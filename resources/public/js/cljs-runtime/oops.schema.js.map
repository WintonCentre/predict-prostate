{"version":3,"sources":["oops/schema.cljs"],"mappings":"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","names":["oops.schema/escaped-dot-marker","oops.schema/re-all-escaped-dots","js/RegExp","oops.schema/re-all-escaped-dot-markers","oops.schema/unescape-modifiers","s","oops.schema/parse-selector-element!","element-str","arr","cljs.core/empty?","G__50073","cljs.core/first","oops.schema/unescape-dots","oops.schema/parse-selector-string!","selector-str","elements-arr","items","cljs.core/seq","cljs.core/next","oops.schema/coerce-key-dynamically!","key","cljs.core/name","oops.schema/collect-coerced-keys-into-array!","coll","item","cljs.core/-first","cljs.core/sequential?","oops.schema/standalone-modifier?","i","cljs.core._EQ_","oops.schema/merge-standalone-modifier!","oops.schema/merge-standalone-modifiers!","len","finger","oops.schema/prepare-path!","selector","oops.schema/prepare-simple-path!","oops.schema/has-invalid-path-access-mode?","path","is-valid?","G__50091","oops.schema/check-dynamic-path!","op","G__50095","js/Error","p1__50093#","cljs.core.not_EQ_","p1__50094#"],"sourcesContent":["(ns oops.schema\n  \"The code for runtime conversion of selectors to paths. Note: we prefer hand-written loops for performance reasons.\"\n  (:require-macros [oops.schema]\n                   [oops.helpers :refer [unchecked-aget]]\n                   [oops.debug :refer [debug-assert]]\n                   [oops.constants :refer [get-dot-access get-soft-access get-punch-access gen-op-get gen-op-set]]))\n\n; implementation here should mimic static versions in schema.clj\n; for performance reasons we don't reuse the same code on cljs side\n\n; --- path utils ------------------------------------------------------------------------------------------------------------\n\n(def escaped-dot-marker \"####ESCAPED-DOT####\")\n(def re-all-escaped-dots (js/RegExp. \"\\\\\\\\\\\\.\" \"g\"))\n(def re-all-escaped-dot-markers (js/RegExp. \"####ESCAPED-DOT####\" \"g\"))\n\n(defn unescape-modifiers [s]\n  (.replace s #\"^\\\\([?!])\" \"$1\"))\n\n(defn parse-selector-element! [element-str arr]\n  (when-not (empty? element-str)\n    (case (first element-str)\n      \"?\" (do\n            (.push arr (get-soft-access))\n            (.push arr (.substring element-str 1)))\n      \"!\" (do\n            (.push arr (get-punch-access))\n            (.push arr (.substring element-str 1)))\n      (do\n        (.push arr (get-dot-access))\n        (.push arr (unescape-modifiers element-str))))))\n\n(defn unescape-dots [s]\n  (.replace s re-all-escaped-dot-markers \".\"))\n\n(defn parse-selector-string! [selector-str arr]\n  (let [elements-arr (.split (.replace selector-str re-all-escaped-dots escaped-dot-marker) \".\")]\n    (loop [items (seq elements-arr)]\n      (when items\n        (parse-selector-element! (unescape-dots (first items)) arr)\n        (recur (next items))))))\n\n(defn coerce-key-dynamically! [key arr]\n  (let [selector-str (name key)]\n    (parse-selector-string! selector-str arr)))\n\n(defn collect-coerced-keys-into-array! [coll arr]\n  (loop [items (seq coll)]                                                                                                    ; note: items is either a seq or nil\n    (when (some? items)\n      (let [item (-first items)]\n        (if (sequential? item)\n          (collect-coerced-keys-into-array! item arr)\n          (coerce-key-dynamically! item arr))\n        (recur (next items))))))\n\n(defn standalone-modifier? [arr i]\n  (and (pos? (unchecked-aget arr i))\n       (= \"\" (unchecked-aget arr (inc i)))))\n\n(defn merge-standalone-modifier! [arr i]\n  (aset arr (+ i 2) (unchecked-aget arr i))                                                                                   ; transfer modifier\n  (.splice arr i 2))                                                                                                          ; remove standalone item\n\n(defn merge-standalone-modifiers! [arr]\n  (let [len (alength arr)]\n    (loop [i (- len 2)]                                                                                                       ; -2 because it makes no sense to potentially merge last item\n      (let [finger (- i 2)]\n        (if (neg? finger)\n          arr\n          (do\n            (when (standalone-modifier? arr finger)\n              (merge-standalone-modifier! arr finger))\n            (recur finger)))))))\n\n(defn prepare-path! [selector arr]\n  (collect-coerced-keys-into-array! selector arr)\n  (merge-standalone-modifiers! arr))\n\n(defn prepare-simple-path! [key arr]\n  (coerce-key-dynamically! key arr))\n\n(defn has-invalid-path-access-mode? [path is-valid?]\n  (loop [items (seq path)]\n    (when items\n      (if (is-valid? (first items))\n        (recur (next (next items)))\n        true))))\n\n; we should mimic check-static-path! here\n(defn check-dynamic-path! [path op]\n  (debug-assert (= (gen-op-get) 0))\n  (debug-assert (= (gen-op-set) 1))\n  (if (empty? path)\n    [:unexpected-empty-selector]\n    (case op\n      0 (when (has-invalid-path-access-mode? path #(not= % (get-punch-access)))\n          [:unexpected-punching-selector])\n      1 (when (has-invalid-path-access-mode? path #(not= % (get-soft-access)))\n          [:unexpected-soft-selector]))))\n"]}