{"version":3,"sources":["oops/sdefs.cljs"],"mappings":";AAQA,AAAAA,yBAAA,AAAA,+EAAA,AAAA,wXAAiB,AAAAC,6BAAA,mFAAA,0DAAA,kEAAA,AAAA,6PAAA,4IAAA,zDAAcC,wBACCC;AAChC,AAAAH,yBAAA,AAAA,uFAAA,AAAA,+dAAsB,AAAAC,6BAAA,mFAAA,oDAAA,oEAAA,AAAA,wWAAA,mFAAA,+EACgB,AAAAA,6BAAA,mFAAA,sDAAA,6EAAA,AAAA,koCAAA,mFAAA,AAAAG,yBAAA,AAAA,uFAAA,wFAAA,WAAAC;AAAA,AAAA,SAAA,AAAAC,uBAAAD,+BAAA,AAAAE,uBAAA,AAAAC,gDAAAC,6BAAA,wFAAAJ;yBADhB,dACgB;AAMtC,AAAAL,yBAAA,AAAA,0FAAA,AAAA,oZAAA,mGAAyB,lBAAiB,SAAkB;AAC5D,AAAAA,yBAAA,AAAA,yFAAA,AAAA,iFAAsBE;AACtB,AAAAF,yBAAA,AAAA,yFAAA,AAAA,2RAAuB,AAAAU,yDAAA,AAAA,8QAAA,mFAAA,0FAAA;AACvB,AAAAV,yBAAA,AAAA,+EAAA,AAAA,kzCAAkB,AAAAW,8BAAA,AAAA,wyCAAA,mFAAOL,uBAAO,WAAKM;AAAL,AACE,IAAMC,QAAM,AAACC,4CAAIC,cAAI,sDAAA,tDAACC,0DAAgBJ;AAAtC,AACE,OAACK,2DAAS,AAAAb,yBAAA,AAAA,yFAAA,0FAAsBS;WAFlD","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha/or-spec-impl","cljs.core/string?","cljs.core/keyword?","cljs.spec.alpha/rep-impl","p1__35363__35364__auto__","cljs.core/array?","cljs.core/every?","cljs.core.partial","cljs.spec.alpha/valid?","cljs.spec.alpha.tuple_impl","cljs.spec.alpha/and-spec-impl","arr","pairs","cljs.core.map","cljs.core/vec","cljs.core.partition_all","cljs.spec.alpha.valid_QMARK_"],"sourcesContent":["(ns oops.sdefs\n  \"Spec definitions for our dynamic code.\"\n  (:require-macros [oops.constants :refer [get-dot-access get-soft-access get-punch-access]]\n                   [oops.spec :refer [native-array-aware-*]])\n  (:require [clojure.spec.alpha :as s]))\n\n; --- specs -----------------------------------------------------------------------------------------------------------------\n\n(s/def ::obj-key (s/or :string string?\n                       :keyword keyword?))\n(s/def ::obj-selector (s/or :key ::obj-key\n                            :selector (native-array-aware-* ::obj-selector)))\n\n; note: ::obj-path is a native array for performance reasons\n;       it is not a sequence of tuples, but it is flat sequence of pairs mode-key\n;       for an example clj path [[0 \"key1\"] [0 \"key2\"] ...]\n;       the equivalent cljs path is [0 \"key1\" 0 \"key2\"]\n(s/def ::obj-path-mode #{(get-dot-access) (get-soft-access) (get-punch-access)})\n(s/def ::obj-path-key string?)\n(s/def ::obj-path-item (s/tuple ::obj-path-mode ::obj-path-key))\n(s/def ::obj-path (s/and array? (fn [arr]\n                                  (let [pairs (map vec (partition-all 2 arr))]\n                                    (s/valid? (s/* ::obj-path-item) pairs)))))\n"]}