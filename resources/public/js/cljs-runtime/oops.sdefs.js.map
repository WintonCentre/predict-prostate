{"version":3,"sources":["oops/sdefs.cljs"],"mappings":";AAQA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAiB,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAcC,AACCC;AAChC,AAAAH,AAAA,AAAA,AAAA,AAAA,AAAsB,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACgB,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAG,AAAA,AAAA,AAAA,AAAA,AAAAC;AAAA,AAAA,AAAA,AAAAC,AAAAD,AAAA,AAAAE,AAAA,AAAAC,AAAAC,AAAA,AAAAJ;AADhB,AACgB;AAMtC,AAAAL,AAAA,AAAA,AAAA,AAAA,AAAA,AAAyB,AAAiB,AAAkB;AAC5D,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAsBE;AACtB,AAAAF,AAAA,AAAA,AAAA,AAAA,AAAuB,AAAAU,AAAA,AAAA,AAAA,AAAA,AAAA;AACvB,AAAAV,AAAA,AAAA,AAAA,AAAA,AAAkB,AAAAW,AAAA,AAAA,AAAA,AAAOL,AAAO,AAAKM;AAAL,AACE,AAAMC,AAAM,AAACC,AAAIC,AAAI,AAAA,AAACC,AAAgBJ;AAAtC,AACE,AAACK,AAAS,AAAAb,AAAA,AAAA,AAAA,AAAsBS;AAFlD","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha/or-spec-impl","cljs.core/string?","cljs.core/keyword?","cljs.spec.alpha/rep-impl","p1__43522__43524__auto__","cljs.core/array?","cljs.core/every?","cljs.core.partial","cljs.spec.alpha/valid?","cljs.spec.alpha.tuple_impl","cljs.spec.alpha/and-spec-impl","arr","pairs","cljs.core.map","cljs.core/vec","cljs.core.partition_all","cljs.spec.alpha.valid_QMARK_"],"sourcesContent":["(ns oops.sdefs\n  \"Spec definitions for our dynamic code.\"\n  (:require-macros [oops.constants :refer [get-dot-access get-soft-access get-punch-access]]\n                   [oops.spec :refer [native-array-aware-*]])\n  (:require [clojure.spec.alpha :as s]))\n\n; --- specs -----------------------------------------------------------------------------------------------------------------\n\n(s/def ::obj-key (s/or :string string?\n                       :keyword keyword?))\n(s/def ::obj-selector (s/or :key ::obj-key\n                            :selector (native-array-aware-* ::obj-selector)))\n\n; note: ::obj-path is a native array for performance reasons\n;       it is not a sequence of tuples, but it is flat sequence of pairs mode-key\n;       for an example clj path [[0 \"key1\"] [0 \"key2\"] ...]\n;       the equivalent cljs path is [0 \"key1\" 0 \"key2\"]\n(s/def ::obj-path-mode #{(get-dot-access) (get-soft-access) (get-punch-access)})\n(s/def ::obj-path-key string?)\n(s/def ::obj-path-item (s/tuple ::obj-path-mode ::obj-path-key))\n(s/def ::obj-path (s/and array? (fn [arr]\n                                  (let [pairs (map vec (partition-all 2 arr))]\n                                    (s/valid? (s/* ::obj-path-item) pairs)))))\n"]}