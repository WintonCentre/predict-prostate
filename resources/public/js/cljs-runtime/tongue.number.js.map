{"version":3,"sources":["tongue/number.cljc"],"mappings":";AAOA,AAMA;;;;;;;;;0BAAA,1BAAMA,4DAQHC;AARH,AASE;AAEA,IAAAC,aAE6BD;IAF7BC,iBAAA,AAAAC,4BAAAD;cAAA,AAAAE,4CAAAF,eAAA,2DAAA,hIAAcG;YAAd,AAAAD,4CAAAF,eAAA,sDAAA,zHAAsBI;AAAtB,AAGE,GACE,EAAK,6CAAA,7CAACE,iDAAMH,cAAU,6CAAA,7CAACG,gDAAKF;AAC5BG;;AAFF,GAIE,6CAAA,7CAACD,gDAAKF;AAJR,kBAAAC;AAAA,AAKG,4FAAA,rFAACG,uBAAY,4CAAAH,sBAAYF;;;AAL5B,AAQE,kBAAKM;AAAL,AACE,IAAAC,aAA0C,qBAAA,rBAACM,yCAAgC,4CAAKP;QAAhF,AAAAE,4CAAAD,WAAA,IAAA,/DAAOE;WAAP,AAAAD,4CAAAD,WAAA,IAAA,lEAASG;mBAAT,AAAAF,4CAAAD,WAAA,IAAA,1EAAcI;oBAAd,AAAAH,4CAAAD,WAAA,IAAA,3EAA2BK;IACrBE,MAAI,AAACC,gBAAMJ;AADjB,AAEE,oDAAKD,MACA,iBAAOM,MAAI,kBAAA,lBAACC,cAAIH;IACTI,MAAI,0DAAA,1DAACC,6CAAKR,iBAAe,kBAAA,lBAACM,cAAIH;;AADrC,AAEE,GAAI,CAAGE,MAAIF;AACT,eAAO,OAAA,NAAGE;eAAO,CAAKE,gDAAI,eAAA,MAAA,nBAAM,OAAA,NAAMF,YAAKf,aAAO,AAACkB,6CAAKR,aAAaK,IAAI,OAAA,NAAGA;;;;;AAC5EE;;;;KACJ,qEAAA,2HAAA,9LAAM,gDAAA,hDAACE,mDAAQR,gBACb,6CAAKZ,qDAASY","names":["tongue.number/formatter","opts","map__42459","cljs.core/--destructure-map","cljs.core.get","decimal","group","p1__42456#","cljs.core._EQ_","cljs.core/str","clojure.string/replace","x","vec__42462","cljs.core.nth","_","sign","integer-part","fraction-part","cljs.core/re-matches","len","cljs.core/count","idx","cljs.core/rem","res","cljs.core.subs","cljs.core.not_EQ_"],"sourcesContent":["(ns tongue.number\n  (:require\n    [clojure.string :as str]\n    [tongue.macro :as macro]\n    #?(:clj [clojure.spec.alpha :as spec])))\n\n\n(macro/with-spec\n  (spec/def ::decimal string?)\n  (spec/def ::group string?)\n  (spec/def ::options (spec/keys :opt-un [::decimal ::group])))\n\n\n(defn formatter\n  \"Helper to build number format functions\n   Accepts options map:\n\n       { :decimal \\\".\\\"  ;; integer/fractional mark\n         :group   \\\"\\\" } ;; thousands grouping mark\n\n   Returns function `(number => String)`\"\n  [opts]\n  (macro/with-spec\n    (spec/assert ::options opts))\n  (let [{:keys [decimal group]\n         :or   { decimal \".\"\n                 group   \"\" }} opts]\n    (cond\n      (and (= \".\" decimal ) (= \"\" group))\n      str\n      \n      (= \"\" group)\n      #(str/replace (str %) \".\" decimal )\n      \n      :else\n      (fn [x]\n        (let [[_ sign integer-part fraction-part] (re-matches #\"(-?)(\\d+)\\.?(\\d*)\" (str x))\n              len (count integer-part)]\n          (str sign\n               (loop [idx (rem len 3)\n                      res (subs integer-part 0 (rem len 3))]\n                 (if (< idx len)\n                   (recur (+ idx 3) (str res (when (pos? idx) group) (subs integer-part idx (+ idx 3))))\n                   res))\n               (when (not= \"\" fraction-part)\n                 (str decimal  fraction-part))))))))\n"]}