{"version":3,"sources":["daiquiri/util.cljc"],"mappings":";AAIA,iCAAA,jCAAMA,0EAAYC;AAAlB,AACE,+CAAA,tCAAI,cAAAC,bAAUD,uCACV,OAASA,oBACT,cAAAE,bAASF;;AAEf,4BAAA,5BAAMG,gEAAaH;AAAnB,AACE,GAAI,OAASA;AACXA;;AACA,IAAAI,aAA2B,wBAAA,xBAAQ,AAACQ,eAAKZ;IAAzCK,aAAA,AAAAC,cAAAF;IAAAG,eAAA,AAAAC,gBAAAH;IAAAA,iBAAA,AAAAI,eAAAJ;iBAAAE,bAAOG;YAAPL,RAAoBM;AAApB,AACE,GAAI,qCAAA,nCAAI,AAACE,uBAAOF,cACR,6CAAA,7CAACG,oDAASJ,iBACV,6CAAA,7CAACI,oDAASJ;AAChBV;;AACA,uDAAA,+FAAI,AAACe,4CAAIC,0BAAeL,nHACpB,AAACM,0HAAKP,5KACNQ,hDACAC;;;;AAEZ,AAAKC,4BAAY,yBAAA,zBAACC;AAElB;;;;2BAAA,3BAAMC,8DAGHtB;AAHH,AAIE,GAAI,AAACD,+BAAWC;AACd,IAAAuB,mBAAI,4CAAA,AAAAC,5CAACC,4DAAKL,2BAAYpB;AAAtB,AAAA,oBAAAuB;AAAAA;;AACI,IAAMG,KAAG,AAACvB,0BAAYH;AAAtB,AACE,yEAAA,8CAAA,vHAAQoB,uHAAAA,9CAAYO,8GAAM3B,EAAE0B;;AAC5BA;;;AACN1B;;;AAEJ,sCAAA,tCAAM4B,oFAAkBC;AAAxB,AACE,kCAAK,oBAAA,WAAAC,iBAAAC,iBAAAC,jEAACC,3BAGDG;AAHA,AAAY,2DAAAN,4DAAAE,hHAACE,qEAAU,yBAAAH,zBAACT;GACb,qBAAA,rBAACa,yDACDN;;AAGlB;;;gCAAA,hCAAMQ,wEAEHR;AAFH,AAGE,GAAI,AAACS,qBAAKT;AACR,IAAMA,QAAE,2BACK,oBAAA,WAAAU,iBAAAC,iBAAAC,jEAACR,3BAEDG;AAFA,AAAY,2DAAAG,4DAAAE,hHAACP,qEAAU,yBAAAM,zBAAClB;4DADxBO,zDAEW,qBAAA,rBAACM;AAFzB,AAIE,IAAAO,WAAQb;AAAR,AAAA,GACE,AAACS,qBAAK,AAAA,qFAAQT;AACd,sDAAAa,SAAA,xDAACC,+GAAcN;;AAFjBK;;;AAGFb;;;AAEJ;;;oCAAA,pCAAMe,gFAEHC;AAFH,AAGE,SAAK,0CAAA,xCAAI,gBAAA5C,fAAU4C,yCACV,gBAAA3C,fAAS2C,sCACT,OAASA,0BACb,EAAI,iEAAA,jEAAC/B,6CAAE,AAACF,eAAKiC,eACT,iEAAA,jEAAC/B,6CAAE,AAACF,eAAKiC;;AAEpB,gCAAA,hCAAMC,wEAAWC;AAAjB,AACE,SAAK,AAACC,wBAAQD,QACT,AAACH,kCAAc,8CAAA,IAAA,lDAACK,4CAAIF;;AAE3B;;;;+BAAA,/BAAMG,sEAGHC;AAHH,AAIE,SAAK,AAACH,wBAAQG,QACT,oEAAAlD,nEAAU,8CAAA,IAAA,lDAACgD,4CAAIE;;AAEtB;;;kCAAA,lCAAMC,4EAEHC;AAFH,AAGE,oEAAA,2CAAA,wDAAA,gEAAA,oDAAA,pRAACC,wBAAY,AAACjB,8BAAgBgB;;AAIhC;;;6BAAA,7BAAME,kEAEHC;AAFH,6DAIO,6CAAA,7CAACC,8EAAQ,AAACC,6CACA,AAACC,+CAAO,WAAKR,lPAEvB,yDAAA,lDAACjC;AAFiB,AAAQ,GAAI,OAASiC;AAAb,0FAAiBA;;AAAG,OAAC7C,cAAI6C;;0EAFnDK,tEAGU,AAACI,+CAAOC","names":["daiquiri.util/valid-key?","k","cljs.core/Keyword","cljs.core/Symbol","daiquiri.util/-camel-case","vec__40774","seq__40775","cljs.core/seq","first__40776","cljs.core/first","cljs.core/next","first-word","words","cljs.core/name","cljs.core/empty?","cljs.core._EQ_","cljs.core.map","clojure.string/capitalize","cljs.core.conj","clojure.string.join","cljs.core.keyword","daiquiri.util/attrs-cache","cljs.core/volatile!","daiquiri.util/camel-case","or__4212__auto__","cljs.core/deref","cljs.core.get","kk","cljs.core.assoc","daiquiri.util/camel-case-keys*","m","p1__40779#","p2__40780#","p3__40781#","cljs.core/reduce-kv","cljs.core.assoc_BANG_","cljs.core/transient","cljs.core/persistent!","daiquiri.util/camel-case-keys","cljs.core/map?","p1__40782#","p2__40783#","p3__40784#","G__40785","cljs.core.update","daiquiri.util/fragment-tag?","tag","daiquiri.util/fragment?","v","cljs.core/vector?","cljs.core.nth","daiquiri.util/element?","x","daiquiri.util/html-to-dom-attrs","attrs","clojure.set/rename-keys","daiquiri.util/join-classes","classes","cljs.core.into","cljs.core.comp","cljs.core.mapcat","cljs.core.remove","cljs.core/nil?"],"sourcesContent":["(ns daiquiri.util\n  (:require [clojure.set :refer [rename-keys]]\n            [clojure.string :as str]))\n\n(defn valid-key? [k]\n  (or (keyword? k)\n      (string? k)\n      (symbol? k)))\n\n(defn -camel-case [k]\n  (if (string? k)\n    k\n    (let [[first-word & words] (.split (name k) \"-\")]\n      (if (or (empty? words)\n              (= \"aria\" first-word)\n              (= \"data\" first-word))\n        k\n        (-> (map str/capitalize words)\n            (conj first-word)\n            str/join\n            keyword)))))\n\n(def attrs-cache (volatile! {}))\n\n(defn camel-case\n  \"Returns camel case version of the key, e.g. :http-equiv becomes :httpEquiv.\n  Does not convert string attributes.\"\n  [k]\n  (if (valid-key? k)\n    (or (get @attrs-cache k)\n        (let [kk (-camel-case k)]\n          (vswap! attrs-cache assoc k kk)\n          kk))\n    k))\n\n(defn camel-case-keys* [m]\n  (->> (reduce-kv #(assoc! %1 (camel-case %2) %3)\n                  (transient {})\n                  m)\n       persistent!))\n\n(defn camel-case-keys\n  \"Recursively transforms all map keys into camel case.\"\n  [m]\n  (if (map? m)\n    (let [m (->> m\n                 (reduce-kv #(assoc! %1 (camel-case %2) %3)\n                            (transient {}))\n                 persistent!)]\n      (cond-> m\n        (map? (:style m))\n        (update :style camel-case-keys)))\n    m))\n\n(defn fragment-tag?\n  \"Returns true if `tag` is the fragment tag \\\"*\\\" or \\\"<>\\\", otherwise false.\"\n  [tag]\n  (and (or (keyword? tag)\n           (symbol? tag)\n           (string? tag))\n       (or (= (name tag) \"*\")\n           (= (name tag) \"<>\"))))\n\n(defn fragment? [v]\n  (and (vector? v)\n       (fragment-tag? (nth v 0 nil))))\n\n(defn element?\n  \"Return true if `x` is an HTML element. True when `x` is a vector\n  and the first element is a keyword, e.g. `[:div]` or `[:div [:span \\\"x\\\"]`.\"\n  [x]\n  (and (vector? x)\n       (keyword? (nth x 0 nil))))\n\n(defn html-to-dom-attrs\n  \"Converts all HTML attributes to their DOM equivalents.\"\n  [attrs]\n  (rename-keys (camel-case-keys attrs)\n               {:class :className\n                :for :htmlFor}))\n\n(defn join-classes\n  \"Join the `classes` with a whitespace.\"\n  [classes]\n  (->> classes\n       (into [] (comp\n                 (mapcat (fn [x] (if (string? x) [x] (seq x))))\n                 (remove nil?)))\n       (str/join \" \")))\n"]}