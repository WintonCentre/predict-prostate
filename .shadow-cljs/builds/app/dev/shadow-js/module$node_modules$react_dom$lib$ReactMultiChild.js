["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactMultiChild.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactMultiChild=function(global,process,require,module,exports,shadow$shims){function enqueue(queue,update){update&&(queue=queue||[],queue.push(update));return queue}require(\"module$node_modules$react_dom$lib$reactProdInvariant\");var ReactComponentEnvironment=require(\"module$node_modules$react_dom$lib$ReactComponentEnvironment\"),ReactInstanceMap=require(\"module$node_modules$react_dom$lib$ReactInstanceMap\"),ReactInstrumentation=require(\"module$node_modules$react_dom$lib$ReactInstrumentation\"),\nReactCurrentOwner=require(\"module$node_modules$react$lib$ReactCurrentOwner\"),ReactReconciler=require(\"module$node_modules$react_dom$lib$ReactReconciler\"),ReactChildReconciler=require(\"module$node_modules$react_dom$lib$ReactChildReconciler\");global=require(\"module$node_modules$fbjs$lib$emptyFunction\");var flattenChildren=require(\"module$node_modules$react_dom$lib$flattenChildren\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),setChildrenForInstrumentation=global,getDebugID=function(inst){if(!inst._debugID){var internal;\nif(internal=ReactInstanceMap.get(inst))inst=internal}return inst._debugID};setChildrenForInstrumentation=function(children){var debugID=getDebugID(this);if(0!==debugID)ReactInstrumentation.debugTool.onSetChildren(debugID,children?Object.keys(children).map(function(key){return children[key]._debugID}):[])};module.exports={Mixin:{_reconcilerInstantiateChildren:function(nestedChildren,transaction,context){var selfDebugID=getDebugID(this);if(this._currentElement)try{return ReactCurrentOwner.current=this._currentElement._owner,\nReactChildReconciler.instantiateChildren(nestedChildren,transaction,context,selfDebugID)}finally{ReactCurrentOwner.current=null}return ReactChildReconciler.instantiateChildren(nestedChildren,transaction,context)},_reconcilerUpdateChildren:function(prevChildren,nextNestedChildrenElements,mountImages,removedNodes,transaction,context){var selfDebugID=getDebugID(this);if(this._currentElement){try{ReactCurrentOwner.current=this._currentElement._owner;var nextChildren=flattenChildren(nextNestedChildrenElements,\nselfDebugID)}finally{ReactCurrentOwner.current=null}ReactChildReconciler.updateChildren(prevChildren,nextChildren,mountImages,removedNodes,transaction,this,this._hostContainerInfo,context,selfDebugID);return nextChildren}nextChildren=flattenChildren(nextNestedChildrenElements,selfDebugID);ReactChildReconciler.updateChildren(prevChildren,nextChildren,mountImages,removedNodes,transaction,this,this._hostContainerInfo,context,selfDebugID);return nextChildren},mountChildren:function(nestedChildren,transaction,\ncontext){this._renderedChildren=nestedChildren=this._reconcilerInstantiateChildren(nestedChildren,transaction,context);var mountImages=[],index=0,name;for(name in nestedChildren)if(nestedChildren.hasOwnProperty(name)){var child=nestedChildren[name];var selfDebugID=getDebugID(this);selfDebugID=ReactReconciler.mountComponent(child,transaction,this,this._hostContainerInfo,context,selfDebugID);child._mountIndex=index++;mountImages.push(selfDebugID)}setChildrenForInstrumentation.call(this,nestedChildren);\nreturn mountImages},updateTextContent:function(nextContent){var prevChildren=this._renderedChildren;ReactChildReconciler.unmountChildren(prevChildren,!1);for(var name in prevChildren)prevChildren.hasOwnProperty(name)&&invariant(!1,\"updateTextContent called on non-empty component.\");ReactComponentEnvironment.processChildrenUpdates(this,[{type:\"TEXT_CONTENT\",content:nextContent,fromIndex:null,fromNode:null,toIndex:null,afterNode:null}])},updateMarkup:function(nextMarkup){var prevChildren=this._renderedChildren;\nReactChildReconciler.unmountChildren(prevChildren,!1);for(var name in prevChildren)prevChildren.hasOwnProperty(name)&&invariant(!1,\"updateTextContent called on non-empty component.\");ReactComponentEnvironment.processChildrenUpdates(this,[{type:\"SET_MARKUP\",content:nextMarkup,fromIndex:null,fromNode:null,toIndex:null,afterNode:null}])},updateChildren:function(nextNestedChildrenElements,transaction,context){this._updateChildren(nextNestedChildrenElements,transaction,context)},_updateChildren:function(nextNestedChildrenElements,\ntransaction,context){var prevChildren=this._renderedChildren,removedNodes={},mountImages=[];if((nextNestedChildrenElements=this._reconcilerUpdateChildren(prevChildren,nextNestedChildrenElements,mountImages,removedNodes,transaction,context))||prevChildren){var updates=null,name,nextIndex=0,lastIndex=0,nextMountIndex=0,lastPlacedNode=null;for(name in nextNestedChildrenElements)if(nextNestedChildrenElements.hasOwnProperty(name)){var prevChild=prevChildren&&prevChildren[name],nextChild=nextNestedChildrenElements[name];\nprevChild===nextChild?(updates=enqueue(updates,this.moveChild(prevChild,lastPlacedNode,nextIndex,lastIndex)),lastIndex=Math.max(prevChild._mountIndex,lastIndex),prevChild._mountIndex=nextIndex):(prevChild&&(lastIndex=Math.max(prevChild._mountIndex,lastIndex)),updates=enqueue(updates,this._mountChildAtIndex(nextChild,mountImages[nextMountIndex],lastPlacedNode,nextIndex,transaction,context)),nextMountIndex++);nextIndex++;lastPlacedNode=ReactReconciler.getHostNode(nextChild)}for(name in removedNodes)removedNodes.hasOwnProperty(name)&&\n(updates=enqueue(updates,this._unmountChild(prevChildren[name],removedNodes[name])));updates&&ReactComponentEnvironment.processChildrenUpdates(this,updates);this._renderedChildren=nextNestedChildrenElements;setChildrenForInstrumentation.call(this,nextNestedChildrenElements)}},unmountChildren:function(safely){ReactChildReconciler.unmountChildren(this._renderedChildren,safely);this._renderedChildren=null},moveChild:function(child,afterNode,toIndex,lastIndex){if(child._mountIndex<lastIndex)return{type:\"MOVE_EXISTING\",\ncontent:null,fromIndex:child._mountIndex,fromNode:ReactReconciler.getHostNode(child),toIndex:toIndex,afterNode:afterNode}},createChild:function(child,afterNode,mountImage){return{type:\"INSERT_MARKUP\",content:mountImage,fromIndex:null,fromNode:null,toIndex:child._mountIndex,afterNode:afterNode}},removeChild:function(child,node){return{type:\"REMOVE_NODE\",content:null,fromIndex:child._mountIndex,fromNode:node,toIndex:null,afterNode:null}},_mountChildAtIndex:function(child,mountImage,afterNode,index,\ntransaction,context){child._mountIndex=index;return this.createChild(child,afterNode,mountImage)},_unmountChild:function(child,node){node=this.removeChild(child,node);child._mountIndex=null;return node}}}}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactMultiChild\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactInstrumentation = require('./ReactInstrumentation');\n\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactChildReconciler = require('./ReactChildReconciler');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar flattenChildren = require('./flattenChildren');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Make an update for markup to be rendered and inserted at a supplied index.\n *\n * @param {string} markup Markup that renders into an element.\n * @param {number} toIndex Destination index.\n * @private\n */\nfunction makeInsertMarkup(markup, afterNode, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: 'INSERT_MARKUP',\n    content: markup,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: toIndex,\n    afterNode: afterNode\n  };\n}\n\n/**\n * Make an update for moving an existing element to another index.\n *\n * @param {number} fromIndex Source index of the existing element.\n * @param {number} toIndex Destination index of the element.\n * @private\n */\nfunction makeMove(child, afterNode, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: 'MOVE_EXISTING',\n    content: null,\n    fromIndex: child._mountIndex,\n    fromNode: ReactReconciler.getHostNode(child),\n    toIndex: toIndex,\n    afterNode: afterNode\n  };\n}\n\n/**\n * Make an update for removing an element at an index.\n *\n * @param {number} fromIndex Index of the element to remove.\n * @private\n */\nfunction makeRemove(child, node) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: 'REMOVE_NODE',\n    content: null,\n    fromIndex: child._mountIndex,\n    fromNode: node,\n    toIndex: null,\n    afterNode: null\n  };\n}\n\n/**\n * Make an update for setting the markup of a node.\n *\n * @param {string} markup Markup that renders into an element.\n * @private\n */\nfunction makeSetMarkup(markup) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: 'SET_MARKUP',\n    content: markup,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: null,\n    afterNode: null\n  };\n}\n\n/**\n * Make an update for setting the text content.\n *\n * @param {string} textContent Text content to set.\n * @private\n */\nfunction makeTextContent(textContent) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: 'TEXT_CONTENT',\n    content: textContent,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: null,\n    afterNode: null\n  };\n}\n\n/**\n * Push an update, if any, onto the queue. Creates a new queue if none is\n * passed and always returns the queue. Mutative.\n */\nfunction enqueue(queue, update) {\n  if (update) {\n    queue = queue || [];\n    queue.push(update);\n  }\n  return queue;\n}\n\n/**\n * Processes any enqueued updates.\n *\n * @private\n */\nfunction processQueue(inst, updateQueue) {\n  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);\n}\n\nvar setChildrenForInstrumentation = emptyFunction;\nif (process.env.NODE_ENV !== 'production') {\n  var getDebugID = function (inst) {\n    if (!inst._debugID) {\n      // Check for ART-like instances. TODO: This is silly/gross.\n      var internal;\n      if (internal = ReactInstanceMap.get(inst)) {\n        inst = internal;\n      }\n    }\n    return inst._debugID;\n  };\n  setChildrenForInstrumentation = function (children) {\n    var debugID = getDebugID(this);\n    // TODO: React Native empty components are also multichild.\n    // This means they still get into this method but don't have _debugID.\n    if (debugID !== 0) {\n      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {\n        return children[key]._debugID;\n      }) : []);\n    }\n  };\n}\n\n/**\n * ReactMultiChild are capable of reconciling multiple children.\n *\n * @class ReactMultiChild\n * @internal\n */\nvar ReactMultiChild = {\n\n  /**\n   * Provides common functionality for components that must reconcile multiple\n   * children. This is used by `ReactDOMComponent` to mount, update, and\n   * unmount child components.\n   *\n   * @lends {ReactMultiChild.prototype}\n   */\n  Mixin: {\n\n    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {\n      if (process.env.NODE_ENV !== 'production') {\n        var selfDebugID = getDebugID(this);\n        if (this._currentElement) {\n          try {\n            ReactCurrentOwner.current = this._currentElement._owner;\n            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);\n          } finally {\n            ReactCurrentOwner.current = null;\n          }\n        }\n      }\n      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);\n    },\n\n    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {\n      var nextChildren;\n      var selfDebugID = 0;\n      if (process.env.NODE_ENV !== 'production') {\n        selfDebugID = getDebugID(this);\n        if (this._currentElement) {\n          try {\n            ReactCurrentOwner.current = this._currentElement._owner;\n            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\n          } finally {\n            ReactCurrentOwner.current = null;\n          }\n          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\n          return nextChildren;\n        }\n      }\n      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\n      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\n      return nextChildren;\n    },\n\n    /**\n     * Generates a \"mount image\" for each of the supplied children. In the case\n     * of `ReactDOMComponent`, a mount image is a string of markup.\n     *\n     * @param {?object} nestedChildren Nested child maps.\n     * @return {array} An array of mounted representations.\n     * @internal\n     */\n    mountChildren: function (nestedChildren, transaction, context) {\n      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);\n      this._renderedChildren = children;\n\n      var mountImages = [];\n      var index = 0;\n      for (var name in children) {\n        if (children.hasOwnProperty(name)) {\n          var child = children[name];\n          var selfDebugID = 0;\n          if (process.env.NODE_ENV !== 'production') {\n            selfDebugID = getDebugID(this);\n          }\n          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);\n          child._mountIndex = index++;\n          mountImages.push(mountImage);\n        }\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        setChildrenForInstrumentation.call(this, children);\n      }\n\n      return mountImages;\n    },\n\n    /**\n     * Replaces any rendered children with a text content string.\n     *\n     * @param {string} nextContent String of content.\n     * @internal\n     */\n    updateTextContent: function (nextContent) {\n      var prevChildren = this._renderedChildren;\n      // Remove any rendered children.\n      ReactChildReconciler.unmountChildren(prevChildren, false);\n      for (var name in prevChildren) {\n        if (prevChildren.hasOwnProperty(name)) {\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\n        }\n      }\n      // Set new text content.\n      var updates = [makeTextContent(nextContent)];\n      processQueue(this, updates);\n    },\n\n    /**\n     * Replaces any rendered children with a markup string.\n     *\n     * @param {string} nextMarkup String of markup.\n     * @internal\n     */\n    updateMarkup: function (nextMarkup) {\n      var prevChildren = this._renderedChildren;\n      // Remove any rendered children.\n      ReactChildReconciler.unmountChildren(prevChildren, false);\n      for (var name in prevChildren) {\n        if (prevChildren.hasOwnProperty(name)) {\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\n        }\n      }\n      var updates = [makeSetMarkup(nextMarkup)];\n      processQueue(this, updates);\n    },\n\n    /**\n     * Updates the rendered children with new children.\n     *\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    updateChildren: function (nextNestedChildrenElements, transaction, context) {\n      // Hook used by React ART\n      this._updateChildren(nextNestedChildrenElements, transaction, context);\n    },\n\n    /**\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @final\n     * @protected\n     */\n    _updateChildren: function (nextNestedChildrenElements, transaction, context) {\n      var prevChildren = this._renderedChildren;\n      var removedNodes = {};\n      var mountImages = [];\n      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);\n      if (!nextChildren && !prevChildren) {\n        return;\n      }\n      var updates = null;\n      var name;\n      // `nextIndex` will increment for each child in `nextChildren`, but\n      // `lastIndex` will be the last index visited in `prevChildren`.\n      var nextIndex = 0;\n      var lastIndex = 0;\n      // `nextMountIndex` will increment for each newly mounted child.\n      var nextMountIndex = 0;\n      var lastPlacedNode = null;\n      for (name in nextChildren) {\n        if (!nextChildren.hasOwnProperty(name)) {\n          continue;\n        }\n        var prevChild = prevChildren && prevChildren[name];\n        var nextChild = nextChildren[name];\n        if (prevChild === nextChild) {\n          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          prevChild._mountIndex = nextIndex;\n        } else {\n          if (prevChild) {\n            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\n            lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n            // The `removedNodes` loop below will actually remove the child.\n          }\n          // The child must be instantiated before it's mounted.\n          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));\n          nextMountIndex++;\n        }\n        nextIndex++;\n        lastPlacedNode = ReactReconciler.getHostNode(nextChild);\n      }\n      // Remove children that are no longer present.\n      for (name in removedNodes) {\n        if (removedNodes.hasOwnProperty(name)) {\n          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));\n        }\n      }\n      if (updates) {\n        processQueue(this, updates);\n      }\n      this._renderedChildren = nextChildren;\n\n      if (process.env.NODE_ENV !== 'production') {\n        setChildrenForInstrumentation.call(this, nextChildren);\n      }\n    },\n\n    /**\n     * Unmounts all rendered children. This should be used to clean up children\n     * when this component is unmounted. It does not actually perform any\n     * backend operations.\n     *\n     * @internal\n     */\n    unmountChildren: function (safely) {\n      var renderedChildren = this._renderedChildren;\n      ReactChildReconciler.unmountChildren(renderedChildren, safely);\n      this._renderedChildren = null;\n    },\n\n    /**\n     * Moves a child component to the supplied index.\n     *\n     * @param {ReactComponent} child Component to move.\n     * @param {number} toIndex Destination index of the element.\n     * @param {number} lastIndex Last index visited of the siblings of `child`.\n     * @protected\n     */\n    moveChild: function (child, afterNode, toIndex, lastIndex) {\n      // If the index of `child` is less than `lastIndex`, then it needs to\n      // be moved. Otherwise, we do not need to move it because a child will be\n      // inserted or moved before `child`.\n      if (child._mountIndex < lastIndex) {\n        return makeMove(child, afterNode, toIndex);\n      }\n    },\n\n    /**\n     * Creates a child component.\n     *\n     * @param {ReactComponent} child Component to create.\n     * @param {string} mountImage Markup to insert.\n     * @protected\n     */\n    createChild: function (child, afterNode, mountImage) {\n      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);\n    },\n\n    /**\n     * Removes a child component.\n     *\n     * @param {ReactComponent} child Child to remove.\n     * @protected\n     */\n    removeChild: function (child, node) {\n      return makeRemove(child, node);\n    },\n\n    /**\n     * Mounts a child with the supplied name.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to mount.\n     * @param {string} name Name of the child.\n     * @param {number} index Index at which to insert the child.\n     * @param {ReactReconcileTransaction} transaction\n     * @private\n     */\n    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {\n      child._mountIndex = index;\n      return this.createChild(child, afterNode, mountImage);\n    },\n\n    /**\n     * Unmounts a rendered child.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to unmount.\n     * @private\n     */\n    _unmountChild: function (child, node) {\n      var update = this.removeChild(child, node);\n      child._mountIndex = null;\n      return update;\n    }\n\n  }\n\n};\n\nmodule.exports = ReactMultiChild;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_dom$lib$ReactChildReconciler","~$module$node_modules$react_dom$lib$ReactInstrumentation","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$fbjs$lib$emptyFunction","~$module$node_modules$react_dom$lib$reactProdInvariant","~$module$node_modules$react_dom$lib$ReactReconciler","~$module$node_modules$react_dom$lib$ReactInstanceMap","~$module$node_modules$react_dom$lib$ReactComponentEnvironment","~$module$node_modules$react$lib$ReactCurrentOwner","~$module$node_modules$react_dom$lib$flattenChildren"]],"~:properties",["^5",["unmountChildren","Mixin","fromNode","toIndex","_reconcilerInstantiateChildren","createChild","updateChildren","fromIndex","_reconcilerUpdateChildren","moveChild","current","content","_mountIndex","_mountChildAtIndex","_updateChildren","_unmountChild","type","updateTextContent","updateMarkup","_renderedChildren","removeChild","mountChildren","afterNode"]],"~:compiled-at",1635270336846,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactMultiChild.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/ReactMultiChild.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactMultiChild\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\\nvar ReactInstanceMap = require('./ReactInstanceMap');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\n\\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\\nvar ReactReconciler = require('./ReactReconciler');\\nvar ReactChildReconciler = require('./ReactChildReconciler');\\n\\nvar emptyFunction = require('fbjs/lib/emptyFunction');\\nvar flattenChildren = require('./flattenChildren');\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Make an update for markup to be rendered and inserted at a supplied index.\\n *\\n * @param {string} markup Markup that renders into an element.\\n * @param {number} toIndex Destination index.\\n * @private\\n */\\nfunction makeInsertMarkup(markup, afterNode, toIndex) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: 'INSERT_MARKUP',\\n    content: markup,\\n    fromIndex: null,\\n    fromNode: null,\\n    toIndex: toIndex,\\n    afterNode: afterNode\\n  };\\n}\\n\\n/**\\n * Make an update for moving an existing element to another index.\\n *\\n * @param {number} fromIndex Source index of the existing element.\\n * @param {number} toIndex Destination index of the element.\\n * @private\\n */\\nfunction makeMove(child, afterNode, toIndex) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: 'MOVE_EXISTING',\\n    content: null,\\n    fromIndex: child._mountIndex,\\n    fromNode: ReactReconciler.getHostNode(child),\\n    toIndex: toIndex,\\n    afterNode: afterNode\\n  };\\n}\\n\\n/**\\n * Make an update for removing an element at an index.\\n *\\n * @param {number} fromIndex Index of the element to remove.\\n * @private\\n */\\nfunction makeRemove(child, node) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: 'REMOVE_NODE',\\n    content: null,\\n    fromIndex: child._mountIndex,\\n    fromNode: node,\\n    toIndex: null,\\n    afterNode: null\\n  };\\n}\\n\\n/**\\n * Make an update for setting the markup of a node.\\n *\\n * @param {string} markup Markup that renders into an element.\\n * @private\\n */\\nfunction makeSetMarkup(markup) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: 'SET_MARKUP',\\n    content: markup,\\n    fromIndex: null,\\n    fromNode: null,\\n    toIndex: null,\\n    afterNode: null\\n  };\\n}\\n\\n/**\\n * Make an update for setting the text content.\\n *\\n * @param {string} textContent Text content to set.\\n * @private\\n */\\nfunction makeTextContent(textContent) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: 'TEXT_CONTENT',\\n    content: textContent,\\n    fromIndex: null,\\n    fromNode: null,\\n    toIndex: null,\\n    afterNode: null\\n  };\\n}\\n\\n/**\\n * Push an update, if any, onto the queue. Creates a new queue if none is\\n * passed and always returns the queue. Mutative.\\n */\\nfunction enqueue(queue, update) {\\n  if (update) {\\n    queue = queue || [];\\n    queue.push(update);\\n  }\\n  return queue;\\n}\\n\\n/**\\n * Processes any enqueued updates.\\n *\\n * @private\\n */\\nfunction processQueue(inst, updateQueue) {\\n  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);\\n}\\n\\nvar setChildrenForInstrumentation = emptyFunction;\\nif (process.env.NODE_ENV !== 'production') {\\n  var getDebugID = function (inst) {\\n    if (!inst._debugID) {\\n      // Check for ART-like instances. TODO: This is silly/gross.\\n      var internal;\\n      if (internal = ReactInstanceMap.get(inst)) {\\n        inst = internal;\\n      }\\n    }\\n    return inst._debugID;\\n  };\\n  setChildrenForInstrumentation = function (children) {\\n    var debugID = getDebugID(this);\\n    // TODO: React Native empty components are also multichild.\\n    // This means they still get into this method but don't have _debugID.\\n    if (debugID !== 0) {\\n      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {\\n        return children[key]._debugID;\\n      }) : []);\\n    }\\n  };\\n}\\n\\n/**\\n * ReactMultiChild are capable of reconciling multiple children.\\n *\\n * @class ReactMultiChild\\n * @internal\\n */\\nvar ReactMultiChild = {\\n\\n  /**\\n   * Provides common functionality for components that must reconcile multiple\\n   * children. This is used by `ReactDOMComponent` to mount, update, and\\n   * unmount child components.\\n   *\\n   * @lends {ReactMultiChild.prototype}\\n   */\\n  Mixin: {\\n\\n    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        var selfDebugID = getDebugID(this);\\n        if (this._currentElement) {\\n          try {\\n            ReactCurrentOwner.current = this._currentElement._owner;\\n            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);\\n          } finally {\\n            ReactCurrentOwner.current = null;\\n          }\\n        }\\n      }\\n      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);\\n    },\\n\\n    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {\\n      var nextChildren;\\n      var selfDebugID = 0;\\n      if (process.env.NODE_ENV !== 'production') {\\n        selfDebugID = getDebugID(this);\\n        if (this._currentElement) {\\n          try {\\n            ReactCurrentOwner.current = this._currentElement._owner;\\n            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\\n          } finally {\\n            ReactCurrentOwner.current = null;\\n          }\\n          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\\n          return nextChildren;\\n        }\\n      }\\n      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\\n      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\\n      return nextChildren;\\n    },\\n\\n    /**\\n     * Generates a \\\"mount image\\\" for each of the supplied children. In the case\\n     * of `ReactDOMComponent`, a mount image is a string of markup.\\n     *\\n     * @param {?object} nestedChildren Nested child maps.\\n     * @return {array} An array of mounted representations.\\n     * @internal\\n     */\\n    mountChildren: function (nestedChildren, transaction, context) {\\n      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);\\n      this._renderedChildren = children;\\n\\n      var mountImages = [];\\n      var index = 0;\\n      for (var name in children) {\\n        if (children.hasOwnProperty(name)) {\\n          var child = children[name];\\n          var selfDebugID = 0;\\n          if (process.env.NODE_ENV !== 'production') {\\n            selfDebugID = getDebugID(this);\\n          }\\n          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);\\n          child._mountIndex = index++;\\n          mountImages.push(mountImage);\\n        }\\n      }\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        setChildrenForInstrumentation.call(this, children);\\n      }\\n\\n      return mountImages;\\n    },\\n\\n    /**\\n     * Replaces any rendered children with a text content string.\\n     *\\n     * @param {string} nextContent String of content.\\n     * @internal\\n     */\\n    updateTextContent: function (nextContent) {\\n      var prevChildren = this._renderedChildren;\\n      // Remove any rendered children.\\n      ReactChildReconciler.unmountChildren(prevChildren, false);\\n      for (var name in prevChildren) {\\n        if (prevChildren.hasOwnProperty(name)) {\\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\\n        }\\n      }\\n      // Set new text content.\\n      var updates = [makeTextContent(nextContent)];\\n      processQueue(this, updates);\\n    },\\n\\n    /**\\n     * Replaces any rendered children with a markup string.\\n     *\\n     * @param {string} nextMarkup String of markup.\\n     * @internal\\n     */\\n    updateMarkup: function (nextMarkup) {\\n      var prevChildren = this._renderedChildren;\\n      // Remove any rendered children.\\n      ReactChildReconciler.unmountChildren(prevChildren, false);\\n      for (var name in prevChildren) {\\n        if (prevChildren.hasOwnProperty(name)) {\\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\\n        }\\n      }\\n      var updates = [makeSetMarkup(nextMarkup)];\\n      processQueue(this, updates);\\n    },\\n\\n    /**\\n     * Updates the rendered children with new children.\\n     *\\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\\n     * @param {ReactReconcileTransaction} transaction\\n     * @internal\\n     */\\n    updateChildren: function (nextNestedChildrenElements, transaction, context) {\\n      // Hook used by React ART\\n      this._updateChildren(nextNestedChildrenElements, transaction, context);\\n    },\\n\\n    /**\\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\\n     * @param {ReactReconcileTransaction} transaction\\n     * @final\\n     * @protected\\n     */\\n    _updateChildren: function (nextNestedChildrenElements, transaction, context) {\\n      var prevChildren = this._renderedChildren;\\n      var removedNodes = {};\\n      var mountImages = [];\\n      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);\\n      if (!nextChildren && !prevChildren) {\\n        return;\\n      }\\n      var updates = null;\\n      var name;\\n      // `nextIndex` will increment for each child in `nextChildren`, but\\n      // `lastIndex` will be the last index visited in `prevChildren`.\\n      var nextIndex = 0;\\n      var lastIndex = 0;\\n      // `nextMountIndex` will increment for each newly mounted child.\\n      var nextMountIndex = 0;\\n      var lastPlacedNode = null;\\n      for (name in nextChildren) {\\n        if (!nextChildren.hasOwnProperty(name)) {\\n          continue;\\n        }\\n        var prevChild = prevChildren && prevChildren[name];\\n        var nextChild = nextChildren[name];\\n        if (prevChild === nextChild) {\\n          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));\\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\\n          prevChild._mountIndex = nextIndex;\\n        } else {\\n          if (prevChild) {\\n            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\\n            lastIndex = Math.max(prevChild._mountIndex, lastIndex);\\n            // The `removedNodes` loop below will actually remove the child.\\n          }\\n          // The child must be instantiated before it's mounted.\\n          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));\\n          nextMountIndex++;\\n        }\\n        nextIndex++;\\n        lastPlacedNode = ReactReconciler.getHostNode(nextChild);\\n      }\\n      // Remove children that are no longer present.\\n      for (name in removedNodes) {\\n        if (removedNodes.hasOwnProperty(name)) {\\n          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));\\n        }\\n      }\\n      if (updates) {\\n        processQueue(this, updates);\\n      }\\n      this._renderedChildren = nextChildren;\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        setChildrenForInstrumentation.call(this, nextChildren);\\n      }\\n    },\\n\\n    /**\\n     * Unmounts all rendered children. This should be used to clean up children\\n     * when this component is unmounted. It does not actually perform any\\n     * backend operations.\\n     *\\n     * @internal\\n     */\\n    unmountChildren: function (safely) {\\n      var renderedChildren = this._renderedChildren;\\n      ReactChildReconciler.unmountChildren(renderedChildren, safely);\\n      this._renderedChildren = null;\\n    },\\n\\n    /**\\n     * Moves a child component to the supplied index.\\n     *\\n     * @param {ReactComponent} child Component to move.\\n     * @param {number} toIndex Destination index of the element.\\n     * @param {number} lastIndex Last index visited of the siblings of `child`.\\n     * @protected\\n     */\\n    moveChild: function (child, afterNode, toIndex, lastIndex) {\\n      // If the index of `child` is less than `lastIndex`, then it needs to\\n      // be moved. Otherwise, we do not need to move it because a child will be\\n      // inserted or moved before `child`.\\n      if (child._mountIndex < lastIndex) {\\n        return makeMove(child, afterNode, toIndex);\\n      }\\n    },\\n\\n    /**\\n     * Creates a child component.\\n     *\\n     * @param {ReactComponent} child Component to create.\\n     * @param {string} mountImage Markup to insert.\\n     * @protected\\n     */\\n    createChild: function (child, afterNode, mountImage) {\\n      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);\\n    },\\n\\n    /**\\n     * Removes a child component.\\n     *\\n     * @param {ReactComponent} child Child to remove.\\n     * @protected\\n     */\\n    removeChild: function (child, node) {\\n      return makeRemove(child, node);\\n    },\\n\\n    /**\\n     * Mounts a child with the supplied name.\\n     *\\n     * NOTE: This is part of `updateChildren` and is here for readability.\\n     *\\n     * @param {ReactComponent} child Component to mount.\\n     * @param {string} name Name of the child.\\n     * @param {number} index Index at which to insert the child.\\n     * @param {ReactReconcileTransaction} transaction\\n     * @private\\n     */\\n    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {\\n      child._mountIndex = index;\\n      return this.createChild(child, afterNode, mountImage);\\n    },\\n\\n    /**\\n     * Unmounts a rendered child.\\n     *\\n     * NOTE: This is part of `updateChildren` and is here for readability.\\n     *\\n     * @param {ReactComponent} child Component to unmount.\\n     * @private\\n     */\\n    _unmountChild: function (child, node) {\\n      var update = this.removeChild(child, node);\\n      child._mountIndex = null;\\n      return update;\\n    }\\n\\n  }\\n\\n};\\n\\nmodule.exports = ReactMultiChild;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"enqueue\",\"queue\",\"update\",\"push\",\"ReactComponentEnvironment\",\"ReactInstanceMap\",\"ReactInstrumentation\",\"ReactCurrentOwner\",\"ReactReconciler\",\"ReactChildReconciler\",\"emptyFunction\",\"flattenChildren\",\"invariant\",\"setChildrenForInstrumentation\",\"getDebugID\",\"inst\",\"_debugID\",\"internal\",\"get\",\"children\",\"debugID\",\"debugTool\",\"onSetChildren\",\"Object\",\"keys\",\"map\",\"key\",\"ReactMultiChild\",\"Mixin\",\"_reconcilerInstantiateChildren\",\"nestedChildren\",\"transaction\",\"context\",\"selfDebugID\",\"_currentElement\",\"current\",\"_owner\",\"instantiateChildren\",\"_reconcilerUpdateChildren\",\"prevChildren\",\"nextNestedChildrenElements\",\"mountImages\",\"removedNodes\",\"nextChildren\",\"updateChildren\",\"_hostContainerInfo\",\"mountChildren\",\"_renderedChildren\",\"index\",\"name\",\"hasOwnProperty\",\"child\",\"mountImage\",\"mountComponent\",\"_mountIndex\",\"call\",\"updateTextContent\",\"nextContent\",\"unmountChildren\",\"processChildrenUpdates\",\"updates\",\"type\",\"content\",\"fromIndex\",\"fromNode\",\"toIndex\",\"afterNode\",\"updateMarkup\",\"nextMarkup\",\"_updateChildren\",\"nextIndex\",\"lastIndex\",\"nextMountIndex\",\"lastPlacedNode\",\"prevChild\",\"nextChild\",\"moveChild\",\"Math\",\"max\",\"_mountChildAtIndex\",\"getHostNode\",\"_unmountChild\",\"safely\",\"createChild\",\"removeChild\",\"node\"]\n}\n"]