["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactMount.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactMount=function(global,require,module,exports){function getReactRootElementInContainer(container){return container?9===container.nodeType?container.documentElement:container.firstChild:null}function mountComponentIntoNode(wrapperInstance,container,transaction,shouldReuseMarkup,context){if(ReactFeatureFlags.logTopLevelRenders){var markerName=wrapperInstance._currentElement.props.type;markerName=\"React mount: \"+(\"string\"===typeof markerName?markerName:\nmarkerName.displayName||markerName.name);console.time(markerName)}context=ReactReconciler.mountComponent(wrapperInstance,transaction,null,ReactDOMContainerInfo(wrapperInstance,container),context,0);markerName&&console.timeEnd(markerName);wrapperInstance._renderedComponent._topLevelWrapper=wrapperInstance;ReactMount._mountImageIntoNode(context,container,wrapperInstance,shouldReuseMarkup,transaction)}function batchedMountComponentIntoNode(componentInstance,container,shouldReuseMarkup,context){var transaction=\nReactUpdates.ReactReconcileTransaction.getPooled(!shouldReuseMarkup&&ReactDOMFeatureFlags.useCreateElement);transaction.perform(mountComponentIntoNode,null,componentInstance,container,transaction,shouldReuseMarkup,context);ReactUpdates.ReactReconcileTransaction.release(transaction)}function unmountComponentFromNode(instance,container,safely){ReactInstrumentation.debugTool.onBeginFlush();ReactReconciler.unmountComponent(instance,safely);ReactInstrumentation.debugTool.onEndFlush();9===container.nodeType&&\n(container=container.documentElement);for(;container.lastChild;)container.removeChild(container.lastChild)}function hasNonRootReactChild(container){if(container=getReactRootElementInContainer(container))return container=ReactDOMComponentTree.getInstanceFromNode(container),!(!container||!container._hostParent)}function isValidContainer(node){return!(!node||1!==node.nodeType&&9!==node.nodeType&&11!==node.nodeType)}function getTopLevelWrapperInContainer(container){return(container=(container=(container=\ngetReactRootElementInContainer(container))&&ReactDOMComponentTree.getInstanceFromNode(container))&&!container._hostParent?container:null)?container._hostContainerInfo._topLevelWrapper:null}require(\"module$node_modules$react$lib$reactProdInvariant\");var DOMLazyTree=require(\"module$node_modules$react$lib$DOMLazyTree\");global=require(\"module$node_modules$react$lib$DOMProperty\");var ReactBrowserEventEmitter=require(\"module$node_modules$react$lib$ReactBrowserEventEmitter\"),ReactCurrentOwner=require(\"module$node_modules$react$lib$ReactCurrentOwner\"),\nReactDOMComponentTree=require(\"module$node_modules$react$lib$ReactDOMComponentTree\"),ReactDOMContainerInfo=require(\"module$node_modules$react$lib$ReactDOMContainerInfo\"),ReactDOMFeatureFlags=require(\"module$node_modules$react$lib$ReactDOMFeatureFlags\"),ReactElement=require(\"module$node_modules$react$lib$ReactElement\"),ReactFeatureFlags=require(\"module$node_modules$react$lib$ReactFeatureFlags\"),ReactInstanceMap=require(\"module$node_modules$react$lib$ReactInstanceMap\"),ReactInstrumentation=require(\"module$node_modules$react$lib$ReactInstrumentation\"),\nReactMarkupChecksum=require(\"module$node_modules$react$lib$ReactMarkupChecksum\"),ReactReconciler=require(\"module$node_modules$react$lib$ReactReconciler\"),ReactUpdateQueue=require(\"module$node_modules$react$lib$ReactUpdateQueue\"),ReactUpdates=require(\"module$node_modules$react$lib$ReactUpdates\"),emptyObject=require(\"module$node_modules$fbjs$lib$emptyObject\"),instantiateReactComponent=require(\"module$node_modules$react$lib$instantiateReactComponent\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),\nsetInnerHTML=require(\"module$node_modules$react$lib$setInnerHTML\"),shouldUpdateReactComponent=require(\"module$node_modules$react$lib$shouldUpdateReactComponent\"),warning=require(\"module$node_modules$fbjs$lib$warning\"),ATTR_NAME=global.ID_ATTRIBUTE_NAME,ROOT_ATTR_NAME=global.ROOT_ATTRIBUTE_NAME,instancesByReactRootID={},topLevelRootCounter=1,TopLevelWrapper=function(){this.rootID=topLevelRootCounter++};TopLevelWrapper.prototype.isReactComponent={};TopLevelWrapper.displayName=\"TopLevelWrapper\";TopLevelWrapper.prototype.render=\nfunction(){return this.props};var ReactMount={TopLevelWrapper,_instancesByReactRootID:instancesByReactRootID,scrollMonitor:function(container,renderCallback){renderCallback()},_updateRootComponent:function(prevComponent,nextElement,nextContext,container,callback){ReactMount.scrollMonitor(container,function(){ReactUpdateQueue.enqueueElementInternal(prevComponent,nextElement,nextContext);callback&&ReactUpdateQueue.enqueueCallbackInternal(prevComponent,callback)});return prevComponent},_renderNewRootComponent:function(nextElement,\ncontainer,shouldReuseMarkup,context){warning(null==ReactCurrentOwner.current,\"_renderNewRootComponent(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate. Check the render method of %s.\",ReactCurrentOwner.current&&ReactCurrentOwner.current.getName()||\"ReactCompositeComponent\");isValidContainer(container)?void 0:invariant(!1,\"_registerComponent(...): Target container is not a DOM element.\");\nReactBrowserEventEmitter.ensureScrollValueMonitoring();nextElement=instantiateReactComponent(nextElement,!1);ReactUpdates.batchedUpdates(batchedMountComponentIntoNode,nextElement,container,shouldReuseMarkup,context);return instancesByReactRootID[nextElement._instance.rootID]=nextElement},renderSubtreeIntoContainer:function(parentComponent,nextElement,container,callback){null!=parentComponent&&ReactInstanceMap.has(parentComponent)?void 0:invariant(!1,\"parentComponent must be a valid React Component\");\nreturn ReactMount._renderSubtreeIntoContainer(parentComponent,nextElement,container,callback)},_renderSubtreeIntoContainer:function(parentComponent,nextElement,container,callback){ReactUpdateQueue.validateCallback(callback,\"ReactDOM.render\");ReactElement.isValidElement(nextElement)?void 0:invariant(!1,\"ReactDOM.render(): Invalid component element.%s\",\"string\"===typeof nextElement?\" Instead of passing a string like 'div', pass React.createElement('div') or \\x3cdiv /\\x3e.\":\"function\"===typeof nextElement?\n\" Instead of passing a class like Foo, pass React.createElement(Foo) or \\x3cFoo /\\x3e.\":null!=nextElement&&void 0!==nextElement.props?\" This may be caused by unintentionally loading two independent copies of React.\":\"\");warning(!container||!container.tagName||\"BODY\"!==container.tagName.toUpperCase(),\"render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.\");\nvar nextWrappedElement=ReactElement(TopLevelWrapper,null,null,null,null,null,nextElement);parentComponent?(parentComponent=ReactInstanceMap.get(parentComponent),parentComponent=parentComponent._processChildContext(parentComponent._context)):parentComponent=emptyObject;var prevComponent=getTopLevelWrapperInContainer(container);if(prevComponent){if(shouldUpdateReactComponent(prevComponent._currentElement.props,nextElement)){var publicInst=prevComponent._renderedComponent.getPublicInstance();ReactMount._updateRootComponent(prevComponent,\nnextWrappedElement,parentComponent,container,callback&&function(){callback.call(publicInst)});return publicInst}ReactMount.unmountComponentAtNode(container)}var reactRootElement=getReactRootElementInContainer(container);nextElement=reactRootElement&&!(!reactRootElement.getAttribute||!reactRootElement.getAttribute(ATTR_NAME));var containerHasNonRootReactChild=hasNonRootReactChild(container);warning(!containerHasNonRootReactChild,\"render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.\");\nif(!nextElement||reactRootElement.nextSibling)for(;reactRootElement;){if(reactRootElement.getAttribute&&reactRootElement.getAttribute(ATTR_NAME)){warning(!1,\"render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.\");break}reactRootElement=reactRootElement.nextSibling}container=ReactMount._renderNewRootComponent(nextWrappedElement,container,nextElement&&!prevComponent&&!containerHasNonRootReactChild,\nparentComponent)._renderedComponent.getPublicInstance();callback&&callback.call(container);return container},render:function(nextElement,container,callback){return ReactMount._renderSubtreeIntoContainer(null,nextElement,container,callback)},unmountComponentAtNode:function(container){warning(null==ReactCurrentOwner.current,\"unmountComponentAtNode(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate. Check the render method of %s.\",\nReactCurrentOwner.current&&ReactCurrentOwner.current.getName()||\"ReactCompositeComponent\");isValidContainer(container)?void 0:invariant(!1,\"unmountComponentAtNode(...): Target container is not a DOM element.\");var JSCompiler_inline_result=getReactRootElementInContainer(container);var JSCompiler_temp;(JSCompiler_temp=!JSCompiler_inline_result)||(JSCompiler_temp=!(isValidContainer(JSCompiler_inline_result)&&(JSCompiler_inline_result.hasAttribute(ROOT_ATTR_NAME)||JSCompiler_inline_result.hasAttribute(ATTR_NAME))));\nJSCompiler_inline_result=!(JSCompiler_temp||ReactDOMComponentTree.getInstanceFromNode(JSCompiler_inline_result));warning(!JSCompiler_inline_result,\"unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.\");JSCompiler_inline_result=getTopLevelWrapperInContainer(container);if(!JSCompiler_inline_result)return JSCompiler_inline_result=hasNonRootReactChild(container),container=1===container.nodeType&&container.hasAttribute(ROOT_ATTR_NAME),warning(!JSCompiler_inline_result,\n\"unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s\",container?\"You may have accidentally passed in a React root node instead of its container.\":\"Instead, have the parent component update its state and rerender in order to remove this component.\"),!1;delete instancesByReactRootID[JSCompiler_inline_result._instance.rootID];ReactUpdates.batchedUpdates(unmountComponentFromNode,JSCompiler_inline_result,container,!1);return!0},_mountImageIntoNode:function(markup,\ncontainer,instance,shouldReuseMarkup,transaction){isValidContainer(container)?void 0:invariant(!1,\"mountComponentIntoNode(...): Target container is not valid.\");if(shouldReuseMarkup){var rootElement=getReactRootElementInContainer(container);if(ReactMarkupChecksum.canReuseMarkup(markup,rootElement)){ReactDOMComponentTree.precacheNode(instance,rootElement);return}var checksum=rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\nshouldReuseMarkup=rootElement.outerHTML;rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME,checksum);1===container.nodeType?(checksum=document.createElement(\"div\"),checksum.innerHTML=markup,rootElement=checksum.innerHTML):(checksum=document.createElement(\"iframe\"),document.body.appendChild(checksum),checksum.contentDocument.write(markup),rootElement=checksum.contentDocument.documentElement.outerHTML,document.body.removeChild(checksum));a:{checksum=rootElement;for(var minLen=Math.min(checksum.length,\nshouldReuseMarkup.length),i=0;i<minLen;i++)if(checksum.charAt(i)!==shouldReuseMarkup.charAt(i)){checksum=i;break a}checksum=checksum.length===shouldReuseMarkup.length?-1:minLen}shouldReuseMarkup=\" (client) \"+rootElement.substring(checksum-20,checksum+20)+\"\\n (server) \"+shouldReuseMarkup.substring(checksum-20,checksum+20);9===container.nodeType?invariant(!1,\"You're trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\\n%s\",\nshouldReuseMarkup):void 0;warning(!1,\"React attempted to reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injected new markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server:\\n%s\",shouldReuseMarkup)}9===container.nodeType?invariant(!1,\n\"You're trying to render a component to the document but you didn't use server rendering. We can't do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.\"):void 0;if(transaction.useCreateElement){for(;container.lastChild;)container.removeChild(container.lastChild);DOMLazyTree.insertTreeBefore(container,markup,null)}else setInnerHTML(container,markup),ReactDOMComponentTree.precacheNode(instance,container.firstChild);container=ReactDOMComponentTree.getInstanceFromNode(container.firstChild);\nif(0!==container._debugID)ReactInstrumentation.debugTool.onHostOperation(container._debugID,\"mount\",markup.toString())}};module.exports=ReactMount}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactMount\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar DOMLazyTree = require('./DOMLazyTree');\nvar DOMProperty = require('./DOMProperty');\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\nvar ReactDOMContainerInfo = require('./ReactDOMContainerInfo');\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\nvar ReactElement = require('./ReactElement');\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactInstrumentation = require('./ReactInstrumentation');\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar instantiateReactComponent = require('./instantiateReactComponent');\nvar invariant = require('fbjs/lib/invariant');\nvar setInnerHTML = require('./setInnerHTML');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar warning = require('fbjs/lib/warning');\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\nvar instancesByReactRootID = {};\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n * a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {\n  var markerName;\n  if (ReactFeatureFlags.logTopLevelRenders) {\n    var wrappedElement = wrapperInstance._currentElement.props;\n    var type = wrappedElement.type;\n    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);\n    console.time(markerName);\n  }\n\n  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */\n  );\n\n  if (markerName) {\n    console.timeEnd(markerName);\n  }\n\n  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;\n  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* useCreateElement */\n  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);\n  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Unmounts a component and removes it from the DOM.\n *\n * @param {ReactComponent} instance React component instance.\n * @param {DOMElement} container DOM element to unmount from.\n * @final\n * @internal\n * @see {ReactMount.unmountComponentAtNode}\n */\nfunction unmountComponentFromNode(instance, container, safely) {\n  if (process.env.NODE_ENV !== 'production') {\n    ReactInstrumentation.debugTool.onBeginFlush();\n  }\n  ReactReconciler.unmountComponent(instance, safely);\n  if (process.env.NODE_ENV !== 'production') {\n    ReactInstrumentation.debugTool.onEndFlush();\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    container = container.documentElement;\n  }\n\n  // http://jsperf.com/emptying-a-node\n  while (container.lastChild) {\n    container.removeChild(container.lastChild);\n  }\n}\n\n/**\n * True if the supplied DOM node has a direct React-rendered child that is\n * not a React root element. Useful for warning in `render`,\n * `unmountComponentAtNode`, etc.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM element contains a direct child that was\n * rendered by React but is not a root element.\n * @internal\n */\nfunction hasNonRootReactChild(container) {\n  var rootEl = getReactRootElementInContainer(container);\n  if (rootEl) {\n    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);\n    return !!(inst && inst._hostParent);\n  }\n}\n\n/**\n * True if the supplied DOM node is a React DOM element and\n * it has been rendered by another copy of React.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM has been rendered by another copy of React\n * @internal\n */\nfunction nodeIsRenderedByOtherInstance(container) {\n  var rootEl = getReactRootElementInContainer(container);\n  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));\n}\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));\n}\n\n/**\n * True if the supplied DOM node is a valid React node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid React DOM node.\n * @internal\n */\nfunction isReactNode(node) {\n  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));\n}\n\nfunction getHostRootInstanceInContainer(container) {\n  var rootEl = getReactRootElementInContainer(container);\n  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);\n  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;\n}\n\nfunction getTopLevelWrapperInContainer(container) {\n  var root = getHostRootInstanceInContainer(container);\n  return root ? root._hostContainerInfo._topLevelWrapper : null;\n}\n\n/**\n * Temporary (?) hack so that we can store all top-level pending updates on\n * composites instead of having to worry about different types of components\n * here.\n */\nvar topLevelRootCounter = 1;\nvar TopLevelWrapper = function () {\n  this.rootID = topLevelRootCounter++;\n};\nTopLevelWrapper.prototype.isReactComponent = {};\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\nTopLevelWrapper.prototype.render = function () {\n  // this.props is actually a ReactElement\n  return this.props;\n};\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n\n  TopLevelWrapper: TopLevelWrapper,\n\n  /**\n   * Used by devtools. The keys are not important.\n   */\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    return prevComponent;\n  },\n\n  /**\n   * Render a new component into the DOM. Hooked by hooks!\n   *\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;\n\n    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var componentInstance = instantiateReactComponent(nextElement, false);\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);\n\n    var wrapperID = componentInstance._instance.rootID;\n    instancesByReactRootID[wrapperID] = componentInstance;\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  },\n\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \\'div\\', pass ' + 'React.createElement(\\'div\\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :\n    // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \\'div\\', pass ' + 'React.createElement(\\'div\\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;\n\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;\n\n    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\n\n    var nextContext;\n    if (parentComponent) {\n      var parentInst = ReactInstanceMap.get(parentComponent);\n      nextContext = parentInst._processChildContext(parentInst._context);\n    } else {\n      nextContext = emptyObject;\n    }\n\n    var prevComponent = getTopLevelWrapperInContainer(container);\n\n    if (prevComponent) {\n      var prevWrappedElement = prevComponent._currentElement;\n      var prevElement = prevWrappedElement.props;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\n        var updatedCallback = callback && function () {\n          callback.call(publicInst);\n        };\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);\n        return publicInst;\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;\n\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (internalGetID(rootElementSibling)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;\n            break;\n          }\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;\n\n    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;\n    }\n\n    var prevComponent = getTopLevelWrapperInContainer(container);\n    if (!prevComponent) {\n      // Check if the node being unmounted was rendered by React, but isn't a\n      // root node.\n      var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n      // Check if the container itself is a React root node.\n      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;\n      }\n\n      return false;\n    }\n    delete instancesByReactRootID[prevComponent._instance.rootID];\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);\n    return true;\n  },\n\n  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {\n    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        ReactDOMComponentTree.precacheNode(instance, rootElement);\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n\n        var normalizedMarkup = markup;\n        if (process.env.NODE_ENV !== 'production') {\n          // because rootMarkup is retrieved from the DOM, various normalizations\n          // will have occurred which will not be present in `markup`. Here,\n          // insert markup into a <div> or <iframe> depending on the container\n          // type to perform the same normalizations before comparing.\n          var normalizer;\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\n            normalizer = document.createElement('div');\n            normalizer.innerHTML = markup;\n            normalizedMarkup = normalizer.innerHTML;\n          } else {\n            normalizer = document.createElement('iframe');\n            document.body.appendChild(normalizer);\n            normalizer.contentDocument.write(markup);\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\n            document.body.removeChild(normalizer);\n          }\n        }\n\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\\n%s', difference) : _prodInvariant('42', difference) : void 0;\n\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : void 0;\n        }\n      }\n    }\n\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but you didn\\'t use server rendering. We can\\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;\n\n    if (transaction.useCreateElement) {\n      while (container.lastChild) {\n        container.removeChild(container.lastChild);\n      }\n      DOMLazyTree.insertTreeBefore(container, markup, null);\n    } else {\n      setInnerHTML(container, markup);\n      ReactDOMComponentTree.precacheNode(instance, container.firstChild);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);\n      if (hostNode._debugID !== 0) {\n        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());\n      }\n    }\n  }\n};\n\nmodule.exports = ReactMount;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$lib$ReactDOMComponentTree","~$module$node_modules$react$lib$instantiateReactComponent","~$module$node_modules$react$lib$DOMProperty","~$module$node_modules$react$lib$ReactBrowserEventEmitter","~$module$node_modules$react$lib$ReactFeatureFlags","~$module$node_modules$react$lib$ReactInstanceMap","~$shadow.js","~$module$node_modules$react$lib$setInnerHTML","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react$lib$DOMLazyTree","~$module$node_modules$react$lib$reactProdInvariant","~$module$node_modules$react$lib$ReactUpdateQueue","~$module$node_modules$fbjs$lib$emptyObject","~$module$node_modules$react$lib$ReactElement","~$module$node_modules$react$lib$ReactInstrumentation","~$module$node_modules$react$lib$ReactUpdates","~$module$node_modules$react$lib$ReactReconciler","~$module$node_modules$react$lib$ReactDOMContainerInfo","~$module$node_modules$react$lib$ReactDOMFeatureFlags","~$module$node_modules$fbjs$lib$warning","~$module$node_modules$react$lib$ReactMarkupChecksum","~$module$node_modules$react$lib$shouldUpdateReactComponent","~$module$node_modules$react$lib$ReactCurrentOwner"]],"~:properties",["^5",["_renderSubtreeIntoContainer","TopLevelWrapper","innerHTML","displayName","renderSubtreeIntoContainer","_mountImageIntoNode","_renderNewRootComponent","_topLevelWrapper","scrollMonitor","rootID","_instancesByReactRootID","_updateRootComponent","isReactComponent","render","unmountComponentAtNode"]],"~:compiled-at",1635250628423,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactMount.js\",\n\"lineCount\":26,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/ReactMount.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactMount\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule ReactMount\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar DOMLazyTree = require('./DOMLazyTree');\\nvar DOMProperty = require('./DOMProperty');\\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\\nvar ReactDOMContainerInfo = require('./ReactDOMContainerInfo');\\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\\nvar ReactElement = require('./ReactElement');\\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\\nvar ReactInstanceMap = require('./ReactInstanceMap');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\\nvar ReactReconciler = require('./ReactReconciler');\\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\\nvar ReactUpdates = require('./ReactUpdates');\\n\\nvar emptyObject = require('fbjs/lib/emptyObject');\\nvar instantiateReactComponent = require('./instantiateReactComponent');\\nvar invariant = require('fbjs/lib/invariant');\\nvar setInnerHTML = require('./setInnerHTML');\\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\\nvar warning = require('fbjs/lib/warning');\\n\\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\\nvar ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;\\n\\nvar ELEMENT_NODE_TYPE = 1;\\nvar DOC_NODE_TYPE = 9;\\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\\n\\nvar instancesByReactRootID = {};\\n\\n/**\\n * Finds the index of the first character\\n * that's not common between the two given strings.\\n *\\n * @return {number} the index of the character where the strings diverge\\n */\\nfunction firstDifferenceIndex(string1, string2) {\\n  var minLen = Math.min(string1.length, string2.length);\\n  for (var i = 0; i < minLen; i++) {\\n    if (string1.charAt(i) !== string2.charAt(i)) {\\n      return i;\\n    }\\n  }\\n  return string1.length === string2.length ? -1 : minLen;\\n}\\n\\n/**\\n * @param {DOMElement|DOMDocument} container DOM element that may contain\\n * a React component\\n * @return {?*} DOM element that may have the reactRoot ID, or null.\\n */\\nfunction getReactRootElementInContainer(container) {\\n  if (!container) {\\n    return null;\\n  }\\n\\n  if (container.nodeType === DOC_NODE_TYPE) {\\n    return container.documentElement;\\n  } else {\\n    return container.firstChild;\\n  }\\n}\\n\\nfunction internalGetID(node) {\\n  // If node is something like a window, document, or text node, none of\\n  // which support attributes or a .getAttribute method, gracefully return\\n  // the empty string, as if the attribute were missing.\\n  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';\\n}\\n\\n/**\\n * Mounts this component and inserts it into the DOM.\\n *\\n * @param {ReactComponent} componentInstance The instance to mount.\\n * @param {DOMElement} container DOM element to mount into.\\n * @param {ReactReconcileTransaction} transaction\\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\\n */\\nfunction mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {\\n  var markerName;\\n  if (ReactFeatureFlags.logTopLevelRenders) {\\n    var wrappedElement = wrapperInstance._currentElement.props;\\n    var type = wrappedElement.type;\\n    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);\\n    console.time(markerName);\\n  }\\n\\n  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */\\n  );\\n\\n  if (markerName) {\\n    console.timeEnd(markerName);\\n  }\\n\\n  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;\\n  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);\\n}\\n\\n/**\\n * Batched mount.\\n *\\n * @param {ReactComponent} componentInstance The instance to mount.\\n * @param {DOMElement} container DOM element to mount into.\\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\\n */\\nfunction batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {\\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\\n  /* useCreateElement */\\n  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);\\n  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);\\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\\n}\\n\\n/**\\n * Unmounts a component and removes it from the DOM.\\n *\\n * @param {ReactComponent} instance React component instance.\\n * @param {DOMElement} container DOM element to unmount from.\\n * @final\\n * @internal\\n * @see {ReactMount.unmountComponentAtNode}\\n */\\nfunction unmountComponentFromNode(instance, container, safely) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    ReactInstrumentation.debugTool.onBeginFlush();\\n  }\\n  ReactReconciler.unmountComponent(instance, safely);\\n  if (process.env.NODE_ENV !== 'production') {\\n    ReactInstrumentation.debugTool.onEndFlush();\\n  }\\n\\n  if (container.nodeType === DOC_NODE_TYPE) {\\n    container = container.documentElement;\\n  }\\n\\n  // http://jsperf.com/emptying-a-node\\n  while (container.lastChild) {\\n    container.removeChild(container.lastChild);\\n  }\\n}\\n\\n/**\\n * True if the supplied DOM node has a direct React-rendered child that is\\n * not a React root element. Useful for warning in `render`,\\n * `unmountComponentAtNode`, etc.\\n *\\n * @param {?DOMElement} node The candidate DOM node.\\n * @return {boolean} True if the DOM element contains a direct child that was\\n * rendered by React but is not a root element.\\n * @internal\\n */\\nfunction hasNonRootReactChild(container) {\\n  var rootEl = getReactRootElementInContainer(container);\\n  if (rootEl) {\\n    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);\\n    return !!(inst && inst._hostParent);\\n  }\\n}\\n\\n/**\\n * True if the supplied DOM node is a React DOM element and\\n * it has been rendered by another copy of React.\\n *\\n * @param {?DOMElement} node The candidate DOM node.\\n * @return {boolean} True if the DOM has been rendered by another copy of React\\n * @internal\\n */\\nfunction nodeIsRenderedByOtherInstance(container) {\\n  var rootEl = getReactRootElementInContainer(container);\\n  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));\\n}\\n\\n/**\\n * True if the supplied DOM node is a valid node element.\\n *\\n * @param {?DOMElement} node The candidate DOM node.\\n * @return {boolean} True if the DOM is a valid DOM node.\\n * @internal\\n */\\nfunction isValidContainer(node) {\\n  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));\\n}\\n\\n/**\\n * True if the supplied DOM node is a valid React node element.\\n *\\n * @param {?DOMElement} node The candidate DOM node.\\n * @return {boolean} True if the DOM is a valid React DOM node.\\n * @internal\\n */\\nfunction isReactNode(node) {\\n  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));\\n}\\n\\nfunction getHostRootInstanceInContainer(container) {\\n  var rootEl = getReactRootElementInContainer(container);\\n  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);\\n  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;\\n}\\n\\nfunction getTopLevelWrapperInContainer(container) {\\n  var root = getHostRootInstanceInContainer(container);\\n  return root ? root._hostContainerInfo._topLevelWrapper : null;\\n}\\n\\n/**\\n * Temporary (?) hack so that we can store all top-level pending updates on\\n * composites instead of having to worry about different types of components\\n * here.\\n */\\nvar topLevelRootCounter = 1;\\nvar TopLevelWrapper = function () {\\n  this.rootID = topLevelRootCounter++;\\n};\\nTopLevelWrapper.prototype.isReactComponent = {};\\nif (process.env.NODE_ENV !== 'production') {\\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\\n}\\nTopLevelWrapper.prototype.render = function () {\\n  // this.props is actually a ReactElement\\n  return this.props;\\n};\\n\\n/**\\n * Mounting is the process of initializing a React component by creating its\\n * representative DOM elements and inserting them into a supplied `container`.\\n * Any prior content inside `container` is destroyed in the process.\\n *\\n *   ReactMount.render(\\n *     component,\\n *     document.getElementById('container')\\n *   );\\n *\\n *   <div id=\\\"container\\\">                   <-- Supplied `container`.\\n *     <div data-reactid=\\\".3\\\">              <-- Rendered reactRoot of React\\n *       // ...                                 component.\\n *     </div>\\n *   </div>\\n *\\n * Inside of `container`, the first element rendered is the \\\"reactRoot\\\".\\n */\\nvar ReactMount = {\\n\\n  TopLevelWrapper: TopLevelWrapper,\\n\\n  /**\\n   * Used by devtools. The keys are not important.\\n   */\\n  _instancesByReactRootID: instancesByReactRootID,\\n\\n  /**\\n   * This is a hook provided to support rendering React components while\\n   * ensuring that the apparent scroll position of its `container` does not\\n   * change.\\n   *\\n   * @param {DOMElement} container The `container` being rendered into.\\n   * @param {function} renderCallback This must be called once to do the render.\\n   */\\n  scrollMonitor: function (container, renderCallback) {\\n    renderCallback();\\n  },\\n\\n  /**\\n   * Take a component that's already mounted into the DOM and replace its props\\n   * @param {ReactComponent} prevComponent component instance already in the DOM\\n   * @param {ReactElement} nextElement component instance to render\\n   * @param {DOMElement} container container to render into\\n   * @param {?function} callback function triggered on completion\\n   */\\n  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {\\n    ReactMount.scrollMonitor(container, function () {\\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);\\n      if (callback) {\\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\\n      }\\n    });\\n\\n    return prevComponent;\\n  },\\n\\n  /**\\n   * Render a new component into the DOM. Hooked by hooks!\\n   *\\n   * @param {ReactElement} nextElement element to render\\n   * @param {DOMElement} container container to render into\\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\\n   * @return {ReactComponent} nextComponent\\n   */\\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\\n    // Various parts of our code (such as ReactCompositeComponent's\\n    // _renderValidatedComponent) assume that calls to render aren't nested;\\n    // verify that that's the case.\\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;\\n\\n    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;\\n\\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\\n    var componentInstance = instantiateReactComponent(nextElement, false);\\n\\n    // The initial render is synchronous but any updates that happen during\\n    // rendering, in componentWillMount or componentDidMount, will be batched\\n    // according to the current batching strategy.\\n\\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);\\n\\n    var wrapperID = componentInstance._instance.rootID;\\n    instancesByReactRootID[wrapperID] = componentInstance;\\n\\n    return componentInstance;\\n  },\\n\\n  /**\\n   * Renders a React component into the DOM in the supplied `container`.\\n   *\\n   * If the React component was previously rendered into `container`, this will\\n   * perform an update on it and only mutate the DOM as necessary to reflect the\\n   * latest React component.\\n   *\\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\\n   * @param {ReactElement} nextElement Component element to render.\\n   * @param {DOMElement} container DOM element to render into.\\n   * @param {?function} callback function triggered on completion\\n   * @return {ReactComponent} Component instance rendered in `container`.\\n   */\\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\\n    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;\\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\\n  },\\n\\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\\n    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');\\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \\\\'div\\\\', pass ' + 'React.createElement(\\\\'div\\\\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :\\n    // Check if it quacks like an element\\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \\\\'div\\\\', pass ' + 'React.createElement(\\\\'div\\\\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;\\n\\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;\\n\\n    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\\n\\n    var nextContext;\\n    if (parentComponent) {\\n      var parentInst = ReactInstanceMap.get(parentComponent);\\n      nextContext = parentInst._processChildContext(parentInst._context);\\n    } else {\\n      nextContext = emptyObject;\\n    }\\n\\n    var prevComponent = getTopLevelWrapperInContainer(container);\\n\\n    if (prevComponent) {\\n      var prevWrappedElement = prevComponent._currentElement;\\n      var prevElement = prevWrappedElement.props;\\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\\n        var updatedCallback = callback && function () {\\n          callback.call(publicInst);\\n        };\\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);\\n        return publicInst;\\n      } else {\\n        ReactMount.unmountComponentAtNode(container);\\n      }\\n    }\\n\\n    var reactRootElement = getReactRootElementInContainer(container);\\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;\\n\\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\\n        var rootElementSibling = reactRootElement;\\n        while (rootElementSibling) {\\n          if (internalGetID(rootElementSibling)) {\\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;\\n            break;\\n          }\\n          rootElementSibling = rootElementSibling.nextSibling;\\n        }\\n      }\\n    }\\n\\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();\\n    if (callback) {\\n      callback.call(component);\\n    }\\n    return component;\\n  },\\n\\n  /**\\n   * Renders a React component into the DOM in the supplied `container`.\\n   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render\\n   *\\n   * If the React component was previously rendered into `container`, this will\\n   * perform an update on it and only mutate the DOM as necessary to reflect the\\n   * latest React component.\\n   *\\n   * @param {ReactElement} nextElement Component element to render.\\n   * @param {DOMElement} container DOM element to render into.\\n   * @param {?function} callback function triggered on completion\\n   * @return {ReactComponent} Component instance rendered in `container`.\\n   */\\n  render: function (nextElement, container, callback) {\\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\\n  },\\n\\n  /**\\n   * Unmounts and destroys the React component rendered in the `container`.\\n   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode\\n   *\\n   * @param {DOMElement} container DOM element containing a React component.\\n   * @return {boolean} True if a component was found in and unmounted from\\n   *                   `container`\\n   */\\n  unmountComponentAtNode: function (container) {\\n    // Various parts of our code (such as ReactCompositeComponent's\\n    // _renderValidatedComponent) assume that calls to render aren't nested;\\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\\n    // render but we still don't expect to be in a render call here.)\\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;\\n\\n    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\\\\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;\\n    }\\n\\n    var prevComponent = getTopLevelWrapperInContainer(container);\\n    if (!prevComponent) {\\n      // Check if the node being unmounted was rendered by React, but isn't a\\n      // root node.\\n      var containerHasNonRootReactChild = hasNonRootReactChild(container);\\n\\n      // Check if the container itself is a React root node.\\n      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;\\n      }\\n\\n      return false;\\n    }\\n    delete instancesByReactRootID[prevComponent._instance.rootID];\\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);\\n    return true;\\n  },\\n\\n  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {\\n    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;\\n\\n    if (shouldReuseMarkup) {\\n      var rootElement = getReactRootElementInContainer(container);\\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\\n        ReactDOMComponentTree.precacheNode(instance, rootElement);\\n        return;\\n      } else {\\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\\n\\n        var rootMarkup = rootElement.outerHTML;\\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\\n\\n        var normalizedMarkup = markup;\\n        if (process.env.NODE_ENV !== 'production') {\\n          // because rootMarkup is retrieved from the DOM, various normalizations\\n          // will have occurred which will not be present in `markup`. Here,\\n          // insert markup into a <div> or <iframe> depending on the container\\n          // type to perform the same normalizations before comparing.\\n          var normalizer;\\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\\n            normalizer = document.createElement('div');\\n            normalizer.innerHTML = markup;\\n            normalizedMarkup = normalizer.innerHTML;\\n          } else {\\n            normalizer = document.createElement('iframe');\\n            document.body.appendChild(normalizer);\\n            normalizer.contentDocument.write(markup);\\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\\n            document.body.removeChild(normalizer);\\n          }\\n        }\\n\\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\\n\\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\\\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\\\\n%s', difference) : _prodInvariant('42', difference) : void 0;\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\\\n%s', difference) : void 0;\\n        }\\n      }\\n    }\\n\\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\\\'re trying to render a component to the document but you didn\\\\'t use server rendering. We can\\\\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;\\n\\n    if (transaction.useCreateElement) {\\n      while (container.lastChild) {\\n        container.removeChild(container.lastChild);\\n      }\\n      DOMLazyTree.insertTreeBefore(container, markup, null);\\n    } else {\\n      setInnerHTML(container, markup);\\n      ReactDOMComponentTree.precacheNode(instance, container.firstChild);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);\\n      if (hostNode._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());\\n      }\\n    }\\n  }\\n};\\n\\nmodule.exports = ReactMount;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getReactRootElementInContainer\",\"container\",\"DOC_NODE_TYPE\",\"nodeType\",\"documentElement\",\"firstChild\",\"mountComponentIntoNode\",\"wrapperInstance\",\"transaction\",\"shouldReuseMarkup\",\"context\",\"ReactFeatureFlags\",\"logTopLevelRenders\",\"type\",\"_currentElement\",\"props\",\"markerName\",\"displayName\",\"name\",\"console\",\"time\",\"markup\",\"ReactReconciler\",\"mountComponent\",\"ReactDOMContainerInfo\",\"timeEnd\",\"_renderedComponent\",\"_topLevelWrapper\",\"ReactMount\",\"_mountImageIntoNode\",\"batchedMountComponentIntoNode\",\"componentInstance\",\"ReactUpdates\",\"ReactReconcileTransaction\",\"getPooled\",\"ReactDOMFeatureFlags\",\"useCreateElement\",\"perform\",\"release\",\"unmountComponentFromNode\",\"instance\",\"safely\",\"ReactInstrumentation\",\"debugTool\",\"onBeginFlush\",\"unmountComponent\",\"onEndFlush\",\"lastChild\",\"removeChild\",\"hasNonRootReactChild\",\"rootEl\",\"inst\",\"ReactDOMComponentTree\",\"getInstanceFromNode\",\"_hostParent\",\"isValidContainer\",\"node\",\"ELEMENT_NODE_TYPE\",\"DOCUMENT_FRAGMENT_NODE_TYPE\",\"getTopLevelWrapperInContainer\",\"prevHostInstance\",\"root\",\"_hostContainerInfo\",\"DOMLazyTree\",\"DOMProperty\",\"ReactBrowserEventEmitter\",\"ReactCurrentOwner\",\"ReactElement\",\"ReactInstanceMap\",\"ReactMarkupChecksum\",\"ReactUpdateQueue\",\"emptyObject\",\"instantiateReactComponent\",\"invariant\",\"setInnerHTML\",\"shouldUpdateReactComponent\",\"warning\",\"ATTR_NAME\",\"ID_ATTRIBUTE_NAME\",\"ROOT_ATTR_NAME\",\"ROOT_ATTRIBUTE_NAME\",\"instancesByReactRootID\",\"topLevelRootCounter\",\"TopLevelWrapper\",\"rootID\",\"prototype\",\"isReactComponent\",\"render\",\"TopLevelWrapper.prototype.render\",\"_instancesByReactRootID\",\"scrollMonitor\",\"renderCallback\",\"_updateRootComponent\",\"prevComponent\",\"nextElement\",\"nextContext\",\"callback\",\"enqueueElementInternal\",\"enqueueCallbackInternal\",\"_renderNewRootComponent\",\"current\",\"getName\",\"ensureScrollValueMonitoring\",\"batchedUpdates\",\"_instance\",\"renderSubtreeIntoContainer\",\"parentComponent\",\"has\",\"_renderSubtreeIntoContainer\",\"validateCallback\",\"isValidElement\",\"undefined\",\"tagName\",\"toUpperCase\",\"nextWrappedElement\",\"parentInst\",\"get\",\"_processChildContext\",\"_context\",\"publicInst\",\"getPublicInstance\",\"call\",\"unmountComponentAtNode\",\"reactRootElement\",\"containerHasReactMarkup\",\"getAttribute\",\"containerHasNonRootReactChild\",\"nextSibling\",\"rootElementSibling\",\"component\",\"hasAttribute\",\"isContainerReactRoot\",\"rootElement\",\"canReuseMarkup\",\"precacheNode\",\"checksum\",\"CHECKSUM_ATTR_NAME\",\"removeAttribute\",\"rootMarkup\",\"outerHTML\",\"setAttribute\",\"normalizer\",\"document\",\"createElement\",\"innerHTML\",\"normalizedMarkup\",\"body\",\"appendChild\",\"contentDocument\",\"write\",\"minLen\",\"Math\",\"min\",\"string1\",\"length\",\"i\",\"charAt\",\"difference\",\"substring\",\"diffIndex\",\"insertTreeBefore\",\"hostNode\",\"_debugID\",\"onHostOperation\",\"toString\"]\n}\n"]