["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/DOMLazyTree.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$DOMLazyTree=function(global,process,require,module,exports,shadow$shims){function insertTreeChildren(tree){if(enableLazy){var node=tree.node,children=tree.children;if(children.length)for(tree=0;tree<children.length;tree++)insertTreeBefore(node,children[tree],null);else null!=tree.html?setInnerHTML(node,tree.html):null!=tree.text&&setTextContent(node,tree.text)}}function toString(){return this.node.nodeName}function DOMLazyTree(node){return{node:node,\nchildren:[],html:null,text:null,toString:toString}}var DOMNamespaces=require(\"module$node_modules$react_dom$lib$DOMNamespaces\"),setInnerHTML=require(\"module$node_modules$react_dom$lib$setInnerHTML\");global=require(\"module$node_modules$react_dom$lib$createMicrosoftUnsafeLocalFunction\");var setTextContent=require(\"module$node_modules$react_dom$lib$setTextContent\"),enableLazy=\"undefined\"!==typeof document&&\"number\"===typeof document.documentMode||\"undefined\"!==typeof navigator&&\"string\"===typeof navigator.userAgent&&\n/\\bEdge\\/\\d/.test(navigator.userAgent),insertTreeBefore=global(function(parentNode,tree,referenceNode){11===tree.node.nodeType||1===tree.node.nodeType&&\"object\"===tree.node.nodeName.toLowerCase()&&(null==tree.node.namespaceURI||tree.node.namespaceURI===DOMNamespaces.html)?(insertTreeChildren(tree),parentNode.insertBefore(tree.node,referenceNode)):(parentNode.insertBefore(tree.node,referenceNode),insertTreeChildren(tree))});DOMLazyTree.insertTreeBefore=insertTreeBefore;DOMLazyTree.replaceChildWithTree=\nfunction(oldNode,newTree){oldNode.parentNode.replaceChild(newTree.node,oldNode);insertTreeChildren(newTree)};DOMLazyTree.queueChild=function(parentTree,childTree){enableLazy?parentTree.children.push(childTree):parentTree.node.appendChild(childTree.node)};DOMLazyTree.queueHTML=function(tree,html){enableLazy?tree.html=html:setInnerHTML(tree.node,html)};DOMLazyTree.queueText=function(tree,text){enableLazy?tree.text=text:setTextContent(tree.node,text)};module.exports=DOMLazyTree}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$DOMLazyTree\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar DOMNamespaces = require('./DOMNamespaces');\nvar setInnerHTML = require('./setInnerHTML');\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\nvar setTextContent = require('./setTextContent');\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\n/**\n * In IE (8-11) and Edge, appending nodes with no children is dramatically\n * faster than appending a full subtree, so we essentially queue up the\n * .appendChild calls here and apply them so each node is added to its parent\n * before any children are added.\n *\n * In other browsers, doing so is slower or neutral compared to the other order\n * (in Firefox, twice as slow) so we only do this inversion in IE.\n *\n * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.\n */\nvar enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\\bEdge\\/\\d/.test(navigator.userAgent);\n\nfunction insertTreeChildren(tree) {\n  if (!enableLazy) {\n    return;\n  }\n  var node = tree.node;\n  var children = tree.children;\n  if (children.length) {\n    for (var i = 0; i < children.length; i++) {\n      insertTreeBefore(node, children[i], null);\n    }\n  } else if (tree.html != null) {\n    setInnerHTML(node, tree.html);\n  } else if (tree.text != null) {\n    setTextContent(node, tree.text);\n  }\n}\n\nvar insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {\n  // DocumentFragments aren't actually part of the DOM after insertion so\n  // appending children won't update the DOM. We need to ensure the fragment\n  // is properly populated first, breaking out of our lazy approach for just\n  // this level. Also, some <object> plugins (like Flash Player) will read\n  // <param> nodes immediately upon insertion into the DOM, so <object>\n  // must also be populated prior to insertion into the DOM.\n  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {\n    insertTreeChildren(tree);\n    parentNode.insertBefore(tree.node, referenceNode);\n  } else {\n    parentNode.insertBefore(tree.node, referenceNode);\n    insertTreeChildren(tree);\n  }\n});\n\nfunction replaceChildWithTree(oldNode, newTree) {\n  oldNode.parentNode.replaceChild(newTree.node, oldNode);\n  insertTreeChildren(newTree);\n}\n\nfunction queueChild(parentTree, childTree) {\n  if (enableLazy) {\n    parentTree.children.push(childTree);\n  } else {\n    parentTree.node.appendChild(childTree.node);\n  }\n}\n\nfunction queueHTML(tree, html) {\n  if (enableLazy) {\n    tree.html = html;\n  } else {\n    setInnerHTML(tree.node, html);\n  }\n}\n\nfunction queueText(tree, text) {\n  if (enableLazy) {\n    tree.text = text;\n  } else {\n    setTextContent(tree.node, text);\n  }\n}\n\nfunction toString() {\n  return this.node.nodeName;\n}\n\nfunction DOMLazyTree(node) {\n  return {\n    node: node,\n    children: [],\n    html: null,\n    text: null,\n    toString: toString\n  };\n}\n\nDOMLazyTree.insertTreeBefore = insertTreeBefore;\nDOMLazyTree.replaceChildWithTree = replaceChildWithTree;\nDOMLazyTree.queueChild = queueChild;\nDOMLazyTree.queueHTML = queueHTML;\nDOMLazyTree.queueText = queueText;\n\nmodule.exports = DOMLazyTree;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_dom$lib$setInnerHTML","~$module$node_modules$react_dom$lib$DOMNamespaces","~$shadow.js","~$module$node_modules$react_dom$lib$createMicrosoftUnsafeLocalFunction","~$module$node_modules$react_dom$lib$setTextContent"]],"~:properties",["^5",["queueText","queueChild","children","toString","replaceChildWithTree","insertTreeBefore","text","queueHTML","html","node"]],"~:compiled-at",1635270336830,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$DOMLazyTree.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/DOMLazyTree.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$DOMLazyTree\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2015-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar DOMNamespaces = require('./DOMNamespaces');\\nvar setInnerHTML = require('./setInnerHTML');\\n\\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\\nvar setTextContent = require('./setTextContent');\\n\\nvar ELEMENT_NODE_TYPE = 1;\\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\\n\\n/**\\n * In IE (8-11) and Edge, appending nodes with no children is dramatically\\n * faster than appending a full subtree, so we essentially queue up the\\n * .appendChild calls here and apply them so each node is added to its parent\\n * before any children are added.\\n *\\n * In other browsers, doing so is slower or neutral compared to the other order\\n * (in Firefox, twice as slow) so we only do this inversion in IE.\\n *\\n * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.\\n */\\nvar enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\\\\bEdge\\\\/\\\\d/.test(navigator.userAgent);\\n\\nfunction insertTreeChildren(tree) {\\n  if (!enableLazy) {\\n    return;\\n  }\\n  var node = tree.node;\\n  var children = tree.children;\\n  if (children.length) {\\n    for (var i = 0; i < children.length; i++) {\\n      insertTreeBefore(node, children[i], null);\\n    }\\n  } else if (tree.html != null) {\\n    setInnerHTML(node, tree.html);\\n  } else if (tree.text != null) {\\n    setTextContent(node, tree.text);\\n  }\\n}\\n\\nvar insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {\\n  // DocumentFragments aren't actually part of the DOM after insertion so\\n  // appending children won't update the DOM. We need to ensure the fragment\\n  // is properly populated first, breaking out of our lazy approach for just\\n  // this level. Also, some <object> plugins (like Flash Player) will read\\n  // <param> nodes immediately upon insertion into the DOM, so <object>\\n  // must also be populated prior to insertion into the DOM.\\n  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {\\n    insertTreeChildren(tree);\\n    parentNode.insertBefore(tree.node, referenceNode);\\n  } else {\\n    parentNode.insertBefore(tree.node, referenceNode);\\n    insertTreeChildren(tree);\\n  }\\n});\\n\\nfunction replaceChildWithTree(oldNode, newTree) {\\n  oldNode.parentNode.replaceChild(newTree.node, oldNode);\\n  insertTreeChildren(newTree);\\n}\\n\\nfunction queueChild(parentTree, childTree) {\\n  if (enableLazy) {\\n    parentTree.children.push(childTree);\\n  } else {\\n    parentTree.node.appendChild(childTree.node);\\n  }\\n}\\n\\nfunction queueHTML(tree, html) {\\n  if (enableLazy) {\\n    tree.html = html;\\n  } else {\\n    setInnerHTML(tree.node, html);\\n  }\\n}\\n\\nfunction queueText(tree, text) {\\n  if (enableLazy) {\\n    tree.text = text;\\n  } else {\\n    setTextContent(tree.node, text);\\n  }\\n}\\n\\nfunction toString() {\\n  return this.node.nodeName;\\n}\\n\\nfunction DOMLazyTree(node) {\\n  return {\\n    node: node,\\n    children: [],\\n    html: null,\\n    text: null,\\n    toString: toString\\n  };\\n}\\n\\nDOMLazyTree.insertTreeBefore = insertTreeBefore;\\nDOMLazyTree.replaceChildWithTree = replaceChildWithTree;\\nDOMLazyTree.queueChild = queueChild;\\nDOMLazyTree.queueHTML = queueHTML;\\nDOMLazyTree.queueText = queueText;\\n\\nmodule.exports = DOMLazyTree;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"insertTreeChildren\",\"tree\",\"enableLazy\",\"node\",\"children\",\"length\",\"i\",\"insertTreeBefore\",\"html\",\"setInnerHTML\",\"text\",\"setTextContent\",\"toString\",\"nodeName\",\"DOMLazyTree\",\"DOMNamespaces\",\"createMicrosoftUnsafeLocalFunction\",\"document\",\"documentMode\",\"navigator\",\"userAgent\",\"test\",\"parentNode\",\"referenceNode\",\"DOCUMENT_FRAGMENT_NODE_TYPE\",\"nodeType\",\"ELEMENT_NODE_TYPE\",\"toLowerCase\",\"namespaceURI\",\"insertBefore\",\"replaceChildWithTree\",\"oldNode\",\"newTree\",\"replaceChild\",\"queueChild\",\"parentTree\",\"childTree\",\"push\",\"appendChild\",\"queueHTML\",\"queueText\"]\n}\n"]