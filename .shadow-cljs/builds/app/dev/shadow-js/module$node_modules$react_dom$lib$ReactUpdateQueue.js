["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactUpdateQueue.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactUpdateQueue=function(global,process,require,module,exports,shadow$shims){function getInternalInstanceReadyForUpdate(publicInstance,callerName){var internalInstance=ReactInstanceMap.get(publicInstance);if(!internalInstance)return publicInstance=publicInstance.constructor,warning(!callerName,\"%s(...): Can only update a mounted or mounting component. This usually means you called %s() on an unmounted component. This is a no-op. Please check the code for the %s component.\",\ncallerName,callerName,publicInstance&&(publicInstance.displayName||publicInstance.name)||\"ReactClass\"),null;warning(null==ReactCurrentOwner.current,\"%s(...): Cannot update during an existing state transition (such as within `render` or another component's constructor). Render methods should be a pure function of props and state; constructor side-effects are an anti-pattern, but can be moved to `componentWillMount`.\",callerName);return internalInstance}require(\"module$node_modules$react_dom$lib$reactProdInvariant\");\nvar ReactCurrentOwner=require(\"module$node_modules$react$lib$ReactCurrentOwner\"),ReactInstanceMap=require(\"module$node_modules$react_dom$lib$ReactInstanceMap\"),ReactInstrumentation=require(\"module$node_modules$react_dom$lib$ReactInstrumentation\"),ReactUpdates=require(\"module$node_modules$react_dom$lib$ReactUpdates\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),warning=require(\"module$node_modules$fbjs$lib$warning\"),ReactUpdateQueue={isMounted:function(publicInstance){var owner=ReactCurrentOwner.current;\nnull!==owner&&(warning(owner._warnedAboutRefsInRender,\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\",owner.getName()||\"A component\"),owner._warnedAboutRefsInRender=!0);return(publicInstance=ReactInstanceMap.get(publicInstance))?!!publicInstance._renderedComponent:!1},\nenqueueCallback:function(publicInstance,callback,callerName){ReactUpdateQueue.validateCallback(callback,callerName);publicInstance=getInternalInstanceReadyForUpdate(publicInstance);if(!publicInstance)return null;publicInstance._pendingCallbacks?publicInstance._pendingCallbacks.push(callback):publicInstance._pendingCallbacks=[callback];ReactUpdates.enqueueUpdate(publicInstance)},enqueueCallbackInternal:function(internalInstance,callback){internalInstance._pendingCallbacks?internalInstance._pendingCallbacks.push(callback):\ninternalInstance._pendingCallbacks=[callback];ReactUpdates.enqueueUpdate(internalInstance)},enqueueForceUpdate:function(publicInstance){if(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,\"forceUpdate\"))publicInstance._pendingForceUpdate=!0,ReactUpdates.enqueueUpdate(publicInstance)},enqueueReplaceState:function(publicInstance,completeState){if(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,\"replaceState\"))publicInstance._pendingStateQueue=[completeState],publicInstance._pendingReplaceState=\n!0,ReactUpdates.enqueueUpdate(publicInstance)},enqueueSetState:function(publicInstance,partialState){ReactInstrumentation.debugTool.onSetState();warning(null!=partialState,\"setState(...): You passed an undefined or null state object; instead, use forceUpdate().\");if(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,\"setState\"))(publicInstance._pendingStateQueue||(publicInstance._pendingStateQueue=[])).push(partialState),ReactUpdates.enqueueUpdate(publicInstance)},enqueueElementInternal:function(internalInstance,\nnextElement,nextContext){internalInstance._pendingElement=nextElement;internalInstance._context=nextContext;ReactUpdates.enqueueUpdate(internalInstance)},validateCallback:function(callback,callerName){if(callback&&\"function\"!==typeof callback){var type=typeof callback;\"object\"!==type?callback=type:(type=callback.constructor&&callback.constructor.name||type,callback=Object.keys(callback),callback=0<callback.length&&20>callback.length?type+\" (keys: \"+callback.join(\", \")+\")\":type);invariant(!1,\"%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.\",\ncallerName,callback)}else void 0}};module.exports=ReactUpdateQueue}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactUpdateQueue\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactInstrumentation = require('./ReactInstrumentation');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction formatUnexpectedArgument(arg) {\n  var type = typeof arg;\n  if (type !== 'object') {\n    return type;\n  }\n  var displayName = arg.constructor && arg.constructor.name || type;\n  var keys = Object.keys(arg);\n  if (keys.length > 0 && keys.length < 20) {\n    return displayName + ' (keys: ' + keys.join(', ') + ')';\n  }\n  return displayName;\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var ctor = publicInstance.constructor;\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;\n    }\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @param {string} callerName Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback, callerName) {\n    ReactUpdateQueue.validateCallback(callback, callerName);\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function (internalInstance, callback) {\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    if (process.env.NODE_ENV !== 'production') {\n      ReactInstrumentation.debugTool.onSetState();\n      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;\n    }\n\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {\n    internalInstance._pendingElement = nextElement;\n    // TODO: introduce _pendingContext instead of setting it directly.\n    internalInstance._context = nextContext;\n    enqueueUpdate(internalInstance);\n  },\n\n  validateCallback: function (callback, callerName) {\n    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;\n  }\n\n};\n\nmodule.exports = ReactUpdateQueue;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_dom$lib$ReactUpdates","~$module$node_modules$react_dom$lib$ReactInstrumentation","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react_dom$lib$reactProdInvariant","~$module$node_modules$react_dom$lib$ReactInstanceMap","~$module$node_modules$fbjs$lib$warning","~$module$node_modules$react$lib$ReactCurrentOwner"]],"~:properties",["^5",["enqueueForceUpdate","_pendingReplaceState","enqueueReplaceState","enqueueCallbackInternal","enqueueCallback","_pendingElement","_warnedAboutRefsInRender","_pendingCallbacks","_context","_pendingStateQueue","_pendingForceUpdate","enqueueElementInternal","isMounted","validateCallback","enqueueSetState"]],"~:compiled-at",1635270336846,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactUpdateQueue.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/ReactUpdateQueue.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactUpdateQueue\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2015-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\\nvar ReactInstanceMap = require('./ReactInstanceMap');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\nvar ReactUpdates = require('./ReactUpdates');\\n\\nvar invariant = require('fbjs/lib/invariant');\\nvar warning = require('fbjs/lib/warning');\\n\\nfunction enqueueUpdate(internalInstance) {\\n  ReactUpdates.enqueueUpdate(internalInstance);\\n}\\n\\nfunction formatUnexpectedArgument(arg) {\\n  var type = typeof arg;\\n  if (type !== 'object') {\\n    return type;\\n  }\\n  var displayName = arg.constructor && arg.constructor.name || type;\\n  var keys = Object.keys(arg);\\n  if (keys.length > 0 && keys.length < 20) {\\n    return displayName + ' (keys: ' + keys.join(', ') + ')';\\n  }\\n  return displayName;\\n}\\n\\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\\n  var internalInstance = ReactInstanceMap.get(publicInstance);\\n  if (!internalInstance) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      var ctor = publicInstance.constructor;\\n      // Only warn when we have a callerName. Otherwise we should be silent.\\n      // We're probably calling from enqueueCallback. We don't want to warn\\n      // there because we already warned for the corresponding lifecycle method.\\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;\\n    }\\n    return null;\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\\\\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;\\n  }\\n\\n  return internalInstance;\\n}\\n\\n/**\\n * ReactUpdateQueue allows for state updates to be scheduled into a later\\n * reconciliation step.\\n */\\nvar ReactUpdateQueue = {\\n\\n  /**\\n   * Checks whether or not this composite component is mounted.\\n   * @param {ReactClass} publicInstance The instance we want to test.\\n   * @return {boolean} True if mounted, false otherwise.\\n   * @protected\\n   * @final\\n   */\\n  isMounted: function (publicInstance) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      var owner = ReactCurrentOwner.current;\\n      if (owner !== null) {\\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;\\n        owner._warnedAboutRefsInRender = true;\\n      }\\n    }\\n    var internalInstance = ReactInstanceMap.get(publicInstance);\\n    if (internalInstance) {\\n      // During componentWillMount and render this will still be null but after\\n      // that will always render to something. At least for now. So we can use\\n      // this hack.\\n      return !!internalInstance._renderedComponent;\\n    } else {\\n      return false;\\n    }\\n  },\\n\\n  /**\\n   * Enqueue a callback that will be executed after all the pending updates\\n   * have processed.\\n   *\\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\\n   * @param {?function} callback Called after state is updated.\\n   * @param {string} callerName Name of the calling function in the public API.\\n   * @internal\\n   */\\n  enqueueCallback: function (publicInstance, callback, callerName) {\\n    ReactUpdateQueue.validateCallback(callback, callerName);\\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\\n\\n    // Previously we would throw an error if we didn't have an internal\\n    // instance. Since we want to make it a no-op instead, we mirror the same\\n    // behavior we have in other enqueue* methods.\\n    // We also need to ignore callbacks in componentWillMount. See\\n    // enqueueUpdates.\\n    if (!internalInstance) {\\n      return null;\\n    }\\n\\n    if (internalInstance._pendingCallbacks) {\\n      internalInstance._pendingCallbacks.push(callback);\\n    } else {\\n      internalInstance._pendingCallbacks = [callback];\\n    }\\n    // TODO: The callback here is ignored when setState is called from\\n    // componentWillMount. Either fix it or disallow doing so completely in\\n    // favor of getInitialState. Alternatively, we can disallow\\n    // componentWillMount during server-side rendering.\\n    enqueueUpdate(internalInstance);\\n  },\\n\\n  enqueueCallbackInternal: function (internalInstance, callback) {\\n    if (internalInstance._pendingCallbacks) {\\n      internalInstance._pendingCallbacks.push(callback);\\n    } else {\\n      internalInstance._pendingCallbacks = [callback];\\n    }\\n    enqueueUpdate(internalInstance);\\n  },\\n\\n  /**\\n   * Forces an update. This should only be invoked when it is known with\\n   * certainty that we are **not** in a DOM transaction.\\n   *\\n   * You may want to call this when you know that some deeper aspect of the\\n   * component's state has changed but `setState` was not called.\\n   *\\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\\n   * `componentWillUpdate` and `componentDidUpdate`.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @internal\\n   */\\n  enqueueForceUpdate: function (publicInstance) {\\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\\n\\n    if (!internalInstance) {\\n      return;\\n    }\\n\\n    internalInstance._pendingForceUpdate = true;\\n\\n    enqueueUpdate(internalInstance);\\n  },\\n\\n  /**\\n   * Replaces all of the state. Always use this or `setState` to mutate state.\\n   * You should treat `this.state` as immutable.\\n   *\\n   * There is no guarantee that `this.state` will be immediately updated, so\\n   * accessing `this.state` after calling this method may return the old value.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @param {object} completeState Next state.\\n   * @internal\\n   */\\n  enqueueReplaceState: function (publicInstance, completeState) {\\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\\n\\n    if (!internalInstance) {\\n      return;\\n    }\\n\\n    internalInstance._pendingStateQueue = [completeState];\\n    internalInstance._pendingReplaceState = true;\\n\\n    enqueueUpdate(internalInstance);\\n  },\\n\\n  /**\\n   * Sets a subset of the state. This only exists because _pendingState is\\n   * internal. This provides a merging strategy that is not available to deep\\n   * properties which is confusing. TODO: Expose pendingState or don't use it\\n   * during the merge.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @param {object} partialState Next partial state to be merged with state.\\n   * @internal\\n   */\\n  enqueueSetState: function (publicInstance, partialState) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      ReactInstrumentation.debugTool.onSetState();\\n      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;\\n    }\\n\\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\\n\\n    if (!internalInstance) {\\n      return;\\n    }\\n\\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\\n    queue.push(partialState);\\n\\n    enqueueUpdate(internalInstance);\\n  },\\n\\n  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {\\n    internalInstance._pendingElement = nextElement;\\n    // TODO: introduce _pendingContext instead of setting it directly.\\n    internalInstance._context = nextContext;\\n    enqueueUpdate(internalInstance);\\n  },\\n\\n  validateCallback: function (callback, callerName) {\\n    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;\\n  }\\n\\n};\\n\\nmodule.exports = ReactUpdateQueue;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"getInternalInstanceReadyForUpdate\",\"publicInstance\",\"callerName\",\"internalInstance\",\"ReactInstanceMap\",\"get\",\"ctor\",\"constructor\",\"warning\",\"displayName\",\"name\",\"ReactCurrentOwner\",\"current\",\"ReactInstrumentation\",\"ReactUpdates\",\"invariant\",\"ReactUpdateQueue\",\"isMounted\",\"owner\",\"_warnedAboutRefsInRender\",\"getName\",\"_renderedComponent\",\"enqueueCallback\",\"callback\",\"validateCallback\",\"_pendingCallbacks\",\"push\",\"enqueueUpdate\",\"enqueueCallbackInternal\",\"enqueueForceUpdate\",\"_pendingForceUpdate\",\"enqueueReplaceState\",\"completeState\",\"_pendingStateQueue\",\"_pendingReplaceState\",\"enqueueSetState\",\"partialState\",\"debugTool\",\"onSetState\",\"enqueueElementInternal\",\"nextElement\",\"nextContext\",\"_pendingElement\",\"_context\",\"type\",\"keys\",\"Object\",\"length\",\"join\"]\n}\n"]