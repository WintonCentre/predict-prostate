["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/EventPluginRegistry.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$EventPluginRegistry=function(global,process,require,module,exports,shadow$shims){function recomputePluginOrdering(){if(eventPluginOrder)for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName],pluginIndex=eventPluginOrder.indexOf(pluginName);-1<pluginIndex?void 0:invariant(!1,\"EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.\",pluginName);if(!EventPluginRegistry.plugins[pluginIndex]){pluginModule.extractEvents?\nvoid 0:invariant(!1,\"EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.\",pluginName);EventPluginRegistry.plugins[pluginIndex]=pluginModule;pluginIndex=pluginModule.eventTypes;for(var eventName in pluginIndex){var JSCompiler_inline_result=void 0;var dispatchConfig=pluginIndex[eventName],pluginModule$jscomp$0=pluginModule,eventName$jscomp$0=eventName;EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0)?invariant(!1,\"EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.\",\neventName$jscomp$0):void 0;EventPluginRegistry.eventNameDispatchConfigs[eventName$jscomp$0]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(JSCompiler_inline_result in phasedRegistrationNames)phasedRegistrationNames.hasOwnProperty(JSCompiler_inline_result)&&publishRegistrationName(phasedRegistrationNames[JSCompiler_inline_result],pluginModule$jscomp$0,eventName$jscomp$0);JSCompiler_inline_result=!0}else dispatchConfig.registrationName?\n(publishRegistrationName(dispatchConfig.registrationName,pluginModule$jscomp$0,eventName$jscomp$0),JSCompiler_inline_result=!0):JSCompiler_inline_result=!1;JSCompiler_inline_result?void 0:invariant(!1,\"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",eventName,pluginName)}}}}function publishRegistrationName(registrationName,pluginModule,eventName){EventPluginRegistry.registrationNameModules[registrationName]?invariant(!1,\"EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.\",\nregistrationName):void 0;EventPluginRegistry.registrationNameModules[registrationName]=pluginModule;EventPluginRegistry.registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;pluginModule=registrationName.toLowerCase();EventPluginRegistry.possibleRegistrationNames[pluginModule]=registrationName;\"onDoubleClick\"===registrationName&&(EventPluginRegistry.possibleRegistrationNames.ondblclick=registrationName)}require(\"module$node_modules$react_dom$lib$reactProdInvariant\");\nvar invariant=require(\"module$node_modules$fbjs$lib$invariant\"),eventPluginOrder=null,namesToPlugins={},EventPluginRegistry={plugins:[],eventNameDispatchConfigs:{},registrationNameModules:{},registrationNameDependencies:{},possibleRegistrationNames:{},injectEventPluginOrder:function(injectedEventPluginOrder){eventPluginOrder?invariant(!1,\"EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.\"):void 0;eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);\nrecomputePluginOrdering()},injectEventPluginsByName:function(injectedNamesToPlugins){var isOrderingDirty=!1,pluginName;for(pluginName in injectedNamesToPlugins)if(injectedNamesToPlugins.hasOwnProperty(pluginName)){var pluginModule=injectedNamesToPlugins[pluginName];namesToPlugins.hasOwnProperty(pluginName)&&namesToPlugins[pluginName]===pluginModule||(namesToPlugins[pluginName]?invariant(!1,\"EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.\",pluginName):void 0,\nnamesToPlugins[pluginName]=pluginModule,isOrderingDirty=!0)}isOrderingDirty&&recomputePluginOrdering()},getPluginModuleForEvent:function(event){event=event.dispatchConfig;if(event.registrationName)return EventPluginRegistry.registrationNameModules[event.registrationName]||null;if(void 0!==event.phasedRegistrationNames){event=event.phasedRegistrationNames;for(var phase in event)if(event.hasOwnProperty(phase)){var pluginModule=EventPluginRegistry.registrationNameModules[event[phase]];if(pluginModule)return pluginModule}}return null},\n_resetEventPlugins:function(){eventPluginOrder=null;for(var pluginName in namesToPlugins)namesToPlugins.hasOwnProperty(pluginName)&&delete namesToPlugins[pluginName];EventPluginRegistry.plugins.length=0;pluginName=EventPluginRegistry.eventNameDispatchConfigs;for(var eventName in pluginName)pluginName.hasOwnProperty(eventName)&&delete pluginName[eventName];eventName=EventPluginRegistry.registrationNameModules;for(var registrationName in eventName)eventName.hasOwnProperty(registrationName)&&delete eventName[registrationName];\nregistrationName=EventPluginRegistry.possibleRegistrationNames;for(var lowerCasedName in registrationName)registrationName.hasOwnProperty(lowerCasedName)&&delete registrationName[lowerCasedName]}};module.exports=EventPluginRegistry}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$EventPluginRegistry\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;\n    if (EventPluginRegistry.plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;\n    EventPluginRegistry.plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events and\n * can be used with `EventPluginHub.putListener` to register listeners.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;\n  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;\n  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var lowerCasedName = registrationName.toLowerCase();\n    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\nvar EventPluginRegistry = {\n\n  /**\n   * Ordered list of injected plugins.\n   */\n  plugins: [],\n\n  /**\n   * Mapping from event name to dispatch config\n   */\n  eventNameDispatchConfigs: {},\n\n  /**\n   * Mapping from registration name to plugin module\n   */\n  registrationNameModules: {},\n\n  /**\n   * Mapping from registration name to event name\n   */\n  registrationNameDependencies: {},\n\n  /**\n   * Mapping from lowercase registration names to the properly cased version,\n   * used to warn in the case of missing event handlers. Available\n   * only in __DEV__.\n   * @type {Object}\n   */\n  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,\n  // Trust the developer to only use possibleRegistrationNames in __DEV__\n\n  /**\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\n   * to be decoupled from injection of the actual plugins so that ordering is\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\n   *\n   * @param {array} InjectedEventPluginOrder\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\n   */\n  injectEventPluginOrder: function (injectedEventPluginOrder) {\n    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;\n    // Clone the ordering so it cannot be dynamically mutated.\n    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n    recomputePluginOrdering();\n  },\n\n  /**\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n   * in the ordering injected by `injectEventPluginOrder`.\n   *\n   * Plugins can be injected as part of page initialization or on-the-fly.\n   *\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\n   */\n  injectEventPluginsByName: function (injectedNamesToPlugins) {\n    var isOrderingDirty = false;\n    for (var pluginName in injectedNamesToPlugins) {\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n        continue;\n      }\n      var pluginModule = injectedNamesToPlugins[pluginName];\n      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;\n        namesToPlugins[pluginName] = pluginModule;\n        isOrderingDirty = true;\n      }\n    }\n    if (isOrderingDirty) {\n      recomputePluginOrdering();\n    }\n  },\n\n  /**\n   * Looks up the plugin for the supplied event.\n   *\n   * @param {object} event A synthetic event.\n   * @return {?object} The plugin that created the supplied event.\n   * @internal\n   */\n  getPluginModuleForEvent: function (event) {\n    var dispatchConfig = event.dispatchConfig;\n    if (dispatchConfig.registrationName) {\n      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;\n    }\n    if (dispatchConfig.phasedRegistrationNames !== undefined) {\n      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see\n      // that it is not undefined.\n      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n\n      for (var phase in phasedRegistrationNames) {\n        if (!phasedRegistrationNames.hasOwnProperty(phase)) {\n          continue;\n        }\n        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];\n        if (pluginModule) {\n          return pluginModule;\n        }\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _resetEventPlugins: function () {\n    eventPluginOrder = null;\n    for (var pluginName in namesToPlugins) {\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\n        delete namesToPlugins[pluginName];\n      }\n    }\n    EventPluginRegistry.plugins.length = 0;\n\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\n    for (var eventName in eventNameDispatchConfigs) {\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\n        delete eventNameDispatchConfigs[eventName];\n      }\n    }\n\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\n    for (var registrationName in registrationNameModules) {\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\n        delete registrationNameModules[registrationName];\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;\n      for (var lowerCasedName in possibleRegistrationNames) {\n        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {\n          delete possibleRegistrationNames[lowerCasedName];\n        }\n      }\n    }\n  }\n\n};\n\nmodule.exports = EventPluginRegistry;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react_dom$lib$reactProdInvariant"]],"~:properties",["^5",["registrationNameDependencies","injectEventPluginOrder","ondblclick","possibleRegistrationNames","eventNameDispatchConfigs","length","registrationNameModules","injectEventPluginsByName","_resetEventPlugins","getPluginModuleForEvent","plugins"]],"~:compiled-at",1635270336804,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$EventPluginRegistry.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/EventPluginRegistry.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$EventPluginRegistry\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * \\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Injectable ordering of event plugins.\\n */\\nvar eventPluginOrder = null;\\n\\n/**\\n * Injectable mapping from names to event plugin modules.\\n */\\nvar namesToPlugins = {};\\n\\n/**\\n * Recomputes the plugin list using the injected plugins and plugin ordering.\\n *\\n * @private\\n */\\nfunction recomputePluginOrdering() {\\n  if (!eventPluginOrder) {\\n    // Wait until an `eventPluginOrder` is injected.\\n    return;\\n  }\\n  for (var pluginName in namesToPlugins) {\\n    var pluginModule = namesToPlugins[pluginName];\\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\\n    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;\\n    if (EventPluginRegistry.plugins[pluginIndex]) {\\n      continue;\\n    }\\n    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;\\n    EventPluginRegistry.plugins[pluginIndex] = pluginModule;\\n    var publishedEvents = pluginModule.eventTypes;\\n    for (var eventName in publishedEvents) {\\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;\\n    }\\n  }\\n}\\n\\n/**\\n * Publishes an event so that it can be dispatched by the supplied plugin.\\n *\\n * @param {object} dispatchConfig Dispatch configuration for the event.\\n * @param {object} PluginModule Plugin publishing the event.\\n * @return {boolean} True if the event was successfully published.\\n * @private\\n */\\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\\n  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;\\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\\n\\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\\n  if (phasedRegistrationNames) {\\n    for (var phaseName in phasedRegistrationNames) {\\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\\n      }\\n    }\\n    return true;\\n  } else if (dispatchConfig.registrationName) {\\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\\n    return true;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Publishes a registration name that is used to identify dispatched events and\\n * can be used with `EventPluginHub.putListener` to register listeners.\\n *\\n * @param {string} registrationName Registration name to add.\\n * @param {object} PluginModule Plugin publishing the event.\\n * @private\\n */\\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\\n  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;\\n  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;\\n  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    var lowerCasedName = registrationName.toLowerCase();\\n    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;\\n\\n    if (registrationName === 'onDoubleClick') {\\n      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;\\n    }\\n  }\\n}\\n\\n/**\\n * Registers plugins so that they can extract and dispatch events.\\n *\\n * @see {EventPluginHub}\\n */\\nvar EventPluginRegistry = {\\n\\n  /**\\n   * Ordered list of injected plugins.\\n   */\\n  plugins: [],\\n\\n  /**\\n   * Mapping from event name to dispatch config\\n   */\\n  eventNameDispatchConfigs: {},\\n\\n  /**\\n   * Mapping from registration name to plugin module\\n   */\\n  registrationNameModules: {},\\n\\n  /**\\n   * Mapping from registration name to event name\\n   */\\n  registrationNameDependencies: {},\\n\\n  /**\\n   * Mapping from lowercase registration names to the properly cased version,\\n   * used to warn in the case of missing event handlers. Available\\n   * only in __DEV__.\\n   * @type {Object}\\n   */\\n  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,\\n  // Trust the developer to only use possibleRegistrationNames in __DEV__\\n\\n  /**\\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\\n   * to be decoupled from injection of the actual plugins so that ordering is\\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\\n   *\\n   * @param {array} InjectedEventPluginOrder\\n   * @internal\\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\\n   */\\n  injectEventPluginOrder: function (injectedEventPluginOrder) {\\n    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;\\n    // Clone the ordering so it cannot be dynamically mutated.\\n    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\\n    recomputePluginOrdering();\\n  },\\n\\n  /**\\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\\n   * in the ordering injected by `injectEventPluginOrder`.\\n   *\\n   * Plugins can be injected as part of page initialization or on-the-fly.\\n   *\\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\\n   * @internal\\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\\n   */\\n  injectEventPluginsByName: function (injectedNamesToPlugins) {\\n    var isOrderingDirty = false;\\n    for (var pluginName in injectedNamesToPlugins) {\\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\\n        continue;\\n      }\\n      var pluginModule = injectedNamesToPlugins[pluginName];\\n      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\\n        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;\\n        namesToPlugins[pluginName] = pluginModule;\\n        isOrderingDirty = true;\\n      }\\n    }\\n    if (isOrderingDirty) {\\n      recomputePluginOrdering();\\n    }\\n  },\\n\\n  /**\\n   * Looks up the plugin for the supplied event.\\n   *\\n   * @param {object} event A synthetic event.\\n   * @return {?object} The plugin that created the supplied event.\\n   * @internal\\n   */\\n  getPluginModuleForEvent: function (event) {\\n    var dispatchConfig = event.dispatchConfig;\\n    if (dispatchConfig.registrationName) {\\n      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;\\n    }\\n    if (dispatchConfig.phasedRegistrationNames !== undefined) {\\n      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see\\n      // that it is not undefined.\\n      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\\n\\n      for (var phase in phasedRegistrationNames) {\\n        if (!phasedRegistrationNames.hasOwnProperty(phase)) {\\n          continue;\\n        }\\n        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];\\n        if (pluginModule) {\\n          return pluginModule;\\n        }\\n      }\\n    }\\n    return null;\\n  },\\n\\n  /**\\n   * Exposed for unit testing.\\n   * @private\\n   */\\n  _resetEventPlugins: function () {\\n    eventPluginOrder = null;\\n    for (var pluginName in namesToPlugins) {\\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\\n        delete namesToPlugins[pluginName];\\n      }\\n    }\\n    EventPluginRegistry.plugins.length = 0;\\n\\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\\n    for (var eventName in eventNameDispatchConfigs) {\\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\\n        delete eventNameDispatchConfigs[eventName];\\n      }\\n    }\\n\\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\\n    for (var registrationName in registrationNameModules) {\\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\\n        delete registrationNameModules[registrationName];\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;\\n      for (var lowerCasedName in possibleRegistrationNames) {\\n        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {\\n          delete possibleRegistrationNames[lowerCasedName];\\n        }\\n      }\\n    }\\n  }\\n\\n};\\n\\nmodule.exports = EventPluginRegistry;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"recomputePluginOrdering\",\"eventPluginOrder\",\"pluginName\",\"namesToPlugins\",\"pluginModule\",\"pluginIndex\",\"indexOf\",\"invariant\",\"EventPluginRegistry\",\"plugins\",\"extractEvents\",\"publishedEvents\",\"eventTypes\",\"eventName\",\"phaseName\",\"eventNameDispatchConfigs\",\"hasOwnProperty\",\"dispatchConfig\",\"phasedRegistrationNames\",\"publishRegistrationName\",\"phasedRegistrationName\",\"registrationName\",\"registrationNameModules\",\"registrationNameDependencies\",\"dependencies\",\"lowerCasedName\",\"toLowerCase\",\"possibleRegistrationNames\",\"ondblclick\",\"injectEventPluginOrder\",\"injectedEventPluginOrder\",\"Array\",\"prototype\",\"slice\",\"call\",\"injectEventPluginsByName\",\"injectedNamesToPlugins\",\"isOrderingDirty\",\"getPluginModuleForEvent\",\"event\",\"undefined\",\"phase\",\"_resetEventPlugins\",\"length\"]\n}\n"]