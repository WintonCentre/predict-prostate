["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactDebugTool.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactDebugTool=function(global,process,require,module,exports,shadow$shims){function emitEvent(event$jscomp$0,arg1,arg2,arg3,arg4,arg5){for(var i=0;i<hooks.length;i++){var hook=hooks[i],fn=hook[event$jscomp$0];if(fn){var event=event$jscomp$0;try{fn.call(hook,arg1,arg2,arg3,arg4,arg5)}catch(e){warning(didHookThrowForEvent[event],\"Exception thrown by hook while handling %s: %s\",event,e+\"\\n\"+e.stack),didHookThrowForEvent[event]=!0}}}}function getTreeSnapshot(registeredIDs){return registeredIDs.reduce(function(tree,\nid){var ownerID=ReactComponentTreeHook.getOwnerID(id),parentID=ReactComponentTreeHook.getParentID(id);tree[id]={displayName:ReactComponentTreeHook.getDisplayName(id),text:ReactComponentTreeHook.getText(id),updateCount:ReactComponentTreeHook.getUpdateCount(id),childIDs:ReactComponentTreeHook.getChildIDs(id),ownerID:ownerID||parentID&&ReactComponentTreeHook.getOwnerID(parentID)||0,parentID:parentID};return tree},{})}function resetMeasurements(){var previousStartTime=currentFlushStartTime,previousMeasurements=\ncurrentFlushMeasurements,previousOperations=ReactHostOperationHistoryHook.getHistory();if(0===currentFlushNesting)currentFlushStartTime=0,currentFlushMeasurements=[],ReactComponentTreeHook.purgeUnmountedComponents(),ReactHostOperationHistoryHook.clearHistory();else{if(previousMeasurements.length||previousOperations.length){var registeredIDs=ReactComponentTreeHook.getRegisteredIDs();flushHistory.push({duration:performanceNow()-previousStartTime,measurements:previousMeasurements||[],operations:previousOperations||\n[],treeSnapshot:getTreeSnapshot(registeredIDs)})}ReactComponentTreeHook.purgeUnmountedComponents();ReactHostOperationHistoryHook.clearHistory();currentFlushStartTime=performanceNow();currentFlushMeasurements=[]}}function checkDebugID(debugID){1<arguments.length&&void 0!==arguments[1]&&arguments[1]&&0===debugID||debugID||warning(!1,\"ReactDebugTool: debugID may not be empty.\")}function shouldMark(debugID){if(!isProfiling||!canUsePerformanceMeasure)return!1;debugID=ReactComponentTreeHook.getElement(debugID);\nreturn null==debugID||\"object\"!==typeof debugID||\"string\"===typeof debugID.type?!1:!0}function markBegin(debugID,markType){shouldMark(debugID)&&(debugID=debugID+\"::\"+markType,lastMarkTimeStamp=performanceNow(),performance.mark(debugID))}function markEnd(debugID,markType){if(shouldMark(debugID)){var markName=debugID+\"::\"+markType;debugID=ReactComponentTreeHook.getDisplayName(debugID)||\"Unknown\";if(.1<performanceNow()-lastMarkTimeStamp){var measurementName=debugID+\" [\"+markType+\"]\";performance.measure(measurementName,\nmarkName)}performance.clearMarks(markName);performance.clearMeasures(measurementName)}}global=require(\"module$node_modules$react_dom$lib$ReactInvalidSetStateWarningHook\");var ReactHostOperationHistoryHook=require(\"module$node_modules$react_dom$lib$ReactHostOperationHistoryHook\"),ReactComponentTreeHook=require(\"module$node_modules$react$lib$ReactComponentTreeHook\");process=require(\"module$node_modules$fbjs$lib$ExecutionEnvironment\");var performanceNow=require(\"module$node_modules$fbjs$lib$performanceNow\"),\nwarning=require(\"module$node_modules$fbjs$lib$warning\"),hooks=[],didHookThrowForEvent={},isProfiling=!1,flushHistory=[],lifeCycleTimerStack=[],currentFlushNesting=0,currentFlushMeasurements=[],currentFlushStartTime=0,currentTimerDebugID=null,currentTimerStartTime=0,currentTimerNestedFlushDuration=0,currentTimerType=null,lifeCycleTimerHasWarned=!1,lastMarkTimeStamp=0,canUsePerformanceMeasure=\"undefined\"!==typeof performance&&\"function\"===typeof performance.mark&&\"function\"===typeof performance.clearMarks&&\n\"function\"===typeof performance.measure&&\"function\"===typeof performance.clearMeasures,ReactDebugTool={addHook:function(hook){hooks.push(hook)},removeHook:function(hook){for(var i=0;i<hooks.length;i++)hooks[i]===hook&&(hooks.splice(i,1),i--)},isProfiling:function(){return isProfiling},beginProfiling:function(){isProfiling||(isProfiling=!0,flushHistory.length=0,resetMeasurements(),ReactDebugTool.addHook(ReactHostOperationHistoryHook))},endProfiling:function(){isProfiling&&(isProfiling=!1,resetMeasurements(),\nReactDebugTool.removeHook(ReactHostOperationHistoryHook))},getFlushHistory:function(){return flushHistory},onBeginFlush:function(){currentFlushNesting++;resetMeasurements();var currentTimer={startTime:currentTimerStartTime,nestedFlushStartTime:performanceNow(),debugID:currentTimerDebugID,timerType:currentTimerType};lifeCycleTimerStack.push(currentTimer);currentTimerNestedFlushDuration=currentTimerStartTime=0;currentTimerType=currentTimerDebugID=null;emitEvent(\"onBeginFlush\")},onEndFlush:function(){resetMeasurements();\ncurrentFlushNesting--;var _lifeCycleTimerStack$=lifeCycleTimerStack.pop(),startTime=_lifeCycleTimerStack$.startTime,nestedFlushStartTime=_lifeCycleTimerStack$.nestedFlushStartTime,debugID=_lifeCycleTimerStack$.debugID;_lifeCycleTimerStack$=_lifeCycleTimerStack$.timerType;nestedFlushStartTime=performanceNow()-nestedFlushStartTime;currentTimerStartTime=startTime;currentTimerNestedFlushDuration+=nestedFlushStartTime;currentTimerDebugID=debugID;currentTimerType=_lifeCycleTimerStack$;emitEvent(\"onEndFlush\")},\nonBeginLifeCycleTimer:function(debugID,timerType){checkDebugID(debugID);emitEvent(\"onBeginLifeCycleTimer\",debugID,timerType);markBegin(debugID,timerType);0!==currentFlushNesting&&(currentTimerType&&!lifeCycleTimerHasWarned&&(warning(!1,\"There is an internal error in the React performance measurement code. Did not expect %s timer to start while %s timer is still in progress for %s instance.\",timerType,currentTimerType||\"no\",debugID===currentTimerDebugID?\"the same\":\"another\"),lifeCycleTimerHasWarned=\n!0),currentTimerStartTime=performanceNow(),currentTimerNestedFlushDuration=0,currentTimerDebugID=debugID,currentTimerType=timerType)},onEndLifeCycleTimer:function(debugID,timerType){checkDebugID(debugID);0!==currentFlushNesting&&(currentTimerType===timerType||lifeCycleTimerHasWarned||(warning(!1,\"There is an internal error in the React performance measurement code. We did not expect %s timer to stop while %s timer is still in progress for %s instance. Please report this as a bug in React.\",timerType,\ncurrentTimerType||\"no\",debugID===currentTimerDebugID?\"the same\":\"another\"),lifeCycleTimerHasWarned=!0),isProfiling&&currentFlushMeasurements.push({timerType:timerType,instanceID:debugID,duration:performanceNow()-currentTimerStartTime-currentTimerNestedFlushDuration}),currentTimerNestedFlushDuration=currentTimerStartTime=0,currentTimerType=currentTimerDebugID=null);markEnd(debugID,timerType);emitEvent(\"onEndLifeCycleTimer\",debugID,timerType)},onBeginProcessingChildContext:function(){emitEvent(\"onBeginProcessingChildContext\")},\nonEndProcessingChildContext:function(){emitEvent(\"onEndProcessingChildContext\")},onHostOperation:function(operation){checkDebugID(operation.instanceID);emitEvent(\"onHostOperation\",operation)},onSetState:function(){emitEvent(\"onSetState\")},onSetChildren:function(debugID,childDebugIDs){checkDebugID(debugID);childDebugIDs.forEach(checkDebugID);emitEvent(\"onSetChildren\",debugID,childDebugIDs)},onBeforeMountComponent:function(debugID,element,parentDebugID){checkDebugID(debugID);checkDebugID(parentDebugID,\n!0);emitEvent(\"onBeforeMountComponent\",debugID,element,parentDebugID);markBegin(debugID,\"mount\")},onMountComponent:function(debugID){checkDebugID(debugID);markEnd(debugID,\"mount\");emitEvent(\"onMountComponent\",debugID)},onBeforeUpdateComponent:function(debugID,element){checkDebugID(debugID);emitEvent(\"onBeforeUpdateComponent\",debugID,element);markBegin(debugID,\"update\")},onUpdateComponent:function(debugID){checkDebugID(debugID);markEnd(debugID,\"update\");emitEvent(\"onUpdateComponent\",debugID)},onBeforeUnmountComponent:function(debugID){checkDebugID(debugID);\nemitEvent(\"onBeforeUnmountComponent\",debugID);markBegin(debugID,\"unmount\")},onUnmountComponent:function(debugID){checkDebugID(debugID);markEnd(debugID,\"unmount\");emitEvent(\"onUnmountComponent\",debugID)},onTestEvent:function(){emitEvent(\"onTestEvent\")}};ReactDebugTool.addDevtool=ReactDebugTool.addHook;ReactDebugTool.removeDevtool=ReactDebugTool.removeHook;ReactDebugTool.addHook(global);ReactDebugTool.addHook(ReactComponentTreeHook);/[?&]react_perf\\b/.test(process.canUseDOM&&window.location.href||\"\")&&\nReactDebugTool.beginProfiling();module.exports=ReactDebugTool}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactDebugTool\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2016-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n'use strict';\n\nvar ReactInvalidSetStateWarningHook = require('./ReactInvalidSetStateWarningHook');\nvar ReactHostOperationHistoryHook = require('./ReactHostOperationHistoryHook');\nvar ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar performanceNow = require('fbjs/lib/performanceNow');\nvar warning = require('fbjs/lib/warning');\n\nvar hooks = [];\nvar didHookThrowForEvent = {};\n\nfunction callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {\n  try {\n    fn.call(context, arg1, arg2, arg3, arg4, arg5);\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\\n' + e.stack) : void 0;\n    didHookThrowForEvent[event] = true;\n  }\n}\n\nfunction emitEvent(event, arg1, arg2, arg3, arg4, arg5) {\n  for (var i = 0; i < hooks.length; i++) {\n    var hook = hooks[i];\n    var fn = hook[event];\n    if (fn) {\n      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);\n    }\n  }\n}\n\nvar isProfiling = false;\nvar flushHistory = [];\nvar lifeCycleTimerStack = [];\nvar currentFlushNesting = 0;\nvar currentFlushMeasurements = [];\nvar currentFlushStartTime = 0;\nvar currentTimerDebugID = null;\nvar currentTimerStartTime = 0;\nvar currentTimerNestedFlushDuration = 0;\nvar currentTimerType = null;\n\nvar lifeCycleTimerHasWarned = false;\n\nfunction clearHistory() {\n  ReactComponentTreeHook.purgeUnmountedComponents();\n  ReactHostOperationHistoryHook.clearHistory();\n}\n\nfunction getTreeSnapshot(registeredIDs) {\n  return registeredIDs.reduce(function (tree, id) {\n    var ownerID = ReactComponentTreeHook.getOwnerID(id);\n    var parentID = ReactComponentTreeHook.getParentID(id);\n    tree[id] = {\n      displayName: ReactComponentTreeHook.getDisplayName(id),\n      text: ReactComponentTreeHook.getText(id),\n      updateCount: ReactComponentTreeHook.getUpdateCount(id),\n      childIDs: ReactComponentTreeHook.getChildIDs(id),\n      // Text nodes don't have owners but this is close enough.\n      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,\n      parentID: parentID\n    };\n    return tree;\n  }, {});\n}\n\nfunction resetMeasurements() {\n  var previousStartTime = currentFlushStartTime;\n  var previousMeasurements = currentFlushMeasurements;\n  var previousOperations = ReactHostOperationHistoryHook.getHistory();\n\n  if (currentFlushNesting === 0) {\n    currentFlushStartTime = 0;\n    currentFlushMeasurements = [];\n    clearHistory();\n    return;\n  }\n\n  if (previousMeasurements.length || previousOperations.length) {\n    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();\n    flushHistory.push({\n      duration: performanceNow() - previousStartTime,\n      measurements: previousMeasurements || [],\n      operations: previousOperations || [],\n      treeSnapshot: getTreeSnapshot(registeredIDs)\n    });\n  }\n\n  clearHistory();\n  currentFlushStartTime = performanceNow();\n  currentFlushMeasurements = [];\n}\n\nfunction checkDebugID(debugID) {\n  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (allowRoot && debugID === 0) {\n    return;\n  }\n  if (!debugID) {\n    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;\n  }\n}\n\nfunction beginLifeCycleTimer(debugID, timerType) {\n  if (currentFlushNesting === 0) {\n    return;\n  }\n  if (currentTimerType && !lifeCycleTimerHasWarned) {\n    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;\n    lifeCycleTimerHasWarned = true;\n  }\n  currentTimerStartTime = performanceNow();\n  currentTimerNestedFlushDuration = 0;\n  currentTimerDebugID = debugID;\n  currentTimerType = timerType;\n}\n\nfunction endLifeCycleTimer(debugID, timerType) {\n  if (currentFlushNesting === 0) {\n    return;\n  }\n  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {\n    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;\n    lifeCycleTimerHasWarned = true;\n  }\n  if (isProfiling) {\n    currentFlushMeasurements.push({\n      timerType: timerType,\n      instanceID: debugID,\n      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration\n    });\n  }\n  currentTimerStartTime = 0;\n  currentTimerNestedFlushDuration = 0;\n  currentTimerDebugID = null;\n  currentTimerType = null;\n}\n\nfunction pauseCurrentLifeCycleTimer() {\n  var currentTimer = {\n    startTime: currentTimerStartTime,\n    nestedFlushStartTime: performanceNow(),\n    debugID: currentTimerDebugID,\n    timerType: currentTimerType\n  };\n  lifeCycleTimerStack.push(currentTimer);\n  currentTimerStartTime = 0;\n  currentTimerNestedFlushDuration = 0;\n  currentTimerDebugID = null;\n  currentTimerType = null;\n}\n\nfunction resumeCurrentLifeCycleTimer() {\n  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),\n      startTime = _lifeCycleTimerStack$.startTime,\n      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,\n      debugID = _lifeCycleTimerStack$.debugID,\n      timerType = _lifeCycleTimerStack$.timerType;\n\n  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;\n  currentTimerStartTime = startTime;\n  currentTimerNestedFlushDuration += nestedFlushDuration;\n  currentTimerDebugID = debugID;\n  currentTimerType = timerType;\n}\n\nvar lastMarkTimeStamp = 0;\nvar canUsePerformanceMeasure =\n// $FlowFixMe https://github.com/facebook/flow/issues/2345\ntypeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\nfunction shouldMark(debugID) {\n  if (!isProfiling || !canUsePerformanceMeasure) {\n    return false;\n  }\n  var element = ReactComponentTreeHook.getElement(debugID);\n  if (element == null || typeof element !== 'object') {\n    return false;\n  }\n  var isHostElement = typeof element.type === 'string';\n  if (isHostElement) {\n    return false;\n  }\n  return true;\n}\n\nfunction markBegin(debugID, markType) {\n  if (!shouldMark(debugID)) {\n    return;\n  }\n\n  var markName = debugID + '::' + markType;\n  lastMarkTimeStamp = performanceNow();\n  performance.mark(markName);\n}\n\nfunction markEnd(debugID, markType) {\n  if (!shouldMark(debugID)) {\n    return;\n  }\n\n  var markName = debugID + '::' + markType;\n  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';\n\n  // Chrome has an issue of dropping markers recorded too fast:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652\n  // To work around this, we will not report very small measurements.\n  // I determined the magic number by tweaking it back and forth.\n  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.\n  // When the bug is fixed, we can `measure()` unconditionally if we want to.\n  var timeStamp = performanceNow();\n  if (timeStamp - lastMarkTimeStamp > 0.1) {\n    var measurementName = displayName + ' [' + markType + ']';\n    performance.measure(measurementName, markName);\n  }\n\n  performance.clearMarks(markName);\n  performance.clearMeasures(measurementName);\n}\n\nvar ReactDebugTool = {\n  addHook: function (hook) {\n    hooks.push(hook);\n  },\n  removeHook: function (hook) {\n    for (var i = 0; i < hooks.length; i++) {\n      if (hooks[i] === hook) {\n        hooks.splice(i, 1);\n        i--;\n      }\n    }\n  },\n  isProfiling: function () {\n    return isProfiling;\n  },\n  beginProfiling: function () {\n    if (isProfiling) {\n      return;\n    }\n\n    isProfiling = true;\n    flushHistory.length = 0;\n    resetMeasurements();\n    ReactDebugTool.addHook(ReactHostOperationHistoryHook);\n  },\n  endProfiling: function () {\n    if (!isProfiling) {\n      return;\n    }\n\n    isProfiling = false;\n    resetMeasurements();\n    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);\n  },\n  getFlushHistory: function () {\n    return flushHistory;\n  },\n  onBeginFlush: function () {\n    currentFlushNesting++;\n    resetMeasurements();\n    pauseCurrentLifeCycleTimer();\n    emitEvent('onBeginFlush');\n  },\n  onEndFlush: function () {\n    resetMeasurements();\n    currentFlushNesting--;\n    resumeCurrentLifeCycleTimer();\n    emitEvent('onEndFlush');\n  },\n  onBeginLifeCycleTimer: function (debugID, timerType) {\n    checkDebugID(debugID);\n    emitEvent('onBeginLifeCycleTimer', debugID, timerType);\n    markBegin(debugID, timerType);\n    beginLifeCycleTimer(debugID, timerType);\n  },\n  onEndLifeCycleTimer: function (debugID, timerType) {\n    checkDebugID(debugID);\n    endLifeCycleTimer(debugID, timerType);\n    markEnd(debugID, timerType);\n    emitEvent('onEndLifeCycleTimer', debugID, timerType);\n  },\n  onBeginProcessingChildContext: function () {\n    emitEvent('onBeginProcessingChildContext');\n  },\n  onEndProcessingChildContext: function () {\n    emitEvent('onEndProcessingChildContext');\n  },\n  onHostOperation: function (operation) {\n    checkDebugID(operation.instanceID);\n    emitEvent('onHostOperation', operation);\n  },\n  onSetState: function () {\n    emitEvent('onSetState');\n  },\n  onSetChildren: function (debugID, childDebugIDs) {\n    checkDebugID(debugID);\n    childDebugIDs.forEach(checkDebugID);\n    emitEvent('onSetChildren', debugID, childDebugIDs);\n  },\n  onBeforeMountComponent: function (debugID, element, parentDebugID) {\n    checkDebugID(debugID);\n    checkDebugID(parentDebugID, true);\n    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);\n    markBegin(debugID, 'mount');\n  },\n  onMountComponent: function (debugID) {\n    checkDebugID(debugID);\n    markEnd(debugID, 'mount');\n    emitEvent('onMountComponent', debugID);\n  },\n  onBeforeUpdateComponent: function (debugID, element) {\n    checkDebugID(debugID);\n    emitEvent('onBeforeUpdateComponent', debugID, element);\n    markBegin(debugID, 'update');\n  },\n  onUpdateComponent: function (debugID) {\n    checkDebugID(debugID);\n    markEnd(debugID, 'update');\n    emitEvent('onUpdateComponent', debugID);\n  },\n  onBeforeUnmountComponent: function (debugID) {\n    checkDebugID(debugID);\n    emitEvent('onBeforeUnmountComponent', debugID);\n    markBegin(debugID, 'unmount');\n  },\n  onUnmountComponent: function (debugID) {\n    checkDebugID(debugID);\n    markEnd(debugID, 'unmount');\n    emitEvent('onUnmountComponent', debugID);\n  },\n  onTestEvent: function () {\n    emitEvent('onTestEvent');\n  }\n};\n\n// TODO remove these when RN/www gets updated\nReactDebugTool.addDevtool = ReactDebugTool.addHook;\nReactDebugTool.removeDevtool = ReactDebugTool.removeHook;\n\nReactDebugTool.addHook(ReactInvalidSetStateWarningHook);\nReactDebugTool.addHook(ReactComponentTreeHook);\nvar url = ExecutionEnvironment.canUseDOM && window.location.href || '';\nif (/[?&]react_perf\\b/.test(url)) {\n  ReactDebugTool.beginProfiling();\n}\n\nmodule.exports = ReactDebugTool;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_dom$lib$ReactHostOperationHistoryHook","~$module$node_modules$react$lib$ReactComponentTreeHook","~$shadow.js","~$module$node_modules$fbjs$lib$performanceNow","~$module$node_modules$fbjs$lib$ExecutionEnvironment","~$module$node_modules$fbjs$lib$warning","~$module$node_modules$react_dom$lib$ReactInvalidSetStateWarningHook"]],"~:properties",["^5",["getFlushHistory","onTestEvent","nestedFlushStartTime","instanceID","measurements","onBeforeMountComponent","ownerID","onUpdateComponent","displayName","onHostOperation","addDevtool","onEndLifeCycleTimer","removeHook","onBeginLifeCycleTimer","endProfiling","addHook","onEndFlush","parentID","startTime","updateCount","beginProfiling","onSetChildren","text","onBeforeUpdateComponent","onBeginFlush","length","onBeforeUnmountComponent","isProfiling","duration","onBeginProcessingChildContext","onMountComponent","onUnmountComponent","treeSnapshot","removeDevtool","childIDs","onSetState","timerType","onEndProcessingChildContext","debugID","operations"]],"~:compiled-at",1635270336822,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactDebugTool.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/ReactDebugTool.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactDebugTool\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2016-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * \\n */\\n\\n'use strict';\\n\\nvar ReactInvalidSetStateWarningHook = require('./ReactInvalidSetStateWarningHook');\\nvar ReactHostOperationHistoryHook = require('./ReactHostOperationHistoryHook');\\nvar ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\\n\\nvar performanceNow = require('fbjs/lib/performanceNow');\\nvar warning = require('fbjs/lib/warning');\\n\\nvar hooks = [];\\nvar didHookThrowForEvent = {};\\n\\nfunction callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {\\n  try {\\n    fn.call(context, arg1, arg2, arg3, arg4, arg5);\\n  } catch (e) {\\n    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\\\\n' + e.stack) : void 0;\\n    didHookThrowForEvent[event] = true;\\n  }\\n}\\n\\nfunction emitEvent(event, arg1, arg2, arg3, arg4, arg5) {\\n  for (var i = 0; i < hooks.length; i++) {\\n    var hook = hooks[i];\\n    var fn = hook[event];\\n    if (fn) {\\n      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);\\n    }\\n  }\\n}\\n\\nvar isProfiling = false;\\nvar flushHistory = [];\\nvar lifeCycleTimerStack = [];\\nvar currentFlushNesting = 0;\\nvar currentFlushMeasurements = [];\\nvar currentFlushStartTime = 0;\\nvar currentTimerDebugID = null;\\nvar currentTimerStartTime = 0;\\nvar currentTimerNestedFlushDuration = 0;\\nvar currentTimerType = null;\\n\\nvar lifeCycleTimerHasWarned = false;\\n\\nfunction clearHistory() {\\n  ReactComponentTreeHook.purgeUnmountedComponents();\\n  ReactHostOperationHistoryHook.clearHistory();\\n}\\n\\nfunction getTreeSnapshot(registeredIDs) {\\n  return registeredIDs.reduce(function (tree, id) {\\n    var ownerID = ReactComponentTreeHook.getOwnerID(id);\\n    var parentID = ReactComponentTreeHook.getParentID(id);\\n    tree[id] = {\\n      displayName: ReactComponentTreeHook.getDisplayName(id),\\n      text: ReactComponentTreeHook.getText(id),\\n      updateCount: ReactComponentTreeHook.getUpdateCount(id),\\n      childIDs: ReactComponentTreeHook.getChildIDs(id),\\n      // Text nodes don't have owners but this is close enough.\\n      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,\\n      parentID: parentID\\n    };\\n    return tree;\\n  }, {});\\n}\\n\\nfunction resetMeasurements() {\\n  var previousStartTime = currentFlushStartTime;\\n  var previousMeasurements = currentFlushMeasurements;\\n  var previousOperations = ReactHostOperationHistoryHook.getHistory();\\n\\n  if (currentFlushNesting === 0) {\\n    currentFlushStartTime = 0;\\n    currentFlushMeasurements = [];\\n    clearHistory();\\n    return;\\n  }\\n\\n  if (previousMeasurements.length || previousOperations.length) {\\n    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();\\n    flushHistory.push({\\n      duration: performanceNow() - previousStartTime,\\n      measurements: previousMeasurements || [],\\n      operations: previousOperations || [],\\n      treeSnapshot: getTreeSnapshot(registeredIDs)\\n    });\\n  }\\n\\n  clearHistory();\\n  currentFlushStartTime = performanceNow();\\n  currentFlushMeasurements = [];\\n}\\n\\nfunction checkDebugID(debugID) {\\n  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n  if (allowRoot && debugID === 0) {\\n    return;\\n  }\\n  if (!debugID) {\\n    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;\\n  }\\n}\\n\\nfunction beginLifeCycleTimer(debugID, timerType) {\\n  if (currentFlushNesting === 0) {\\n    return;\\n  }\\n  if (currentTimerType && !lifeCycleTimerHasWarned) {\\n    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;\\n    lifeCycleTimerHasWarned = true;\\n  }\\n  currentTimerStartTime = performanceNow();\\n  currentTimerNestedFlushDuration = 0;\\n  currentTimerDebugID = debugID;\\n  currentTimerType = timerType;\\n}\\n\\nfunction endLifeCycleTimer(debugID, timerType) {\\n  if (currentFlushNesting === 0) {\\n    return;\\n  }\\n  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {\\n    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;\\n    lifeCycleTimerHasWarned = true;\\n  }\\n  if (isProfiling) {\\n    currentFlushMeasurements.push({\\n      timerType: timerType,\\n      instanceID: debugID,\\n      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration\\n    });\\n  }\\n  currentTimerStartTime = 0;\\n  currentTimerNestedFlushDuration = 0;\\n  currentTimerDebugID = null;\\n  currentTimerType = null;\\n}\\n\\nfunction pauseCurrentLifeCycleTimer() {\\n  var currentTimer = {\\n    startTime: currentTimerStartTime,\\n    nestedFlushStartTime: performanceNow(),\\n    debugID: currentTimerDebugID,\\n    timerType: currentTimerType\\n  };\\n  lifeCycleTimerStack.push(currentTimer);\\n  currentTimerStartTime = 0;\\n  currentTimerNestedFlushDuration = 0;\\n  currentTimerDebugID = null;\\n  currentTimerType = null;\\n}\\n\\nfunction resumeCurrentLifeCycleTimer() {\\n  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),\\n      startTime = _lifeCycleTimerStack$.startTime,\\n      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,\\n      debugID = _lifeCycleTimerStack$.debugID,\\n      timerType = _lifeCycleTimerStack$.timerType;\\n\\n  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;\\n  currentTimerStartTime = startTime;\\n  currentTimerNestedFlushDuration += nestedFlushDuration;\\n  currentTimerDebugID = debugID;\\n  currentTimerType = timerType;\\n}\\n\\nvar lastMarkTimeStamp = 0;\\nvar canUsePerformanceMeasure =\\n// $FlowFixMe https://github.com/facebook/flow/issues/2345\\ntypeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\\n\\nfunction shouldMark(debugID) {\\n  if (!isProfiling || !canUsePerformanceMeasure) {\\n    return false;\\n  }\\n  var element = ReactComponentTreeHook.getElement(debugID);\\n  if (element == null || typeof element !== 'object') {\\n    return false;\\n  }\\n  var isHostElement = typeof element.type === 'string';\\n  if (isHostElement) {\\n    return false;\\n  }\\n  return true;\\n}\\n\\nfunction markBegin(debugID, markType) {\\n  if (!shouldMark(debugID)) {\\n    return;\\n  }\\n\\n  var markName = debugID + '::' + markType;\\n  lastMarkTimeStamp = performanceNow();\\n  performance.mark(markName);\\n}\\n\\nfunction markEnd(debugID, markType) {\\n  if (!shouldMark(debugID)) {\\n    return;\\n  }\\n\\n  var markName = debugID + '::' + markType;\\n  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';\\n\\n  // Chrome has an issue of dropping markers recorded too fast:\\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652\\n  // To work around this, we will not report very small measurements.\\n  // I determined the magic number by tweaking it back and forth.\\n  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.\\n  // When the bug is fixed, we can `measure()` unconditionally if we want to.\\n  var timeStamp = performanceNow();\\n  if (timeStamp - lastMarkTimeStamp > 0.1) {\\n    var measurementName = displayName + ' [' + markType + ']';\\n    performance.measure(measurementName, markName);\\n  }\\n\\n  performance.clearMarks(markName);\\n  performance.clearMeasures(measurementName);\\n}\\n\\nvar ReactDebugTool = {\\n  addHook: function (hook) {\\n    hooks.push(hook);\\n  },\\n  removeHook: function (hook) {\\n    for (var i = 0; i < hooks.length; i++) {\\n      if (hooks[i] === hook) {\\n        hooks.splice(i, 1);\\n        i--;\\n      }\\n    }\\n  },\\n  isProfiling: function () {\\n    return isProfiling;\\n  },\\n  beginProfiling: function () {\\n    if (isProfiling) {\\n      return;\\n    }\\n\\n    isProfiling = true;\\n    flushHistory.length = 0;\\n    resetMeasurements();\\n    ReactDebugTool.addHook(ReactHostOperationHistoryHook);\\n  },\\n  endProfiling: function () {\\n    if (!isProfiling) {\\n      return;\\n    }\\n\\n    isProfiling = false;\\n    resetMeasurements();\\n    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);\\n  },\\n  getFlushHistory: function () {\\n    return flushHistory;\\n  },\\n  onBeginFlush: function () {\\n    currentFlushNesting++;\\n    resetMeasurements();\\n    pauseCurrentLifeCycleTimer();\\n    emitEvent('onBeginFlush');\\n  },\\n  onEndFlush: function () {\\n    resetMeasurements();\\n    currentFlushNesting--;\\n    resumeCurrentLifeCycleTimer();\\n    emitEvent('onEndFlush');\\n  },\\n  onBeginLifeCycleTimer: function (debugID, timerType) {\\n    checkDebugID(debugID);\\n    emitEvent('onBeginLifeCycleTimer', debugID, timerType);\\n    markBegin(debugID, timerType);\\n    beginLifeCycleTimer(debugID, timerType);\\n  },\\n  onEndLifeCycleTimer: function (debugID, timerType) {\\n    checkDebugID(debugID);\\n    endLifeCycleTimer(debugID, timerType);\\n    markEnd(debugID, timerType);\\n    emitEvent('onEndLifeCycleTimer', debugID, timerType);\\n  },\\n  onBeginProcessingChildContext: function () {\\n    emitEvent('onBeginProcessingChildContext');\\n  },\\n  onEndProcessingChildContext: function () {\\n    emitEvent('onEndProcessingChildContext');\\n  },\\n  onHostOperation: function (operation) {\\n    checkDebugID(operation.instanceID);\\n    emitEvent('onHostOperation', operation);\\n  },\\n  onSetState: function () {\\n    emitEvent('onSetState');\\n  },\\n  onSetChildren: function (debugID, childDebugIDs) {\\n    checkDebugID(debugID);\\n    childDebugIDs.forEach(checkDebugID);\\n    emitEvent('onSetChildren', debugID, childDebugIDs);\\n  },\\n  onBeforeMountComponent: function (debugID, element, parentDebugID) {\\n    checkDebugID(debugID);\\n    checkDebugID(parentDebugID, true);\\n    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);\\n    markBegin(debugID, 'mount');\\n  },\\n  onMountComponent: function (debugID) {\\n    checkDebugID(debugID);\\n    markEnd(debugID, 'mount');\\n    emitEvent('onMountComponent', debugID);\\n  },\\n  onBeforeUpdateComponent: function (debugID, element) {\\n    checkDebugID(debugID);\\n    emitEvent('onBeforeUpdateComponent', debugID, element);\\n    markBegin(debugID, 'update');\\n  },\\n  onUpdateComponent: function (debugID) {\\n    checkDebugID(debugID);\\n    markEnd(debugID, 'update');\\n    emitEvent('onUpdateComponent', debugID);\\n  },\\n  onBeforeUnmountComponent: function (debugID) {\\n    checkDebugID(debugID);\\n    emitEvent('onBeforeUnmountComponent', debugID);\\n    markBegin(debugID, 'unmount');\\n  },\\n  onUnmountComponent: function (debugID) {\\n    checkDebugID(debugID);\\n    markEnd(debugID, 'unmount');\\n    emitEvent('onUnmountComponent', debugID);\\n  },\\n  onTestEvent: function () {\\n    emitEvent('onTestEvent');\\n  }\\n};\\n\\n// TODO remove these when RN/www gets updated\\nReactDebugTool.addDevtool = ReactDebugTool.addHook;\\nReactDebugTool.removeDevtool = ReactDebugTool.removeHook;\\n\\nReactDebugTool.addHook(ReactInvalidSetStateWarningHook);\\nReactDebugTool.addHook(ReactComponentTreeHook);\\nvar url = ExecutionEnvironment.canUseDOM && window.location.href || '';\\nif (/[?&]react_perf\\\\b/.test(url)) {\\n  ReactDebugTool.beginProfiling();\\n}\\n\\nmodule.exports = ReactDebugTool;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"emitEvent\",\"event\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"i\",\"hooks\",\"length\",\"hook\",\"fn\",\"call\",\"e\",\"warning\",\"didHookThrowForEvent\",\"stack\",\"getTreeSnapshot\",\"registeredIDs\",\"reduce\",\"tree\",\"id\",\"ownerID\",\"ReactComponentTreeHook\",\"getOwnerID\",\"parentID\",\"getParentID\",\"displayName\",\"getDisplayName\",\"text\",\"getText\",\"updateCount\",\"getUpdateCount\",\"childIDs\",\"getChildIDs\",\"resetMeasurements\",\"previousStartTime\",\"currentFlushStartTime\",\"previousMeasurements\",\"currentFlushMeasurements\",\"previousOperations\",\"ReactHostOperationHistoryHook\",\"getHistory\",\"currentFlushNesting\",\"purgeUnmountedComponents\",\"clearHistory\",\"getRegisteredIDs\",\"flushHistory\",\"push\",\"duration\",\"performanceNow\",\"measurements\",\"operations\",\"treeSnapshot\",\"checkDebugID\",\"debugID\",\"arguments\",\"undefined\",\"shouldMark\",\"isProfiling\",\"canUsePerformanceMeasure\",\"element\",\"getElement\",\"type\",\"markBegin\",\"markType\",\"markName\",\"lastMarkTimeStamp\",\"performance\",\"mark\",\"markEnd\",\"timeStamp\",\"measurementName\",\"measure\",\"clearMarks\",\"clearMeasures\",\"ReactInvalidSetStateWarningHook\",\"ExecutionEnvironment\",\"lifeCycleTimerStack\",\"currentTimerDebugID\",\"currentTimerStartTime\",\"currentTimerNestedFlushDuration\",\"currentTimerType\",\"lifeCycleTimerHasWarned\",\"ReactDebugTool\",\"addHook\",\"removeHook\",\"splice\",\"beginProfiling\",\"endProfiling\",\"getFlushHistory\",\"onBeginFlush\",\"currentTimer\",\"startTime\",\"nestedFlushStartTime\",\"timerType\",\"onEndFlush\",\"_lifeCycleTimerStack$\",\"pop\",\"nestedFlushDuration\",\"onBeginLifeCycleTimer\",\"onEndLifeCycleTimer\",\"instanceID\",\"onBeginProcessingChildContext\",\"onEndProcessingChildContext\",\"onHostOperation\",\"operation\",\"onSetState\",\"onSetChildren\",\"childDebugIDs\",\"forEach\",\"onBeforeMountComponent\",\"parentDebugID\",\"onMountComponent\",\"onBeforeUpdateComponent\",\"onUpdateComponent\",\"onBeforeUnmountComponent\",\"onUnmountComponent\",\"onTestEvent\",\"addDevtool\",\"removeDevtool\",\"test\",\"canUseDOM\",\"window\",\"location\",\"href\"]\n}\n"]