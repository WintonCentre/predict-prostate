["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactDOMTreeTraversal.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactDOMTreeTraversal=function(global,require,module,exports){function getLowestCommonAncestor(instA,instB){\"_hostNode\"in instA?void 0:invariant(!1,\"getNodeFromInstance: Invalid argument.\");\"_hostNode\"in instB?void 0:invariant(!1,\"getNodeFromInstance: Invalid argument.\");for(var depthA=0,tempA=instA;tempA;tempA=tempA._hostParent)depthA++;tempA=0;for(var tempB=instB;tempB;tempB=tempB._hostParent)tempA++;for(;0<depthA-tempA;)instA=instA._hostParent,depthA--;\nfor(;0<tempA-depthA;)instB=instB._hostParent,tempA--;for(;depthA--;){if(instA===instB)return instA;instA=instA._hostParent;instB=instB._hostParent}return null}require(\"module$node_modules$react$lib$reactProdInvariant\");var invariant=require(\"module$node_modules$fbjs$lib$invariant\");module.exports={isAncestor:function(instA,instB){\"_hostNode\"in instA?void 0:invariant(!1,\"isAncestor: Invalid argument.\");\"_hostNode\"in instB?void 0:invariant(!1,\"isAncestor: Invalid argument.\");for(;instB;){if(instB===\ninstA)return!0;instB=instB._hostParent}return!1},getLowestCommonAncestor,getParentInstance:function(inst){\"_hostNode\"in inst?void 0:invariant(!1,\"getParentInstance: Invalid argument.\");return inst._hostParent},traverseTwoPhase:function(inst,fn,arg){for(var path=[];inst;)path.push(inst),inst=inst._hostParent;for(inst=path.length;0<inst--;)fn(path[inst],!1,arg);for(inst=0;inst<path.length;inst++)fn(path[inst],!0,arg)},traverseEnterLeave:function(from,to,fn,argFrom,argTo){for(var common=from&&to?getLowestCommonAncestor(from,\nto):null,pathFrom=[];from&&from!==common;)pathFrom.push(from),from=from._hostParent;for(from=[];to&&to!==common;)from.push(to),to=to._hostParent;for(to=0;to<pathFrom.length;to++)fn(pathFrom[to],!0,argFrom);for(to=from.length;0<to--;)fn(from[to],!1,argTo)}}}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactDOMTreeTraversal\"] = function(global,require,module,exports) {\n/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTreeTraversal\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = tempA._hostParent) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = tempB._hostParent) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = instA._hostParent;\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = instB._hostParent;\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB) {\n      return instA;\n    }\n    instA = instA._hostParent;\n    instB = instB._hostParent;\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n\n  while (instB) {\n    if (instB === instA) {\n      return true;\n    }\n    instB = instB._hostParent;\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;\n\n  return inst._hostParent;\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = inst._hostParent;\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], false, arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], true, arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (from && from !== common) {\n    pathFrom.push(from);\n    from = from._hostParent;\n  }\n  var pathTo = [];\n  while (to && to !== common) {\n    pathTo.push(to);\n    to = to._hostParent;\n  }\n  var i;\n  for (i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], true, argFrom);\n  }\n  for (i = pathTo.length; i-- > 0;) {\n    fn(pathTo[i], false, argTo);\n  }\n}\n\nmodule.exports = {\n  isAncestor: isAncestor,\n  getLowestCommonAncestor: getLowestCommonAncestor,\n  getParentInstance: getParentInstance,\n  traverseTwoPhase: traverseTwoPhase,\n  traverseEnterLeave: traverseEnterLeave\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react$lib$reactProdInvariant"]],"~:properties",["^5",["getLowestCommonAncestor","traverseTwoPhase","traverseEnterLeave","getParentInstance","isAncestor"]],"~:compiled-at",1635250628413,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactDOMTreeTraversal.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/ReactDOMTreeTraversal.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactDOMTreeTraversal\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2015-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule ReactDOMTreeTraversal\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Return the lowest common ancestor of A and B, or null if they are in\\n * different trees.\\n */\\nfunction getLowestCommonAncestor(instA, instB) {\\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\\n\\n  var depthA = 0;\\n  for (var tempA = instA; tempA; tempA = tempA._hostParent) {\\n    depthA++;\\n  }\\n  var depthB = 0;\\n  for (var tempB = instB; tempB; tempB = tempB._hostParent) {\\n    depthB++;\\n  }\\n\\n  // If A is deeper, crawl up.\\n  while (depthA - depthB > 0) {\\n    instA = instA._hostParent;\\n    depthA--;\\n  }\\n\\n  // If B is deeper, crawl up.\\n  while (depthB - depthA > 0) {\\n    instB = instB._hostParent;\\n    depthB--;\\n  }\\n\\n  // Walk in lockstep until we find a match.\\n  var depth = depthA;\\n  while (depth--) {\\n    if (instA === instB) {\\n      return instA;\\n    }\\n    instA = instA._hostParent;\\n    instB = instB._hostParent;\\n  }\\n  return null;\\n}\\n\\n/**\\n * Return if A is an ancestor of B.\\n */\\nfunction isAncestor(instA, instB) {\\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\\n\\n  while (instB) {\\n    if (instB === instA) {\\n      return true;\\n    }\\n    instB = instB._hostParent;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Return the parent instance of the passed-in instance.\\n */\\nfunction getParentInstance(inst) {\\n  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;\\n\\n  return inst._hostParent;\\n}\\n\\n/**\\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\\n */\\nfunction traverseTwoPhase(inst, fn, arg) {\\n  var path = [];\\n  while (inst) {\\n    path.push(inst);\\n    inst = inst._hostParent;\\n  }\\n  var i;\\n  for (i = path.length; i-- > 0;) {\\n    fn(path[i], false, arg);\\n  }\\n  for (i = 0; i < path.length; i++) {\\n    fn(path[i], true, arg);\\n  }\\n}\\n\\n/**\\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\\n * should would receive a `mouseEnter` or `mouseLeave` event.\\n *\\n * Does not invoke the callback on the nearest common ancestor because nothing\\n * \\\"entered\\\" or \\\"left\\\" that element.\\n */\\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\\n  var pathFrom = [];\\n  while (from && from !== common) {\\n    pathFrom.push(from);\\n    from = from._hostParent;\\n  }\\n  var pathTo = [];\\n  while (to && to !== common) {\\n    pathTo.push(to);\\n    to = to._hostParent;\\n  }\\n  var i;\\n  for (i = 0; i < pathFrom.length; i++) {\\n    fn(pathFrom[i], true, argFrom);\\n  }\\n  for (i = pathTo.length; i-- > 0;) {\\n    fn(pathTo[i], false, argTo);\\n  }\\n}\\n\\nmodule.exports = {\\n  isAncestor: isAncestor,\\n  getLowestCommonAncestor: getLowestCommonAncestor,\\n  getParentInstance: getParentInstance,\\n  traverseTwoPhase: traverseTwoPhase,\\n  traverseEnterLeave: traverseEnterLeave\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getLowestCommonAncestor\",\"instA\",\"instB\",\"invariant\",\"depthA\",\"tempA\",\"_hostParent\",\"depthB\",\"tempB\",\"depth\",\"isAncestor\",\"getParentInstance\",\"inst\",\"traverseTwoPhase\",\"fn\",\"arg\",\"path\",\"push\",\"i\",\"length\",\"traverseEnterLeave\",\"from\",\"to\",\"argFrom\",\"argTo\",\"common\",\"pathFrom\",\"pathTo\"]\n}\n"]