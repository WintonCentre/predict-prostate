["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactReconciler.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactReconciler=function(global,process,require,module,exports,shadow$shims){function attachRefs(){ReactRef.attachRefs(this,this._currentElement)}var ReactRef=require(\"module$node_modules$react_dom$lib$ReactRef\"),ReactInstrumentation=require(\"module$node_modules$react_dom$lib$ReactInstrumentation\"),warning=require(\"module$node_modules$fbjs$lib$warning\");module.exports={mountComponent:function(internalInstance,transaction,hostParent,hostContainerInfo,\ncontext,parentDebugID){if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID,internalInstance._currentElement,parentDebugID);hostParent=internalInstance.mountComponent(transaction,hostParent,hostContainerInfo,context,parentDebugID);internalInstance._currentElement&&null!=internalInstance._currentElement.ref&&transaction.getReactMountReady().enqueue(attachRefs,internalInstance);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);\nreturn hostParent},getHostNode:function(internalInstance){return internalInstance.getHostNode()},unmountComponent:function(internalInstance,safely){if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);ReactRef.detachRefs(internalInstance,internalInstance._currentElement);internalInstance.unmountComponent(safely);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID)},receiveComponent:function(internalInstance,\nnextElement,transaction,context){var prevElement=internalInstance._currentElement;if(nextElement!==prevElement||context!==internalInstance._context){if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID,nextElement);var refsChanged=ReactRef.shouldUpdateRefs(prevElement,nextElement);refsChanged&&ReactRef.detachRefs(internalInstance,prevElement);internalInstance.receiveComponent(nextElement,transaction,context);refsChanged&&internalInstance._currentElement&&\nnull!=internalInstance._currentElement.ref&&transaction.getReactMountReady().enqueue(attachRefs,internalInstance);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID)}},performUpdateIfNecessary:function(internalInstance,transaction,updateBatchNumber){if(internalInstance._updateBatchNumber!==updateBatchNumber)warning(null==internalInstance._updateBatchNumber||internalInstance._updateBatchNumber===updateBatchNumber+1,\"performUpdateIfNecessary: Unexpected batch number (current %s, pending %s)\",\nupdateBatchNumber,internalInstance._updateBatchNumber);else{if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID,internalInstance._currentElement);internalInstance.performUpdateIfNecessary(transaction);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID)}}}}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactReconciler\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar ReactRef = require('./ReactRef');\nvar ReactInstrumentation = require('./ReactInstrumentation');\n\nvar warning = require('fbjs/lib/warning');\n\n/**\n * Helper to call ReactRef.attachRefs with this composite component, split out\n * to avoid allocations in the transaction mount-ready queue.\n */\nfunction attachRefs() {\n  ReactRef.attachRefs(this, this._currentElement);\n}\n\nvar ReactReconciler = {\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?object} the containing host component instance\n   * @param {?object} info about the host container\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots\n  ) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);\n      }\n    }\n    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);\n    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);\n      }\n    }\n    return markup;\n  },\n\n  /**\n   * Returns a value that can be passed to\n   * ReactComponentEnvironment.replaceNodeWithMarkup.\n   */\n  getHostNode: function (internalInstance) {\n    return internalInstance.getHostNode();\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function (internalInstance, safely) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);\n      }\n    }\n    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);\n    internalInstance.unmountComponent(safely);\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);\n      }\n    }\n  },\n\n  /**\n   * Update a component using a new element.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactElement} nextElement\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @internal\n   */\n  receiveComponent: function (internalInstance, nextElement, transaction, context) {\n    var prevElement = internalInstance._currentElement;\n\n    if (nextElement === prevElement && context === internalInstance._context) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for an element created outside a composite to be\n      // deeply mutated and reused.\n\n      // TODO: Bailing out early is just a perf optimization right?\n      // TODO: Removing the return statement should affect correctness?\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);\n      }\n    }\n\n    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);\n\n    if (refsChanged) {\n      ReactRef.detachRefs(internalInstance, prevElement);\n    }\n\n    internalInstance.receiveComponent(nextElement, transaction, context);\n\n    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\n      }\n    }\n  },\n\n  /**\n   * Flush any dirty changes in a component.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {\n    if (internalInstance._updateBatchNumber !== updateBatchNumber) {\n      // The component's enqueued batch number should always be the current\n      // batch or the following one.\n      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);\n      }\n    }\n    internalInstance.performUpdateIfNecessary(transaction);\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\n      }\n    }\n  }\n\n};\n\nmodule.exports = ReactReconciler;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_dom$lib$ReactInstrumentation","~$shadow.js","~$module$node_modules$react_dom$lib$ReactRef","~$module$node_modules$fbjs$lib$warning"]],"~:properties",["^5",["getHostNode","mountComponent","receiveComponent","performUpdateIfNecessary","unmountComponent"]],"~:compiled-at",1635270336823,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactReconciler.js\",\n\"lineCount\":6,\n\"mappings\":\"AAAAA,cAAA,kDAAA,CAAsE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAsBnIC,QAASA,WAAU,EAAG,CACpBC,QAAAD,WAAA,CAAoB,IAApB,CAA0B,IAAAE,gBAA1B,CADoB,CATtB,IAAID,SAAWL,OAAA,CAAQ,4CAAR,CAAf,CACIO,qBAAuBP,OAAA,CAAQ,wDAAR,CAD3B,CAGIQ,QAAUR,OAAA,CAAQ,sCAAR,CAuJdC,OAAAC,QAAA,CA7IsBO,CAapBC,eAAgBA,QAAS,CAACC,gBAAD,CAAmBC,WAAnB,CAAgCC,UAAhC,CAA4CC,iBAA5C;AAA+DC,OAA/D,CAAwEC,aAAxE,CACvB,CAEE,GAAkC,CAAlC,GAAIL,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAC,uBAAA,CAAsDR,gBAAAM,SAAtD,CAAiFN,gBAAAL,gBAAjF,CAAmHU,aAAnH,CAGAI,WAAAA,CAAST,gBAAAD,eAAA,CAAgCE,WAAhC,CAA6CC,UAA7C,CAAyDC,iBAAzD,CAA4EC,OAA5E,CAAqFC,aAArF,CACTL,iBAAAL,gBAAJ,EAAgF,IAAhF,EAAwCK,gBAAAL,gBAAAe,IAAxC,EACET,WAAAU,mBAAA,EAAAC,QAAA,CAAyCnB,UAAzC,CAAqDO,gBAArD,CAGA,IAAkC,CAAlC,GAAIA,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAM,iBAAA,CAAgDb,gBAAAM,SAAhD,CAGJ;MAAOG,WAfP,CAdkBX,CAoCpBgB,YAAaA,QAAS,CAACd,gBAAD,CAAmB,CACvC,MAAOA,iBAAAc,YAAA,EADgC,CApCrBhB,CA8CpBiB,iBAAkBA,QAAS,CAACf,gBAAD,CAAmBgB,MAAnB,CAA2B,CAElD,GAAkC,CAAlC,GAAIhB,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAU,yBAAA,CAAwDjB,gBAAAM,SAAxD,CAGJZ,SAAAwB,WAAA,CAAoBlB,gBAApB,CAAsCA,gBAAAL,gBAAtC,CACAK,iBAAAe,iBAAA,CAAkCC,MAAlC,CAEE,IAAkC,CAAlC,GAAIhB,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAY,mBAAA,CAAkDnB,gBAAAM,SAAlD,CAVgD,CA9ClCR,CAsEpBsB,iBAAkBA,QAAS,CAACpB,gBAAD;AAAmBqB,WAAnB,CAAgCpB,WAAhC,CAA6CG,OAA7C,CAAsD,CAC/E,IAAIkB,YAActB,gBAAAL,gBAElB,IAAI0B,WAAJ,GAAoBC,WAApB,EAAmClB,OAAnC,GAA+CJ,gBAAAuB,SAA/C,CAAA,CAeE,GAAkC,CAAlC,GAAIvB,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAiB,wBAAA,CAAuDxB,gBAAAM,SAAvD,CAAkFe,WAAlF,CAIJ,KAAII,YAAc/B,QAAAgC,iBAAA,CAA0BJ,WAA1B,CAAuCD,WAAvC,CAEdI,YAAJ,EACE/B,QAAAwB,WAAA,CAAoBlB,gBAApB,CAAsCsB,WAAtC,CAGFtB,iBAAAoB,iBAAA,CAAkCC,WAAlC,CAA+CpB,WAA/C,CAA4DG,OAA5D,CAEIqB,YAAJ,EAAmBzB,gBAAAL,gBAAnB;AAA+F,IAA/F,EAAuDK,gBAAAL,gBAAAe,IAAvD,EACET,WAAAU,mBAAA,EAAAC,QAAA,CAAyCnB,UAAzC,CAAqDO,gBAArD,CAIA,IAAkC,CAAlC,GAAIA,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAoB,kBAAA,CAAiD3B,gBAAAM,SAAjD,CAlCJ,CAH+E,CAtE7DR,CAuHpB8B,yBAA0BA,QAAS,CAAC5B,gBAAD,CAAmBC,WAAnB,CAAgC4B,iBAAhC,CAAmD,CACpF,GAAI7B,gBAAA8B,mBAAJ,GAA4CD,iBAA5C,CAG0ChC,OAAA,CAA+C,IAA/C,EAAQG,gBAAA8B,mBAAR,EAAuD9B,gBAAA8B,mBAAvD,GAA+FD,iBAA/F,CAAmH,CAAnH,CAAsH,4EAAtH;AAAyMA,iBAAzM,CAA4N7B,gBAAA8B,mBAA5N,CAH1C,KAAA,CAOE,GAAkC,CAAlC,GAAI9B,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAiB,wBAAA,CAAuDxB,gBAAAM,SAAvD,CAAkFN,gBAAAL,gBAAlF,CAGJK,iBAAA4B,yBAAA,CAA0C3B,WAA1C,CAEE,IAAkC,CAAlC,GAAID,gBAAAM,SAAJ,CACEV,oBAAAW,UAAAoB,kBAAA,CAAiD3B,gBAAAM,SAAjD,CAdJ,CADoF,CAvHlER,CA1B6G;\",\n\"sources\":[\"node_modules/react-dom/lib/ReactReconciler.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactReconciler\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar ReactRef = require('./ReactRef');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\n\\nvar warning = require('fbjs/lib/warning');\\n\\n/**\\n * Helper to call ReactRef.attachRefs with this composite component, split out\\n * to avoid allocations in the transaction mount-ready queue.\\n */\\nfunction attachRefs() {\\n  ReactRef.attachRefs(this, this._currentElement);\\n}\\n\\nvar ReactReconciler = {\\n\\n  /**\\n   * Initializes the component, renders markup, and registers event listeners.\\n   *\\n   * @param {ReactComponent} internalInstance\\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\\n   * @param {?object} the containing host component instance\\n   * @param {?object} info about the host container\\n   * @return {?string} Rendered markup to be inserted into the DOM.\\n   * @final\\n   * @internal\\n   */\\n  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots\\n  ) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);\\n      }\\n    }\\n    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);\\n    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {\\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\\n    }\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);\\n      }\\n    }\\n    return markup;\\n  },\\n\\n  /**\\n   * Returns a value that can be passed to\\n   * ReactComponentEnvironment.replaceNodeWithMarkup.\\n   */\\n  getHostNode: function (internalInstance) {\\n    return internalInstance.getHostNode();\\n  },\\n\\n  /**\\n   * Releases any resources allocated by `mountComponent`.\\n   *\\n   * @final\\n   * @internal\\n   */\\n  unmountComponent: function (internalInstance, safely) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);\\n      }\\n    }\\n    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);\\n    internalInstance.unmountComponent(safely);\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Update a component using a new element.\\n   *\\n   * @param {ReactComponent} internalInstance\\n   * @param {ReactElement} nextElement\\n   * @param {ReactReconcileTransaction} transaction\\n   * @param {object} context\\n   * @internal\\n   */\\n  receiveComponent: function (internalInstance, nextElement, transaction, context) {\\n    var prevElement = internalInstance._currentElement;\\n\\n    if (nextElement === prevElement && context === internalInstance._context) {\\n      // Since elements are immutable after the owner is rendered,\\n      // we can do a cheap identity compare here to determine if this is a\\n      // superfluous reconcile. It's possible for state to be mutable but such\\n      // change should trigger an update of the owner which would recreate\\n      // the element. We explicitly check for the existence of an owner since\\n      // it's possible for an element created outside a composite to be\\n      // deeply mutated and reused.\\n\\n      // TODO: Bailing out early is just a perf optimization right?\\n      // TODO: Removing the return statement should affect correctness?\\n      return;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);\\n      }\\n    }\\n\\n    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);\\n\\n    if (refsChanged) {\\n      ReactRef.detachRefs(internalInstance, prevElement);\\n    }\\n\\n    internalInstance.receiveComponent(nextElement, transaction, context);\\n\\n    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {\\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Flush any dirty changes in a component.\\n   *\\n   * @param {ReactComponent} internalInstance\\n   * @param {ReactReconcileTransaction} transaction\\n   * @internal\\n   */\\n  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {\\n    if (internalInstance._updateBatchNumber !== updateBatchNumber) {\\n      // The component's enqueued batch number should always be the current\\n      // batch or the following one.\\n      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;\\n      return;\\n    }\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);\\n      }\\n    }\\n    internalInstance.performUpdateIfNecessary(transaction);\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\\n      }\\n    }\\n  }\\n\\n};\\n\\nmodule.exports = ReactReconciler;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"attachRefs\",\"ReactRef\",\"_currentElement\",\"ReactInstrumentation\",\"warning\",\"ReactReconciler\",\"mountComponent\",\"internalInstance\",\"transaction\",\"hostParent\",\"hostContainerInfo\",\"context\",\"parentDebugID\",\"_debugID\",\"debugTool\",\"onBeforeMountComponent\",\"markup\",\"ref\",\"getReactMountReady\",\"enqueue\",\"onMountComponent\",\"getHostNode\",\"unmountComponent\",\"safely\",\"onBeforeUnmountComponent\",\"detachRefs\",\"onUnmountComponent\",\"receiveComponent\",\"nextElement\",\"prevElement\",\"_context\",\"onBeforeUpdateComponent\",\"refsChanged\",\"shouldUpdateRefs\",\"onUpdateComponent\",\"performUpdateIfNecessary\",\"updateBatchNumber\",\"_updateBatchNumber\"]\n}\n"]