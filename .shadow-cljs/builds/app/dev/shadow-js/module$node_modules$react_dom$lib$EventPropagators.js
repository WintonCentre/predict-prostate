["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/EventPropagators.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$EventPropagators=function(global,process,require,module,exports,shadow$shims){function accumulateDirectionalDispatches(inst,phase,event){warning(inst,\"Dispatching inst must not be null\");if(phase=getListener(inst,event.dispatchConfig.phasedRegistrationNames[phase]))event._dispatchListeners=accumulateInto(event._dispatchListeners,phase),event._dispatchInstances=accumulateInto(event._dispatchInstances,inst)}function accumulateTwoPhaseDispatchesSingle(event){event&&\nevent.dispatchConfig.phasedRegistrationNames&&EventPluginUtils.traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event)}function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;targetInst=targetInst?EventPluginUtils.getParentInstance(targetInst):null;EventPluginUtils.traverseTwoPhase(targetInst,accumulateDirectionalDispatches,event)}}function accumulateDispatches(inst,ignoredDirection,event){event&&\nevent.dispatchConfig.registrationName&&(ignoredDirection=getListener(inst,event.dispatchConfig.registrationName))&&(event._dispatchListeners=accumulateInto(event._dispatchListeners,ignoredDirection),event._dispatchInstances=accumulateInto(event._dispatchInstances,inst))}function accumulateDirectDispatchesSingle(event){event&&event.dispatchConfig.registrationName&&accumulateDispatches(event._targetInst,null,event)}global=require(\"module$node_modules$react_dom$lib$EventPluginHub\");var EventPluginUtils=\nrequire(\"module$node_modules$react_dom$lib$EventPluginUtils\"),accumulateInto=require(\"module$node_modules$react_dom$lib$accumulateInto\"),forEachAccumulated=require(\"module$node_modules$react_dom$lib$forEachAccumulated\"),warning=require(\"module$node_modules$fbjs$lib$warning\"),getListener=global.getListener;module.exports={accumulateTwoPhaseDispatches:function(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle)},accumulateTwoPhaseDispatchesSkipTarget:function(events){forEachAccumulated(events,\naccumulateTwoPhaseDispatchesSingleSkipTarget)},accumulateDirectDispatches:function(events){forEachAccumulated(events,accumulateDirectDispatchesSingle)},accumulateEnterLeaveDispatches:function(leave,enter,from,to){EventPluginUtils.traverseEnterLeave(from,to,accumulateDispatches,leave,enter)}}}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$EventPropagators\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPluginUtils = require('./EventPluginUtils');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\nvar warning = require('fbjs/lib/warning');\n\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$react_dom$lib$EventPluginUtils","~$module$node_modules$react_dom$lib$EventPluginHub","~$module$node_modules$react_dom$lib$forEachAccumulated","~$module$node_modules$fbjs$lib$warning","~$module$node_modules$react_dom$lib$accumulateInto"]],"~:properties",["^5",["_dispatchListeners","accumulateDirectDispatches","accumulateTwoPhaseDispatches","accumulateEnterLeaveDispatches","accumulateTwoPhaseDispatchesSkipTarget","_dispatchInstances"]],"~:compiled-at",1635270336810,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$EventPropagators.js\",\n\"lineCount\":5,\n\"mappings\":\"AAAAA,cAAA,mDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAqCpIC,QAASA,gCAA+B,CAACC,IAAD,CAAOC,KAAP,CAAcC,KAAd,CAAqB,CAEjBC,OAAA,CAAQH,IAAR,CAAc,mCAAd,CAG1C,IAdA,KAcA,CAdOI,WAAA,CAawBJ,IAbxB,CAa8BE,KAddG,eAAAC,wBAAAC,CAcqBN,KAdrBM,CAChB,CAcP,CACEL,KAAAM,mBACA,CAD2BC,cAAA,CAAeP,KAAAM,mBAAf,CAAyCE,KAAzC,CAC3B,CAAAR,KAAAS,mBAAA,CAA2BF,cAAA,CAAeP,KAAAS,mBAAf,CAAyCX,IAAzC,CAP8B,CAkB7DY,QAASA,mCAAkC,CAACV,KAAD,CAAQ,CAC7CA,KAAJ;AAAaA,KAAAG,eAAAC,wBAAb,EACEO,gBAAAC,iBAAA,CAAkCZ,KAAAa,YAAlC,CAAqDhB,+BAArD,CAAsFG,KAAtF,CAF+C,CASnDc,QAASA,6CAA4C,CAACd,KAAD,CAAQ,CAC3D,GAAIA,KAAJ,EAAaA,KAAAG,eAAAC,wBAAb,CAA2D,CACzD,IAAIW,WAAaf,KAAAa,YACbG,WAAAA,CAAaD,UAAA,CAAaJ,gBAAAM,kBAAA,CAAmCF,UAAnC,CAAb,CAA8D,IAC/EJ,iBAAAC,iBAAA,CAAkCI,UAAlC,CAA8CnB,+BAA9C,CAA+EG,KAA/E,CAHyD,CADA,CAa7DkB,QAASA,qBAAoB,CAACpB,IAAD,CAAOqB,gBAAP,CAAyBnB,KAAzB,CAAgC,CACvDA,KAAJ;AAAaA,KAAAG,eAAAE,iBAAb,GAEMG,gBAFN,CAEiBN,WAAA,CAAYJ,IAAZ,CADQE,KAAAG,eAAAE,iBACR,CAFjB,IAIIL,KAAAM,mBACA,CAD2BC,cAAA,CAAeP,KAAAM,mBAAf,CAAyCE,gBAAzC,CAC3B,CAAAR,KAAAS,mBAAA,CAA2BF,cAAA,CAAeP,KAAAS,mBAAf,CAAyCX,IAAzC,CAL/B,CAD2D,CAgB7DsB,QAASA,iCAAgC,CAACpB,KAAD,CAAQ,CAC3CA,KAAJ,EAAaA,KAAAG,eAAAE,iBAAb,EACEa,oBAAA,CAAqBlB,KAAAa,YAArB,CAAwC,IAAxC,CAA8Cb,KAA9C,CAF6C,CAhF7CqB,MAAAA,CAAiB5B,OAAA,CAAQ,kDAAR,CACrB,KAAIkB;AAAmBlB,OAAA,CAAQ,oDAAR,CAAvB,CAEIc,eAAiBd,OAAA,CAAQ,kDAAR,CAFrB,CAGI6B,mBAAqB7B,OAAA,CAAQ,sDAAR,CAHzB,CAIIQ,QAAUR,OAAA,CAAQ,sCAAR,CAJd,CAMIS,YAAcmB,MAAAnB,YAiHlBR,OAAAC,QAAA,CAPuB4B,CACrBC,6BA5BFA,QAAqC,CAACC,MAAD,CAAS,CAC5CH,kBAAA,CAAmBG,MAAnB,CAA2Bf,kCAA3B,CAD4C,CA2BvBa,CAErBG,uCAzBFA,QAA+C,CAACD,MAAD,CAAS,CACtDH,kBAAA,CAAmBG,MAAnB;AAA2BX,4CAA3B,CADsD,CAuBjCS,CAGrBI,2BAlBFA,QAAmC,CAACF,MAAD,CAAS,CAC1CH,kBAAA,CAAmBG,MAAnB,CAA2BL,gCAA3B,CAD0C,CAerBG,CAIrBK,+BAvBFA,QAAuC,CAACC,KAAD,CAAQC,KAAR,CAAeC,IAAf,CAAqBC,EAArB,CAAyB,CAC9DrB,gBAAAsB,mBAAA,CAAoCF,IAApC,CAA0CC,EAA1C,CAA8Cd,oBAA9C,CAAoEW,KAApE,CAA2EC,KAA3E,CAD8D,CAmBzCP,CA9H6G;\",\n\"sources\":[\"node_modules/react-dom/lib/EventPropagators.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$EventPropagators\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar EventPluginHub = require('./EventPluginHub');\\nvar EventPluginUtils = require('./EventPluginUtils');\\n\\nvar accumulateInto = require('./accumulateInto');\\nvar forEachAccumulated = require('./forEachAccumulated');\\nvar warning = require('fbjs/lib/warning');\\n\\nvar getListener = EventPluginHub.getListener;\\n\\n/**\\n * Some event types have a notion of different registration names for different\\n * \\\"phases\\\" of propagation. This finds listeners by a given phase.\\n */\\nfunction listenerAtPhase(inst, event, propagationPhase) {\\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\\n  return getListener(inst, registrationName);\\n}\\n\\n/**\\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\\n * here, allows us to not have to bind or create functions for each event.\\n * Mutating the event's members allows us to not have to create a wrapping\\n * \\\"dispatch\\\" object that pairs the event with the listener.\\n */\\nfunction accumulateDirectionalDispatches(inst, phase, event) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\\n  }\\n  var listener = listenerAtPhase(inst, event, phase);\\n  if (listener) {\\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\\n  }\\n}\\n\\n/**\\n * Collect dispatches (must be entirely collected before dispatching - see unit\\n * tests). Lazily allocate the array to conserve memory.  We must loop through\\n * each event and perform the traversal for each one. We cannot perform a\\n * single traversal for the entire collection of events because each event may\\n * have a different target.\\n */\\nfunction accumulateTwoPhaseDispatchesSingle(event) {\\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\\n  }\\n}\\n\\n/**\\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\\n */\\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\\n    var targetInst = event._targetInst;\\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\\n  }\\n}\\n\\n/**\\n * Accumulates without regard to direction, does not look for phased\\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\\n */\\nfunction accumulateDispatches(inst, ignoredDirection, event) {\\n  if (event && event.dispatchConfig.registrationName) {\\n    var registrationName = event.dispatchConfig.registrationName;\\n    var listener = getListener(inst, registrationName);\\n    if (listener) {\\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\\n    }\\n  }\\n}\\n\\n/**\\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\\n * `dispatchMarker`.\\n * @param {SyntheticEvent} event\\n */\\nfunction accumulateDirectDispatchesSingle(event) {\\n  if (event && event.dispatchConfig.registrationName) {\\n    accumulateDispatches(event._targetInst, null, event);\\n  }\\n}\\n\\nfunction accumulateTwoPhaseDispatches(events) {\\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\\n}\\n\\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\\n}\\n\\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\\n}\\n\\nfunction accumulateDirectDispatches(events) {\\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\\n}\\n\\n/**\\n * A small set of propagation patterns, each of which will accept a small amount\\n * of information, and generate a set of \\\"dispatch ready event objects\\\" - which\\n * are sets of events that have already been annotated with a set of dispatched\\n * listener functions/ids. The API is designed this way to discourage these\\n * propagation strategies from actually executing the dispatches, since we\\n * always want to collect the entire set of dispatches before executing event a\\n * single one.\\n *\\n * @constructor EventPropagators\\n */\\nvar EventPropagators = {\\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\\n  accumulateDirectDispatches: accumulateDirectDispatches,\\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\\n};\\n\\nmodule.exports = EventPropagators;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"accumulateDirectionalDispatches\",\"inst\",\"phase\",\"event\",\"warning\",\"getListener\",\"dispatchConfig\",\"phasedRegistrationNames\",\"registrationName\",\"_dispatchListeners\",\"accumulateInto\",\"listener\",\"_dispatchInstances\",\"accumulateTwoPhaseDispatchesSingle\",\"EventPluginUtils\",\"traverseTwoPhase\",\"_targetInst\",\"accumulateTwoPhaseDispatchesSingleSkipTarget\",\"targetInst\",\"parentInst\",\"getParentInstance\",\"accumulateDispatches\",\"ignoredDirection\",\"accumulateDirectDispatchesSingle\",\"EventPluginHub\",\"forEachAccumulated\",\"EventPropagators\",\"accumulateTwoPhaseDispatches\",\"events\",\"accumulateTwoPhaseDispatchesSkipTarget\",\"accumulateDirectDispatches\",\"accumulateEnterLeaveDispatches\",\"leave\",\"enter\",\"from\",\"to\",\"traverseEnterLeave\"]\n}\n"]