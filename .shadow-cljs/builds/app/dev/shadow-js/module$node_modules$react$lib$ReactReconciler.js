["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactReconciler.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactReconciler=function(global,require,module,exports){function attachRefs(){ReactRef.attachRefs(this,this._currentElement)}var ReactRef=require(\"module$node_modules$react$lib$ReactRef\"),ReactInstrumentation=require(\"module$node_modules$react$lib$ReactInstrumentation\"),warning=require(\"module$node_modules$fbjs$lib$warning\");module.exports={mountComponent:function(internalInstance,transaction,hostParent,hostContainerInfo,context,parentDebugID){if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID,\ninternalInstance._currentElement,parentDebugID);hostParent=internalInstance.mountComponent(transaction,hostParent,hostContainerInfo,context,parentDebugID);internalInstance._currentElement&&null!=internalInstance._currentElement.ref&&transaction.getReactMountReady().enqueue(attachRefs,internalInstance);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);return hostParent},getHostNode:function(internalInstance){return internalInstance.getHostNode()},\nunmountComponent:function(internalInstance,safely){if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);ReactRef.detachRefs(internalInstance,internalInstance._currentElement);internalInstance.unmountComponent(safely);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID)},receiveComponent:function(internalInstance,nextElement,transaction,context){var prevElement=internalInstance._currentElement;\nif(nextElement!==prevElement||context!==internalInstance._context){if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID,nextElement);var refsChanged=ReactRef.shouldUpdateRefs(prevElement,nextElement);refsChanged&&ReactRef.detachRefs(internalInstance,prevElement);internalInstance.receiveComponent(nextElement,transaction,context);refsChanged&&internalInstance._currentElement&&null!=internalInstance._currentElement.ref&&transaction.getReactMountReady().enqueue(attachRefs,\ninternalInstance);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID)}},performUpdateIfNecessary:function(internalInstance,transaction,updateBatchNumber){if(internalInstance._updateBatchNumber!==updateBatchNumber)warning(null==internalInstance._updateBatchNumber||internalInstance._updateBatchNumber===updateBatchNumber+1,\"performUpdateIfNecessary: Unexpected batch number (current %s, pending %s)\",updateBatchNumber,internalInstance._updateBatchNumber);\nelse{if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID,internalInstance._currentElement);internalInstance.performUpdateIfNecessary(transaction);if(0!==internalInstance._debugID)ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID)}}}}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactReconciler\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactReconciler\n */\n\n'use strict';\n\nvar ReactRef = require('./ReactRef');\nvar ReactInstrumentation = require('./ReactInstrumentation');\n\nvar warning = require('fbjs/lib/warning');\n\n/**\n * Helper to call ReactRef.attachRefs with this composite component, split out\n * to avoid allocations in the transaction mount-ready queue.\n */\nfunction attachRefs() {\n  ReactRef.attachRefs(this, this._currentElement);\n}\n\nvar ReactReconciler = {\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?object} the containing host component instance\n   * @param {?object} info about the host container\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots\n  ) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);\n      }\n    }\n    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);\n    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);\n      }\n    }\n    return markup;\n  },\n\n  /**\n   * Returns a value that can be passed to\n   * ReactComponentEnvironment.replaceNodeWithMarkup.\n   */\n  getHostNode: function (internalInstance) {\n    return internalInstance.getHostNode();\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function (internalInstance, safely) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);\n      }\n    }\n    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);\n    internalInstance.unmountComponent(safely);\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);\n      }\n    }\n  },\n\n  /**\n   * Update a component using a new element.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactElement} nextElement\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @internal\n   */\n  receiveComponent: function (internalInstance, nextElement, transaction, context) {\n    var prevElement = internalInstance._currentElement;\n\n    if (nextElement === prevElement && context === internalInstance._context) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for an element created outside a composite to be\n      // deeply mutated and reused.\n\n      // TODO: Bailing out early is just a perf optimization right?\n      // TODO: Removing the return statement should affect correctness?\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);\n      }\n    }\n\n    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);\n\n    if (refsChanged) {\n      ReactRef.detachRefs(internalInstance, prevElement);\n    }\n\n    internalInstance.receiveComponent(nextElement, transaction, context);\n\n    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\n      }\n    }\n  },\n\n  /**\n   * Flush any dirty changes in a component.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {\n    if (internalInstance._updateBatchNumber !== updateBatchNumber) {\n      // The component's enqueued batch number should always be the current\n      // batch or the following one.\n      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);\n      }\n    }\n    internalInstance.performUpdateIfNecessary(transaction);\n    if (process.env.NODE_ENV !== 'production') {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\n      }\n    }\n  }\n\n};\n\nmodule.exports = ReactReconciler;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$react$lib$ReactRef","~$module$node_modules$react$lib$ReactInstrumentation","~$module$node_modules$fbjs$lib$warning"]],"~:properties",["^5",["getHostNode","mountComponent","receiveComponent","performUpdateIfNecessary","unmountComponent"]],"~:compiled-at",1635250628388,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactReconciler.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/ReactReconciler.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactReconciler\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule ReactReconciler\\n */\\n\\n'use strict';\\n\\nvar ReactRef = require('./ReactRef');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\n\\nvar warning = require('fbjs/lib/warning');\\n\\n/**\\n * Helper to call ReactRef.attachRefs with this composite component, split out\\n * to avoid allocations in the transaction mount-ready queue.\\n */\\nfunction attachRefs() {\\n  ReactRef.attachRefs(this, this._currentElement);\\n}\\n\\nvar ReactReconciler = {\\n\\n  /**\\n   * Initializes the component, renders markup, and registers event listeners.\\n   *\\n   * @param {ReactComponent} internalInstance\\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\\n   * @param {?object} the containing host component instance\\n   * @param {?object} info about the host container\\n   * @return {?string} Rendered markup to be inserted into the DOM.\\n   * @final\\n   * @internal\\n   */\\n  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots\\n  ) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);\\n      }\\n    }\\n    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);\\n    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {\\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\\n    }\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);\\n      }\\n    }\\n    return markup;\\n  },\\n\\n  /**\\n   * Returns a value that can be passed to\\n   * ReactComponentEnvironment.replaceNodeWithMarkup.\\n   */\\n  getHostNode: function (internalInstance) {\\n    return internalInstance.getHostNode();\\n  },\\n\\n  /**\\n   * Releases any resources allocated by `mountComponent`.\\n   *\\n   * @final\\n   * @internal\\n   */\\n  unmountComponent: function (internalInstance, safely) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);\\n      }\\n    }\\n    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);\\n    internalInstance.unmountComponent(safely);\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Update a component using a new element.\\n   *\\n   * @param {ReactComponent} internalInstance\\n   * @param {ReactElement} nextElement\\n   * @param {ReactReconcileTransaction} transaction\\n   * @param {object} context\\n   * @internal\\n   */\\n  receiveComponent: function (internalInstance, nextElement, transaction, context) {\\n    var prevElement = internalInstance._currentElement;\\n\\n    if (nextElement === prevElement && context === internalInstance._context) {\\n      // Since elements are immutable after the owner is rendered,\\n      // we can do a cheap identity compare here to determine if this is a\\n      // superfluous reconcile. It's possible for state to be mutable but such\\n      // change should trigger an update of the owner which would recreate\\n      // the element. We explicitly check for the existence of an owner since\\n      // it's possible for an element created outside a composite to be\\n      // deeply mutated and reused.\\n\\n      // TODO: Bailing out early is just a perf optimization right?\\n      // TODO: Removing the return statement should affect correctness?\\n      return;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);\\n      }\\n    }\\n\\n    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);\\n\\n    if (refsChanged) {\\n      ReactRef.detachRefs(internalInstance, prevElement);\\n    }\\n\\n    internalInstance.receiveComponent(nextElement, transaction, context);\\n\\n    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {\\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Flush any dirty changes in a component.\\n   *\\n   * @param {ReactComponent} internalInstance\\n   * @param {ReactReconcileTransaction} transaction\\n   * @internal\\n   */\\n  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {\\n    if (internalInstance._updateBatchNumber !== updateBatchNumber) {\\n      // The component's enqueued batch number should always be the current\\n      // batch or the following one.\\n      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;\\n      return;\\n    }\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);\\n      }\\n    }\\n    internalInstance.performUpdateIfNecessary(transaction);\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (internalInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);\\n      }\\n    }\\n  }\\n\\n};\\n\\nmodule.exports = ReactReconciler;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"attachRefs\",\"ReactRef\",\"_currentElement\",\"ReactInstrumentation\",\"warning\",\"ReactReconciler\",\"mountComponent\",\"internalInstance\",\"transaction\",\"hostParent\",\"hostContainerInfo\",\"context\",\"parentDebugID\",\"_debugID\",\"debugTool\",\"onBeforeMountComponent\",\"markup\",\"ref\",\"getReactMountReady\",\"enqueue\",\"onMountComponent\",\"getHostNode\",\"unmountComponent\",\"safely\",\"onBeforeUnmountComponent\",\"detachRefs\",\"onUnmountComponent\",\"receiveComponent\",\"nextElement\",\"prevElement\",\"_context\",\"onBeforeUpdateComponent\",\"refsChanged\",\"shouldUpdateRefs\",\"onUpdateComponent\",\"performUpdateIfNecessary\",\"updateBatchNumber\",\"_updateBatchNumber\"]\n}\n"]