["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactCompositeComponent.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactCompositeComponent=function(global,process,require,module,exports,shadow$shims){function StatelessComponent(Component){}function warnIfInvalidElement(Component,element){warning(null===element||!1===element||React.isValidElement(element),\"%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.\",Component.displayName||Component.name||\"Component\");warning(!Component.childContextTypes,\n\"%s(...): childContextTypes cannot be defined on a functional component.\",Component.displayName||Component.name||\"Component\")}function measureLifeCyclePerf(fn,debugID,timerType){if(0===debugID)return fn();ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID,timerType);try{return fn()}finally{ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID,timerType)}}require(\"module$node_modules$react_dom$lib$reactProdInvariant\");var _assign=require(\"module$node_modules$object_assign$index\"),React=\nrequire(\"module$node_modules$react$lib$React\"),ReactComponentEnvironment=require(\"module$node_modules$react_dom$lib$ReactComponentEnvironment\"),ReactCurrentOwner=require(\"module$node_modules$react$lib$ReactCurrentOwner\"),ReactErrorUtils=require(\"module$node_modules$react_dom$lib$ReactErrorUtils\"),ReactInstanceMap=require(\"module$node_modules$react_dom$lib$ReactInstanceMap\"),ReactInstrumentation=require(\"module$node_modules$react_dom$lib$ReactInstrumentation\"),ReactNodeTypes=require(\"module$node_modules$react_dom$lib$ReactNodeTypes\"),\nReactReconciler=require(\"module$node_modules$react_dom$lib$ReactReconciler\"),checkReactTypeSpec=require(\"module$node_modules$react_dom$lib$checkReactTypeSpec\"),emptyObject=require(\"module$node_modules$fbjs$lib$emptyObject\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),shallowEqual=require(\"module$node_modules$fbjs$lib$shallowEqual\"),shouldUpdateReactComponent=require(\"module$node_modules$react_dom$lib$shouldUpdateReactComponent\"),warning=require(\"module$node_modules$fbjs$lib$warning\");\nStatelessComponent.prototype.render=function(){var Component=ReactInstanceMap.get(this)._currentElement.type,element=Component(this.props,this.context,this.updater);warnIfInvalidElement(Component,element);return element};var nextMountID=1;module.exports={construct:function(element){this._currentElement=element;this._rootNodeID=0;this._pendingStateQueue=this._pendingElement=this._updateBatchNumber=this._hostContainerInfo=this._hostParent=this._instance=this._compositeType=null;this._pendingForceUpdate=\nthis._pendingReplaceState=!1;this._context=this._renderedComponent=this._renderedNodeType=null;this._mountOrder=0;this._pendingCallbacks=this._topLevelWrapper=null;this._warnedAboutRefsInRender=this._calledComponentWillUnmount=!1},mountComponent:function(transaction,hostParent,hostContainerInfo,context){var _this=this;this._context=context;this._mountOrder=nextMountID++;this._hostParent=hostParent;this._hostContainerInfo=hostContainerInfo;var publicProps=this._currentElement.props,publicContext=this._processContext(context),\nComponent=this._currentElement.type,updateQueue=transaction.getUpdateQueue(),doConstruct=!(!Component.prototype||!Component.prototype.isReactComponent),inst=this._constructComponent(doConstruct,publicProps,publicContext,updateQueue);if(doConstruct||null!=inst&&null!=inst.render)this._compositeType=Component.prototype&&Component.prototype.isPureReactComponent?1:0;else{var renderedElement=inst;warnIfInvalidElement(Component,renderedElement);null===inst||!1===inst||React.isValidElement(inst)?void 0:\ninvariant(!1,\"%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.\",Component.displayName||Component.name||\"Component\");inst=new StatelessComponent(Component);this._compositeType=2}null==inst.render&&warning(!1,\"%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.\",Component.displayName||Component.name||\"Component\");doConstruct=inst.props!==publicProps;Component=\nComponent.displayName||Component.name||\"Component\";warning(void 0===inst.props||!doConstruct,\"%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",Component,Component);inst.props=publicProps;inst.context=publicContext;inst.refs=emptyObject;inst.updater=updateQueue;this._instance=inst;ReactInstanceMap.set(inst,this);warning(!inst.getInitialState||inst.getInitialState.isReactClassApproved||inst.state,\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\nthis.getName()||\"a component\");warning(!inst.getDefaultProps||inst.getDefaultProps.isReactClassApproved,\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",this.getName()||\"a component\");warning(!inst.propTypes,\"propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.\",this.getName()||\"a component\");warning(!inst.contextTypes,\n\"contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.\",this.getName()||\"a component\");warning(\"function\"!==typeof inst.componentShouldUpdate,\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",this.getName()||\"A component\");warning(\"function\"!==typeof inst.componentDidUnmount,\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\nthis.getName()||\"A component\");warning(\"function\"!==typeof inst.componentWillRecieveProps,\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",this.getName()||\"A component\");publicProps=inst.state;void 0===publicProps&&(inst.state=publicProps=null);\"object\"!==typeof publicProps||Array.isArray(publicProps)?invariant(!1,\"%s.state: must be set to an object or null\",this.getName()||\"ReactCompositeComponent\"):void 0;this._pendingStateQueue=null;this._pendingForceUpdate=\nthis._pendingReplaceState=!1;hostParent=inst.unstable_handleError?this.performInitialMountWithErrorHandling(renderedElement,hostParent,hostContainerInfo,transaction,context):this.performInitialMount(renderedElement,hostParent,hostContainerInfo,transaction,context);inst.componentDidMount&&transaction.getReactMountReady().enqueue(function(){measureLifeCyclePerf(function(){return inst.componentDidMount()},_this._debugID,\"componentDidMount\")});return hostParent},_constructComponent:function(doConstruct,\npublicProps,publicContext,updateQueue){ReactCurrentOwner.current=this;try{return this._constructComponentWithoutOwner(doConstruct,publicProps,publicContext,updateQueue)}finally{ReactCurrentOwner.current=null}},_constructComponentWithoutOwner:function(doConstruct,publicProps,publicContext,updateQueue){var Component=this._currentElement.type;return doConstruct?measureLifeCyclePerf(function(){return new Component(publicProps,publicContext,updateQueue)},this._debugID,\"ctor\"):measureLifeCyclePerf(function(){return Component(publicProps,\npublicContext,updateQueue)},this._debugID,\"render\")},performInitialMountWithErrorHandling:function(renderedElement,hostParent,hostContainerInfo,transaction,context){var checkpoint=transaction.checkpoint();try{var markup=this.performInitialMount(renderedElement,hostParent,hostContainerInfo,transaction,context)}catch(e){transaction.rollback(checkpoint),this._instance.unstable_handleError(e),this._pendingStateQueue&&(this._instance.state=this._processPendingState(this._instance.props,this._instance.context)),\ncheckpoint=transaction.checkpoint(),this._renderedComponent.unmountComponent(!0),transaction.rollback(checkpoint),markup=this.performInitialMount(renderedElement,hostParent,hostContainerInfo,transaction,context)}return markup},performInitialMount:function(renderedElement,hostParent,hostContainerInfo,transaction,context){var inst=this._instance,debugID=0;debugID=this._debugID;inst.componentWillMount&&(measureLifeCyclePerf(function(){return inst.componentWillMount()},debugID,\"componentWillMount\"),this._pendingStateQueue&&\n(inst.state=this._processPendingState(inst.props,inst.context)));void 0===renderedElement&&(renderedElement=this._renderValidatedComponent());var nodeType=ReactNodeTypes.getType(renderedElement);this._renderedNodeType=nodeType;this._renderedComponent=renderedElement=this._instantiateReactComponent(renderedElement,nodeType!==ReactNodeTypes.EMPTY);hostParent=ReactReconciler.mountComponent(renderedElement,transaction,hostParent,hostContainerInfo,this._processChildContext(context),debugID);if(0!==debugID)ReactInstrumentation.debugTool.onSetChildren(debugID,\n0!==renderedElement._debugID?[renderedElement._debugID]:[]);return hostParent},getHostNode:function(){return ReactReconciler.getHostNode(this._renderedComponent)},unmountComponent:function(safely){if(this._renderedComponent){var inst=this._instance;if(inst.componentWillUnmount&&!inst._calledComponentWillUnmount)if(inst._calledComponentWillUnmount=!0,safely){var name=this.getName()+\".componentWillUnmount()\";ReactErrorUtils.invokeGuardedCallback(name,inst.componentWillUnmount.bind(inst))}else measureLifeCyclePerf(function(){return inst.componentWillUnmount()},\nthis._debugID,\"componentWillUnmount\");this._renderedComponent&&(ReactReconciler.unmountComponent(this._renderedComponent,safely),this._instance=this._renderedComponent=this._renderedNodeType=null);this._pendingStateQueue=null;this._pendingForceUpdate=this._pendingReplaceState=!1;this._context=this._pendingElement=this._pendingCallbacks=null;this._rootNodeID=0;this._topLevelWrapper=null;ReactInstanceMap.remove(inst)}},_maskContext:function(context){var contextTypes=this._currentElement.type.contextTypes;\nif(!contextTypes)return emptyObject;var maskedContext={},contextName;for(contextName in contextTypes)maskedContext[contextName]=context[contextName];return maskedContext},_processContext:function(context){context=this._maskContext(context);var Component=this._currentElement.type;Component.contextTypes&&this._checkContextTypes(Component.contextTypes,context,\"context\");return context},_processChildContext:function(currentContext){var Component=this._currentElement.type,inst=this._instance;if(inst.getChildContext){ReactInstrumentation.debugTool.onBeginProcessingChildContext();\ntry{var childContext=inst.getChildContext()}finally{ReactInstrumentation.debugTool.onEndProcessingChildContext()}}if(childContext){\"object\"!==typeof Component.childContextTypes?invariant(!1,\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",this.getName()||\"ReactCompositeComponent\"):void 0;this._checkContextTypes(Component.childContextTypes,childContext,\"childContext\");for(var name in childContext)name in Component.childContextTypes?void 0:invariant(!1,'%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\nthis.getName()||\"ReactCompositeComponent\",name);return _assign({},currentContext,childContext)}return currentContext},_checkContextTypes:function(typeSpecs,values,location){checkReactTypeSpec(typeSpecs,values,location,this.getName(),null,this._debugID)},receiveComponent:function(nextElement,transaction,nextContext){var prevElement=this._currentElement,prevContext=this._context;this._pendingElement=null;this.updateComponent(transaction,prevElement,nextElement,prevContext,nextContext)},performUpdateIfNecessary:function(transaction){null!=\nthis._pendingElement?ReactReconciler.receiveComponent(this,this._pendingElement,transaction,this._context):null!==this._pendingStateQueue||this._pendingForceUpdate?this.updateComponent(transaction,this._currentElement,this._currentElement,this._context,this._context):this._updateBatchNumber=null},updateComponent:function(transaction,prevParentElement,nextParentElement,prevUnmaskedContext,nextUnmaskedContext){var inst=this._instance;null==inst?invariant(!1,\"Attempted to update component `%s` that has already been unmounted (or failed to mount).\",\nthis.getName()||\"ReactCompositeComponent\"):void 0;var willReceive=!1;if(this._context===nextUnmaskedContext)var nextContext=inst.context;else nextContext=this._processContext(nextUnmaskedContext),willReceive=!0;prevUnmaskedContext=prevParentElement.props;var nextProps=nextParentElement.props;prevParentElement!==nextParentElement&&(willReceive=!0);willReceive&&inst.componentWillReceiveProps&&measureLifeCyclePerf(function(){return inst.componentWillReceiveProps(nextProps,nextContext)},this._debugID,\n\"componentWillReceiveProps\");var nextState=this._processPendingState(nextProps,nextContext);prevParentElement=!0;this._pendingForceUpdate||(inst.shouldComponentUpdate?prevParentElement=measureLifeCyclePerf(function(){return inst.shouldComponentUpdate(nextProps,nextState,nextContext)},this._debugID,\"shouldComponentUpdate\"):1===this._compositeType&&(prevParentElement=!shallowEqual(prevUnmaskedContext,nextProps)||!shallowEqual(inst.state,nextState)));warning(void 0!==prevParentElement,\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\",\nthis.getName()||\"ReactCompositeComponent\");this._updateBatchNumber=null;prevParentElement?(this._pendingForceUpdate=!1,this._performComponentUpdate(nextParentElement,nextProps,nextState,nextContext,transaction,nextUnmaskedContext)):(this._currentElement=nextParentElement,this._context=nextUnmaskedContext,inst.props=nextProps,inst.state=nextState,inst.context=nextContext)},_processPendingState:function(props,context){var inst=this._instance,queue=this._pendingStateQueue,replace=this._pendingReplaceState;\nthis._pendingReplaceState=!1;this._pendingStateQueue=null;if(!queue)return inst.state;if(replace&&1===queue.length)return queue[0];var nextState=_assign({},replace?queue[0]:inst.state);for(replace=replace?1:0;replace<queue.length;replace++){var partial=queue[replace];_assign(nextState,\"function\"===typeof partial?partial.call(inst,nextState,props,context):partial)}return nextState},_performComponentUpdate:function(nextElement,nextProps,nextState,nextContext,transaction,unmaskedContext){var _this2=\nthis,inst=this._instance,hasComponentDidUpdate=!!inst.componentDidUpdate;if(hasComponentDidUpdate){var prevProps=inst.props;var prevState=inst.state;var prevContext=inst.context}inst.componentWillUpdate&&measureLifeCyclePerf(function(){return inst.componentWillUpdate(nextProps,nextState,nextContext)},this._debugID,\"componentWillUpdate\");this._currentElement=nextElement;this._context=unmaskedContext;inst.props=nextProps;inst.state=nextState;inst.context=nextContext;this._updateRenderedComponent(transaction,\nunmaskedContext);hasComponentDidUpdate&&transaction.getReactMountReady().enqueue(function(){measureLifeCyclePerf(inst.componentDidUpdate.bind(inst,prevProps,prevState,prevContext),_this2._debugID,\"componentDidUpdate\")})},_updateRenderedComponent:function(transaction,context){var prevComponentInstance=this._renderedComponent,prevRenderedElement=prevComponentInstance._currentElement,nextRenderedElement=this._renderValidatedComponent();var debugID=this._debugID;if(shouldUpdateReactComponent(prevRenderedElement,\nnextRenderedElement))ReactReconciler.receiveComponent(prevComponentInstance,nextRenderedElement,transaction,this._processChildContext(context));else{prevRenderedElement=ReactReconciler.getHostNode(prevComponentInstance);ReactReconciler.unmountComponent(prevComponentInstance,!1);var nodeType=ReactNodeTypes.getType(nextRenderedElement);this._renderedNodeType=nodeType;this._renderedComponent=nextRenderedElement=this._instantiateReactComponent(nextRenderedElement,nodeType!==ReactNodeTypes.EMPTY);transaction=\nReactReconciler.mountComponent(nextRenderedElement,transaction,this._hostParent,this._hostContainerInfo,this._processChildContext(context),debugID);if(0!==debugID)ReactInstrumentation.debugTool.onSetChildren(debugID,0!==nextRenderedElement._debugID?[nextRenderedElement._debugID]:[]);this._replaceNodeWithMarkup(prevRenderedElement,transaction,prevComponentInstance)}},_replaceNodeWithMarkup:function(oldHostNode,nextMarkup,prevInstance){ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode,nextMarkup,\nprevInstance)},_renderValidatedComponentWithoutOwnerOrContext:function(){var inst=this._instance;var renderedElement=measureLifeCyclePerf(function(){return inst.render()},this._debugID,\"render\");void 0===renderedElement&&inst.render._isMockFunction&&(renderedElement=null);return renderedElement},_renderValidatedComponent:function(){ReactCurrentOwner.current=this;try{var renderedElement=this._renderValidatedComponentWithoutOwnerOrContext()}finally{ReactCurrentOwner.current=null}null===renderedElement||\n!1===renderedElement||React.isValidElement(renderedElement)?void 0:invariant(!1,\"%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.\",this.getName()||\"ReactCompositeComponent\");return renderedElement},attachRef:function(ref,component){var inst=this.getPublicInstance();null==inst?invariant(!1,\"Stateless function components cannot have refs.\"):void 0;var publicComponentInstance=component.getPublicInstance(),componentName=\ncomponent&&component.getName?component.getName():\"a component\";warning(null!=publicComponentInstance||2!==component._compositeType,'Stateless function components cannot be given refs (See ref \"%s\" in %s created by %s). Attempts to access this ref will fail.',ref,componentName,this.getName());(inst.refs===emptyObject?inst.refs={}:inst.refs)[ref]=publicComponentInstance},detachRef:function(ref){delete this.getPublicInstance().refs[ref]},getName:function(){var type=this._currentElement.type,constructor=\nthis._instance&&this._instance.constructor;return type.displayName||constructor&&constructor.displayName||type.name||constructor&&constructor.name||null},getPublicInstance:function(){return 2===this._compositeType?null:this._instance},_instantiateReactComponent:null}}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactCompositeComponent\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n    _assign = require('object-assign');\n\nvar React = require('react/lib/React');\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\nvar ReactErrorUtils = require('./ReactErrorUtils');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactInstrumentation = require('./ReactInstrumentation');\nvar ReactNodeTypes = require('./ReactNodeTypes');\nvar ReactReconciler = require('./ReactReconciler');\n\nif (process.env.NODE_ENV !== 'production') {\n  var checkReactTypeSpec = require('./checkReactTypeSpec');\n}\n\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar invariant = require('fbjs/lib/invariant');\nvar shallowEqual = require('fbjs/lib/shallowEqual');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar warning = require('fbjs/lib/warning');\n\nvar CompositeTypes = {\n  ImpureClass: 0,\n  PureClass: 1,\n  StatelessFunctional: 2\n};\n\nfunction StatelessComponent(Component) {}\nStatelessComponent.prototype.render = function () {\n  var Component = ReactInstanceMap.get(this)._currentElement.type;\n  var element = Component(this.props, this.context, this.updater);\n  warnIfInvalidElement(Component, element);\n  return element;\n};\n\nfunction warnIfInvalidElement(Component, element) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;\n    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;\n  }\n}\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\nfunction isPureComponent(Component) {\n  return !!(Component.prototype && Component.prototype.isPureReactComponent);\n}\n\n// Separated into a function to contain deoptimizations caused by try/finally.\nfunction measureLifeCyclePerf(fn, debugID, timerType) {\n  if (debugID === 0) {\n    // Top-level wrappers (see ReactMount) and empty components (see\n    // ReactDOMEmptyComponent) are invisible to hooks and devtools.\n    // Both are implementation details that should go away in the future.\n    return fn();\n  }\n\n  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);\n  try {\n    return fn();\n  } finally {\n    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);\n  }\n}\n\n/**\n * ------------------ The Life-Cycle of a Composite Component ------------------\n *\n * - constructor: Initialization of state. The instance is now retained.\n *   - componentWillMount\n *   - render\n *   - [children's constructors]\n *     - [children's componentWillMount and render]\n *     - [children's componentDidMount]\n *     - componentDidMount\n *\n *       Update Phases:\n *       - componentWillReceiveProps (only called if parent updated)\n *       - shouldComponentUpdate\n *         - componentWillUpdate\n *           - render\n *           - [children's constructors or receive props phases]\n *         - componentDidUpdate\n *\n *     - componentWillUnmount\n *     - [children's componentWillUnmount]\n *   - [children destroyed]\n * - (destroyed): The instance is now blank, released by React and ready for GC.\n *\n * -----------------------------------------------------------------------------\n */\n\n/**\n * An incrementing ID assigned to each component when it is mounted. This is\n * used to enforce the order in which `ReactUpdates` updates dirty components.\n *\n * @private\n */\nvar nextMountID = 1;\n\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\nvar ReactCompositeComponent = {\n\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function (element) {\n    this._currentElement = element;\n    this._rootNodeID = 0;\n    this._compositeType = null;\n    this._instance = null;\n    this._hostParent = null;\n    this._hostContainerInfo = null;\n\n    // See ReactUpdateQueue\n    this._updateBatchNumber = null;\n    this._pendingElement = null;\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    this._renderedNodeType = null;\n    this._renderedComponent = null;\n    this._context = null;\n    this._mountOrder = 0;\n    this._topLevelWrapper = null;\n\n    // See ReactUpdates and ReactUpdateQueue.\n    this._pendingCallbacks = null;\n\n    // ComponentWillUnmount shall only be called once\n    this._calledComponentWillUnmount = false;\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._warnedAboutRefsInRender = false;\n    }\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?object} hostParent\n   * @param {?object} hostContainerInfo\n   * @param {?object} context\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {\n    var _this = this;\n\n    this._context = context;\n    this._mountOrder = nextMountID++;\n    this._hostParent = hostParent;\n    this._hostContainerInfo = hostContainerInfo;\n\n    var publicProps = this._currentElement.props;\n    var publicContext = this._processContext(context);\n\n    var Component = this._currentElement.type;\n\n    var updateQueue = transaction.getUpdateQueue();\n\n    // Initialize the public class\n    var doConstruct = shouldConstruct(Component);\n    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);\n    var renderedElement;\n\n    // Support functional components\n    if (!doConstruct && (inst == null || inst.render == null)) {\n      renderedElement = inst;\n      warnIfInvalidElement(Component, renderedElement);\n      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;\n      inst = new StatelessComponent(Component);\n      this._compositeType = CompositeTypes.StatelessFunctional;\n    } else {\n      if (isPureComponent(Component)) {\n        this._compositeType = CompositeTypes.PureClass;\n      } else {\n        this._compositeType = CompositeTypes.ImpureClass;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw later in _renderValidatedComponent, but add an early\n      // warning now to help debugging\n      if (inst.render == null) {\n        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;\n      }\n\n      var propsMutated = inst.props !== publicProps;\n      var componentName = Component.displayName || Component.name || 'Component';\n\n      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\\'s constructor was passed.', componentName, componentName) : void 0;\n    }\n\n    // These should be set up in the constructor, but as a convenience for\n    // simpler class abstractions, we set them up after the fact.\n    inst.props = publicProps;\n    inst.context = publicContext;\n    inst.refs = emptyObject;\n    inst.updater = updateQueue;\n\n    this._instance = inst;\n\n    // Store a reference from the instance back to the internal representation\n    ReactInstanceMap.set(inst, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Since plain JS classes are defined without any special initialization\n      // logic, we can not catch common errors early. Therefore, we have to\n      // catch them here, at initialization time, instead.\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;\n    }\n\n    var initialState = inst.state;\n    if (initialState === undefined) {\n      inst.state = initialState = null;\n    }\n    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;\n\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    var markup;\n    if (inst.unstable_handleError) {\n      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);\n    } else {\n      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);\n    }\n\n    if (inst.componentDidMount) {\n      if (process.env.NODE_ENV !== 'production') {\n        transaction.getReactMountReady().enqueue(function () {\n          measureLifeCyclePerf(function () {\n            return inst.componentDidMount();\n          }, _this._debugID, 'componentDidMount');\n        });\n      } else {\n        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);\n      }\n    }\n\n    return markup;\n  },\n\n  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      ReactCurrentOwner.current = this;\n      try {\n        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);\n      } finally {\n        ReactCurrentOwner.current = null;\n      }\n    } else {\n      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);\n    }\n  },\n\n  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {\n    var Component = this._currentElement.type;\n\n    if (doConstruct) {\n      if (process.env.NODE_ENV !== 'production') {\n        return measureLifeCyclePerf(function () {\n          return new Component(publicProps, publicContext, updateQueue);\n        }, this._debugID, 'ctor');\n      } else {\n        return new Component(publicProps, publicContext, updateQueue);\n      }\n    }\n\n    // This can still be an instance in case of factory components\n    // but we'll count this as time spent rendering as the more common case.\n    if (process.env.NODE_ENV !== 'production') {\n      return measureLifeCyclePerf(function () {\n        return Component(publicProps, publicContext, updateQueue);\n      }, this._debugID, 'render');\n    } else {\n      return Component(publicProps, publicContext, updateQueue);\n    }\n  },\n\n  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {\n    var markup;\n    var checkpoint = transaction.checkpoint();\n    try {\n      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);\n    } catch (e) {\n      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint\n      transaction.rollback(checkpoint);\n      this._instance.unstable_handleError(e);\n      if (this._pendingStateQueue) {\n        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);\n      }\n      checkpoint = transaction.checkpoint();\n\n      this._renderedComponent.unmountComponent(true);\n      transaction.rollback(checkpoint);\n\n      // Try again - we've informed the component about the error, so they can render an error message this time.\n      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).\n      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);\n    }\n    return markup;\n  },\n\n  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {\n    var inst = this._instance;\n\n    var debugID = 0;\n    if (process.env.NODE_ENV !== 'production') {\n      debugID = this._debugID;\n    }\n\n    if (inst.componentWillMount) {\n      if (process.env.NODE_ENV !== 'production') {\n        measureLifeCyclePerf(function () {\n          return inst.componentWillMount();\n        }, debugID, 'componentWillMount');\n      } else {\n        inst.componentWillMount();\n      }\n      // When mounting, calls to `setState` by `componentWillMount` will set\n      // `this._pendingStateQueue` without triggering a re-render.\n      if (this._pendingStateQueue) {\n        inst.state = this._processPendingState(inst.props, inst.context);\n      }\n    }\n\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    var nodeType = ReactNodeTypes.getType(renderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */\n    );\n    this._renderedComponent = child;\n\n    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (debugID !== 0) {\n        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n      }\n    }\n\n    return markup;\n  },\n\n  getHostNode: function () {\n    return ReactReconciler.getHostNode(this._renderedComponent);\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function (safely) {\n    if (!this._renderedComponent) {\n      return;\n    }\n\n    var inst = this._instance;\n\n    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {\n      inst._calledComponentWillUnmount = true;\n\n      if (safely) {\n        var name = this.getName() + '.componentWillUnmount()';\n        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          measureLifeCyclePerf(function () {\n            return inst.componentWillUnmount();\n          }, this._debugID, 'componentWillUnmount');\n        } else {\n          inst.componentWillUnmount();\n        }\n      }\n    }\n\n    if (this._renderedComponent) {\n      ReactReconciler.unmountComponent(this._renderedComponent, safely);\n      this._renderedNodeType = null;\n      this._renderedComponent = null;\n      this._instance = null;\n    }\n\n    // Reset pending fields\n    // Even if this component is scheduled for another update in ReactUpdates,\n    // it would still be ignored because these fields are reset.\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n    this._pendingCallbacks = null;\n    this._pendingElement = null;\n\n    // These fields do not really need to be reset since this object is no\n    // longer accessible.\n    this._context = null;\n    this._rootNodeID = 0;\n    this._topLevelWrapper = null;\n\n    // Delete the reference from the instance to this internal representation\n    // which allow the internals to be properly cleaned up even if the user\n    // leaks a reference to the public instance.\n    ReactInstanceMap.remove(inst);\n\n    // Some existing components rely on inst.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: inst.props = null;\n    // TODO: inst.state = null;\n    // TODO: inst.context = null;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _maskContext: function (context) {\n    var Component = this._currentElement.type;\n    var contextTypes = Component.contextTypes;\n    if (!contextTypes) {\n      return emptyObject;\n    }\n    var maskedContext = {};\n    for (var contextName in contextTypes) {\n      maskedContext[contextName] = context[contextName];\n    }\n    return maskedContext;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function (context) {\n    var maskedContext = this._maskContext(context);\n    if (process.env.NODE_ENV !== 'production') {\n      var Component = this._currentElement.type;\n      if (Component.contextTypes) {\n        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');\n      }\n    }\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _processChildContext: function (currentContext) {\n    var Component = this._currentElement.type;\n    var inst = this._instance;\n    var childContext;\n\n    if (inst.getChildContext) {\n      if (process.env.NODE_ENV !== 'production') {\n        ReactInstrumentation.debugTool.onBeginProcessingChildContext();\n        try {\n          childContext = inst.getChildContext();\n        } finally {\n          ReactInstrumentation.debugTool.onEndProcessingChildContext();\n        }\n      } else {\n        childContext = inst.getChildContext();\n      }\n    }\n\n    if (childContext) {\n      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;\n      if (process.env.NODE_ENV !== 'production') {\n        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');\n      }\n      for (var name in childContext) {\n        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;\n      }\n      return _assign({}, currentContext, childContext);\n    }\n    return currentContext;\n  },\n\n  /**\n   * Assert that the context types are valid\n   *\n   * @param {object} typeSpecs Map of context field to a ReactPropType\n   * @param {object} values Runtime values that need to be type-checked\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkContextTypes: function (typeSpecs, values, location) {\n    if (process.env.NODE_ENV !== 'production') {\n      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);\n    }\n  },\n\n  receiveComponent: function (nextElement, transaction, nextContext) {\n    var prevElement = this._currentElement;\n    var prevContext = this._context;\n\n    this._pendingElement = null;\n\n    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (transaction) {\n    if (this._pendingElement != null) {\n      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);\n    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);\n    } else {\n      this._updateBatchNumber = null;\n    }\n  },\n\n  /**\n   * Perform an update to a mounted component. The componentWillReceiveProps and\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\n   * skipped) the remaining update lifecycle methods are called and the DOM\n   * representation is updated.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevParentElement\n   * @param {ReactElement} nextParentElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {\n    var inst = this._instance;\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;\n\n    var willReceive = false;\n    var nextContext;\n\n    // Determine if the context has changed or not\n    if (this._context === nextUnmaskedContext) {\n      nextContext = inst.context;\n    } else {\n      nextContext = this._processContext(nextUnmaskedContext);\n      willReceive = true;\n    }\n\n    var prevProps = prevParentElement.props;\n    var nextProps = nextParentElement.props;\n\n    // Not a simple state update but a props update\n    if (prevParentElement !== nextParentElement) {\n      willReceive = true;\n    }\n\n    // An update here will schedule an update but immediately set\n    // _pendingStateQueue which will ensure that any state updates gets\n    // immediately reconciled instead of waiting for the next batch.\n    if (willReceive && inst.componentWillReceiveProps) {\n      if (process.env.NODE_ENV !== 'production') {\n        measureLifeCyclePerf(function () {\n          return inst.componentWillReceiveProps(nextProps, nextContext);\n        }, this._debugID, 'componentWillReceiveProps');\n      } else {\n        inst.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    var nextState = this._processPendingState(nextProps, nextContext);\n    var shouldUpdate = true;\n\n    if (!this._pendingForceUpdate) {\n      if (inst.shouldComponentUpdate) {\n        if (process.env.NODE_ENV !== 'production') {\n          shouldUpdate = measureLifeCyclePerf(function () {\n            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n          }, this._debugID, 'shouldComponentUpdate');\n        } else {\n          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n        }\n      } else {\n        if (this._compositeType === CompositeTypes.PureClass) {\n          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);\n        }\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;\n    }\n\n    this._updateBatchNumber = null;\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state but we shortcut the rest of the update.\n      this._currentElement = nextParentElement;\n      this._context = nextUnmaskedContext;\n      inst.props = nextProps;\n      inst.state = nextState;\n      inst.context = nextContext;\n    }\n  },\n\n  _processPendingState: function (props, context) {\n    var inst = this._instance;\n    var queue = this._pendingStateQueue;\n    var replace = this._pendingReplaceState;\n    this._pendingReplaceState = false;\n    this._pendingStateQueue = null;\n\n    if (!queue) {\n      return inst.state;\n    }\n\n    if (replace && queue.length === 1) {\n      return queue[0];\n    }\n\n    var nextState = _assign({}, replace ? queue[0] : inst.state);\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\n      var partial = queue[i];\n      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);\n    }\n\n    return nextState;\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?object} unmaskedContext\n   * @private\n   */\n  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {\n    var _this2 = this;\n\n    var inst = this._instance;\n\n    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);\n    var prevProps;\n    var prevState;\n    var prevContext;\n    if (hasComponentDidUpdate) {\n      prevProps = inst.props;\n      prevState = inst.state;\n      prevContext = inst.context;\n    }\n\n    if (inst.componentWillUpdate) {\n      if (process.env.NODE_ENV !== 'production') {\n        measureLifeCyclePerf(function () {\n          return inst.componentWillUpdate(nextProps, nextState, nextContext);\n        }, this._debugID, 'componentWillUpdate');\n      } else {\n        inst.componentWillUpdate(nextProps, nextState, nextContext);\n      }\n    }\n\n    this._currentElement = nextElement;\n    this._context = unmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n\n    this._updateRenderedComponent(transaction, unmaskedContext);\n\n    if (hasComponentDidUpdate) {\n      if (process.env.NODE_ENV !== 'production') {\n        transaction.getReactMountReady().enqueue(function () {\n          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');\n        });\n      } else {\n        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);\n      }\n    }\n  },\n\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponent: function (transaction, context) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n    var nextRenderedElement = this._renderValidatedComponent();\n\n    var debugID = 0;\n    if (process.env.NODE_ENV !== 'production') {\n      debugID = this._debugID;\n    }\n\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));\n    } else {\n      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n      ReactReconciler.unmountComponent(prevComponentInstance, false);\n\n      var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n      this._renderedNodeType = nodeType;\n      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */\n      );\n      this._renderedComponent = child;\n\n      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (debugID !== 0) {\n          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n        }\n      }\n\n      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);\n    }\n  },\n\n  /**\n   * Overridden in shallow rendering.\n   *\n   * @protected\n   */\n  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {\n    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);\n  },\n\n  /**\n   * @protected\n   */\n  _renderValidatedComponentWithoutOwnerOrContext: function () {\n    var inst = this._instance;\n    var renderedElement;\n\n    if (process.env.NODE_ENV !== 'production') {\n      renderedElement = measureLifeCyclePerf(function () {\n        return inst.render();\n      }, this._debugID, 'render');\n    } else {\n      renderedElement = inst.render();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We allow auto-mocks to proceed as if they're returning null.\n      if (renderedElement === undefined && inst.render._isMockFunction) {\n        // This is probably bad practice. Consider warning here and\n        // deprecating this convenience.\n        renderedElement = null;\n      }\n    }\n\n    return renderedElement;\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: function () {\n    var renderedElement;\n    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {\n      ReactCurrentOwner.current = this;\n      try {\n        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\n      } finally {\n        ReactCurrentOwner.current = null;\n      }\n    } else {\n      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\n    }\n    !(\n    // TODO: An `isValidNode` function would probably be more appropriate\n    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;\n\n    return renderedElement;\n  },\n\n  /**\n   * Lazily allocates the refs object and stores `component` as `ref`.\n   *\n   * @param {string} ref Reference name.\n   * @param {component} component Component to store as `ref`.\n   * @final\n   * @private\n   */\n  attachRef: function (ref, component) {\n    var inst = this.getPublicInstance();\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;\n    var publicComponentInstance = component.getPublicInstance();\n    if (process.env.NODE_ENV !== 'production') {\n      var componentName = component && component.getName ? component.getName() : 'a component';\n      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref \"%s\" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;\n    }\n    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n    refs[ref] = publicComponentInstance;\n  },\n\n  /**\n   * Detaches a reference name.\n   *\n   * @param {string} ref Name to dereference.\n   * @final\n   * @private\n   */\n  detachRef: function (ref) {\n    var refs = this.getPublicInstance().refs;\n    delete refs[ref];\n  },\n\n  /**\n   * Get a text description of the component that can be used to identify it\n   * in error messages.\n   * @return {string} The name or null.\n   * @internal\n   */\n  getName: function () {\n    var type = this._currentElement.type;\n    var constructor = this._instance && this._instance.constructor;\n    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;\n  },\n\n  /**\n   * Get the publicly accessible representation of this component - i.e. what\n   * is exposed by refs and returned by render. Can be null for stateless\n   * components.\n   *\n   * @return {ReactComponent} the public component instance.\n   * @internal\n   */\n  getPublicInstance: function () {\n    var inst = this._instance;\n    if (this._compositeType === CompositeTypes.StatelessFunctional) {\n      return null;\n    }\n    return inst;\n  },\n\n  // Stub\n  _instantiateReactComponent: null\n\n};\n\nmodule.exports = ReactCompositeComponent;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_dom$lib$ReactErrorUtils","~$module$node_modules$react_dom$lib$ReactInstrumentation","~$module$node_modules$fbjs$lib$shallowEqual","~$module$node_modules$react$lib$React","~$module$node_modules$object_assign$index","~$module$node_modules$react_dom$lib$shouldUpdateReactComponent","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react_dom$lib$checkReactTypeSpec","~$module$node_modules$fbjs$lib$emptyObject","~$module$node_modules$react_dom$lib$reactProdInvariant","~$module$node_modules$react_dom$lib$ReactReconciler","~$module$node_modules$react_dom$lib$ReactInstanceMap","~$module$node_modules$fbjs$lib$warning","~$module$node_modules$react_dom$lib$ReactComponentEnvironment","~$module$node_modules$react_dom$lib$ReactNodeTypes","~$module$node_modules$react$lib$ReactCurrentOwner"]],"~:properties",["^5",["_renderedComponent","_compositeType","_pendingReplaceState","_renderValidatedComponent","updateComponent","_constructComponentWithoutOwner","_renderedNodeType","_instance","_processContext","updater","_mountOrder","performInitialMount","_maskContext","_checkContextTypes","getHostNode","detachRef","_pendingElement","_updateBatchNumber","_processPendingState","_topLevelWrapper","_currentElement","mountComponent","_hostContainerInfo","_rootNodeID","getName","_renderValidatedComponentWithoutOwnerOrContext","construct","_warnedAboutRefsInRender","_pendingCallbacks","_constructComponent","receiveComponent","context","_instantiateReactComponent","_context","_pendingStateQueue","_calledComponentWillUnmount","performUpdateIfNecessary","current","performInitialMountWithErrorHandling","props","_pendingForceUpdate","render","state","getPublicInstance","attachRef","_hostParent","unmountComponent","_updateRenderedComponent","_replaceNodeWithMarkup","_performComponentUpdate","_processChildContext","refs"]],"~:compiled-at",1635270336843,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactCompositeComponent.js\",\n\"lineCount\":35,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/ReactCompositeComponent.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactCompositeComponent\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant'),\\n    _assign = require('object-assign');\\n\\nvar React = require('react/lib/React');\\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\\nvar ReactErrorUtils = require('./ReactErrorUtils');\\nvar ReactInstanceMap = require('./ReactInstanceMap');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\nvar ReactNodeTypes = require('./ReactNodeTypes');\\nvar ReactReconciler = require('./ReactReconciler');\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  var checkReactTypeSpec = require('./checkReactTypeSpec');\\n}\\n\\nvar emptyObject = require('fbjs/lib/emptyObject');\\nvar invariant = require('fbjs/lib/invariant');\\nvar shallowEqual = require('fbjs/lib/shallowEqual');\\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\\nvar warning = require('fbjs/lib/warning');\\n\\nvar CompositeTypes = {\\n  ImpureClass: 0,\\n  PureClass: 1,\\n  StatelessFunctional: 2\\n};\\n\\nfunction StatelessComponent(Component) {}\\nStatelessComponent.prototype.render = function () {\\n  var Component = ReactInstanceMap.get(this)._currentElement.type;\\n  var element = Component(this.props, this.context, this.updater);\\n  warnIfInvalidElement(Component, element);\\n  return element;\\n};\\n\\nfunction warnIfInvalidElement(Component, element) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;\\n    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;\\n  }\\n}\\n\\nfunction shouldConstruct(Component) {\\n  return !!(Component.prototype && Component.prototype.isReactComponent);\\n}\\n\\nfunction isPureComponent(Component) {\\n  return !!(Component.prototype && Component.prototype.isPureReactComponent);\\n}\\n\\n// Separated into a function to contain deoptimizations caused by try/finally.\\nfunction measureLifeCyclePerf(fn, debugID, timerType) {\\n  if (debugID === 0) {\\n    // Top-level wrappers (see ReactMount) and empty components (see\\n    // ReactDOMEmptyComponent) are invisible to hooks and devtools.\\n    // Both are implementation details that should go away in the future.\\n    return fn();\\n  }\\n\\n  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);\\n  try {\\n    return fn();\\n  } finally {\\n    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);\\n  }\\n}\\n\\n/**\\n * ------------------ The Life-Cycle of a Composite Component ------------------\\n *\\n * - constructor: Initialization of state. The instance is now retained.\\n *   - componentWillMount\\n *   - render\\n *   - [children's constructors]\\n *     - [children's componentWillMount and render]\\n *     - [children's componentDidMount]\\n *     - componentDidMount\\n *\\n *       Update Phases:\\n *       - componentWillReceiveProps (only called if parent updated)\\n *       - shouldComponentUpdate\\n *         - componentWillUpdate\\n *           - render\\n *           - [children's constructors or receive props phases]\\n *         - componentDidUpdate\\n *\\n *     - componentWillUnmount\\n *     - [children's componentWillUnmount]\\n *   - [children destroyed]\\n * - (destroyed): The instance is now blank, released by React and ready for GC.\\n *\\n * -----------------------------------------------------------------------------\\n */\\n\\n/**\\n * An incrementing ID assigned to each component when it is mounted. This is\\n * used to enforce the order in which `ReactUpdates` updates dirty components.\\n *\\n * @private\\n */\\nvar nextMountID = 1;\\n\\n/**\\n * @lends {ReactCompositeComponent.prototype}\\n */\\nvar ReactCompositeComponent = {\\n\\n  /**\\n   * Base constructor for all composite component.\\n   *\\n   * @param {ReactElement} element\\n   * @final\\n   * @internal\\n   */\\n  construct: function (element) {\\n    this._currentElement = element;\\n    this._rootNodeID = 0;\\n    this._compositeType = null;\\n    this._instance = null;\\n    this._hostParent = null;\\n    this._hostContainerInfo = null;\\n\\n    // See ReactUpdateQueue\\n    this._updateBatchNumber = null;\\n    this._pendingElement = null;\\n    this._pendingStateQueue = null;\\n    this._pendingReplaceState = false;\\n    this._pendingForceUpdate = false;\\n\\n    this._renderedNodeType = null;\\n    this._renderedComponent = null;\\n    this._context = null;\\n    this._mountOrder = 0;\\n    this._topLevelWrapper = null;\\n\\n    // See ReactUpdates and ReactUpdateQueue.\\n    this._pendingCallbacks = null;\\n\\n    // ComponentWillUnmount shall only be called once\\n    this._calledComponentWillUnmount = false;\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      this._warnedAboutRefsInRender = false;\\n    }\\n  },\\n\\n  /**\\n   * Initializes the component, renders markup, and registers event listeners.\\n   *\\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\\n   * @param {?object} hostParent\\n   * @param {?object} hostContainerInfo\\n   * @param {?object} context\\n   * @return {?string} Rendered markup to be inserted into the DOM.\\n   * @final\\n   * @internal\\n   */\\n  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {\\n    var _this = this;\\n\\n    this._context = context;\\n    this._mountOrder = nextMountID++;\\n    this._hostParent = hostParent;\\n    this._hostContainerInfo = hostContainerInfo;\\n\\n    var publicProps = this._currentElement.props;\\n    var publicContext = this._processContext(context);\\n\\n    var Component = this._currentElement.type;\\n\\n    var updateQueue = transaction.getUpdateQueue();\\n\\n    // Initialize the public class\\n    var doConstruct = shouldConstruct(Component);\\n    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);\\n    var renderedElement;\\n\\n    // Support functional components\\n    if (!doConstruct && (inst == null || inst.render == null)) {\\n      renderedElement = inst;\\n      warnIfInvalidElement(Component, renderedElement);\\n      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;\\n      inst = new StatelessComponent(Component);\\n      this._compositeType = CompositeTypes.StatelessFunctional;\\n    } else {\\n      if (isPureComponent(Component)) {\\n        this._compositeType = CompositeTypes.PureClass;\\n      } else {\\n        this._compositeType = CompositeTypes.ImpureClass;\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      // This will throw later in _renderValidatedComponent, but add an early\\n      // warning now to help debugging\\n      if (inst.render == null) {\\n        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;\\n      }\\n\\n      var propsMutated = inst.props !== publicProps;\\n      var componentName = Component.displayName || Component.name || 'Component';\\n\\n      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\\\\'s constructor was passed.', componentName, componentName) : void 0;\\n    }\\n\\n    // These should be set up in the constructor, but as a convenience for\\n    // simpler class abstractions, we set them up after the fact.\\n    inst.props = publicProps;\\n    inst.context = publicContext;\\n    inst.refs = emptyObject;\\n    inst.updater = updateQueue;\\n\\n    this._instance = inst;\\n\\n    // Store a reference from the instance back to the internal representation\\n    ReactInstanceMap.set(inst, this);\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      // Since plain JS classes are defined without any special initialization\\n      // logic, we can not catch common errors early. Therefore, we have to\\n      // catch them here, at initialization time, instead.\\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;\\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;\\n      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;\\n      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;\\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;\\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;\\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;\\n    }\\n\\n    var initialState = inst.state;\\n    if (initialState === undefined) {\\n      inst.state = initialState = null;\\n    }\\n    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;\\n\\n    this._pendingStateQueue = null;\\n    this._pendingReplaceState = false;\\n    this._pendingForceUpdate = false;\\n\\n    var markup;\\n    if (inst.unstable_handleError) {\\n      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);\\n    } else {\\n      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);\\n    }\\n\\n    if (inst.componentDidMount) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        transaction.getReactMountReady().enqueue(function () {\\n          measureLifeCyclePerf(function () {\\n            return inst.componentDidMount();\\n          }, _this._debugID, 'componentDidMount');\\n        });\\n      } else {\\n        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);\\n      }\\n    }\\n\\n    return markup;\\n  },\\n\\n  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      ReactCurrentOwner.current = this;\\n      try {\\n        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);\\n      } finally {\\n        ReactCurrentOwner.current = null;\\n      }\\n    } else {\\n      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);\\n    }\\n  },\\n\\n  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {\\n    var Component = this._currentElement.type;\\n\\n    if (doConstruct) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        return measureLifeCyclePerf(function () {\\n          return new Component(publicProps, publicContext, updateQueue);\\n        }, this._debugID, 'ctor');\\n      } else {\\n        return new Component(publicProps, publicContext, updateQueue);\\n      }\\n    }\\n\\n    // This can still be an instance in case of factory components\\n    // but we'll count this as time spent rendering as the more common case.\\n    if (process.env.NODE_ENV !== 'production') {\\n      return measureLifeCyclePerf(function () {\\n        return Component(publicProps, publicContext, updateQueue);\\n      }, this._debugID, 'render');\\n    } else {\\n      return Component(publicProps, publicContext, updateQueue);\\n    }\\n  },\\n\\n  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {\\n    var markup;\\n    var checkpoint = transaction.checkpoint();\\n    try {\\n      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);\\n    } catch (e) {\\n      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint\\n      transaction.rollback(checkpoint);\\n      this._instance.unstable_handleError(e);\\n      if (this._pendingStateQueue) {\\n        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);\\n      }\\n      checkpoint = transaction.checkpoint();\\n\\n      this._renderedComponent.unmountComponent(true);\\n      transaction.rollback(checkpoint);\\n\\n      // Try again - we've informed the component about the error, so they can render an error message this time.\\n      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).\\n      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);\\n    }\\n    return markup;\\n  },\\n\\n  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {\\n    var inst = this._instance;\\n\\n    var debugID = 0;\\n    if (process.env.NODE_ENV !== 'production') {\\n      debugID = this._debugID;\\n    }\\n\\n    if (inst.componentWillMount) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        measureLifeCyclePerf(function () {\\n          return inst.componentWillMount();\\n        }, debugID, 'componentWillMount');\\n      } else {\\n        inst.componentWillMount();\\n      }\\n      // When mounting, calls to `setState` by `componentWillMount` will set\\n      // `this._pendingStateQueue` without triggering a re-render.\\n      if (this._pendingStateQueue) {\\n        inst.state = this._processPendingState(inst.props, inst.context);\\n      }\\n    }\\n\\n    // If not a stateless component, we now render\\n    if (renderedElement === undefined) {\\n      renderedElement = this._renderValidatedComponent();\\n    }\\n\\n    var nodeType = ReactNodeTypes.getType(renderedElement);\\n    this._renderedNodeType = nodeType;\\n    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */\\n    );\\n    this._renderedComponent = child;\\n\\n    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (debugID !== 0) {\\n        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\\n        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\\n      }\\n    }\\n\\n    return markup;\\n  },\\n\\n  getHostNode: function () {\\n    return ReactReconciler.getHostNode(this._renderedComponent);\\n  },\\n\\n  /**\\n   * Releases any resources allocated by `mountComponent`.\\n   *\\n   * @final\\n   * @internal\\n   */\\n  unmountComponent: function (safely) {\\n    if (!this._renderedComponent) {\\n      return;\\n    }\\n\\n    var inst = this._instance;\\n\\n    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {\\n      inst._calledComponentWillUnmount = true;\\n\\n      if (safely) {\\n        var name = this.getName() + '.componentWillUnmount()';\\n        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));\\n      } else {\\n        if (process.env.NODE_ENV !== 'production') {\\n          measureLifeCyclePerf(function () {\\n            return inst.componentWillUnmount();\\n          }, this._debugID, 'componentWillUnmount');\\n        } else {\\n          inst.componentWillUnmount();\\n        }\\n      }\\n    }\\n\\n    if (this._renderedComponent) {\\n      ReactReconciler.unmountComponent(this._renderedComponent, safely);\\n      this._renderedNodeType = null;\\n      this._renderedComponent = null;\\n      this._instance = null;\\n    }\\n\\n    // Reset pending fields\\n    // Even if this component is scheduled for another update in ReactUpdates,\\n    // it would still be ignored because these fields are reset.\\n    this._pendingStateQueue = null;\\n    this._pendingReplaceState = false;\\n    this._pendingForceUpdate = false;\\n    this._pendingCallbacks = null;\\n    this._pendingElement = null;\\n\\n    // These fields do not really need to be reset since this object is no\\n    // longer accessible.\\n    this._context = null;\\n    this._rootNodeID = 0;\\n    this._topLevelWrapper = null;\\n\\n    // Delete the reference from the instance to this internal representation\\n    // which allow the internals to be properly cleaned up even if the user\\n    // leaks a reference to the public instance.\\n    ReactInstanceMap.remove(inst);\\n\\n    // Some existing components rely on inst.props even after they've been\\n    // destroyed (in event handlers).\\n    // TODO: inst.props = null;\\n    // TODO: inst.state = null;\\n    // TODO: inst.context = null;\\n  },\\n\\n  /**\\n   * Filters the context object to only contain keys specified in\\n   * `contextTypes`\\n   *\\n   * @param {object} context\\n   * @return {?object}\\n   * @private\\n   */\\n  _maskContext: function (context) {\\n    var Component = this._currentElement.type;\\n    var contextTypes = Component.contextTypes;\\n    if (!contextTypes) {\\n      return emptyObject;\\n    }\\n    var maskedContext = {};\\n    for (var contextName in contextTypes) {\\n      maskedContext[contextName] = context[contextName];\\n    }\\n    return maskedContext;\\n  },\\n\\n  /**\\n   * Filters the context object to only contain keys specified in\\n   * `contextTypes`, and asserts that they are valid.\\n   *\\n   * @param {object} context\\n   * @return {?object}\\n   * @private\\n   */\\n  _processContext: function (context) {\\n    var maskedContext = this._maskContext(context);\\n    if (process.env.NODE_ENV !== 'production') {\\n      var Component = this._currentElement.type;\\n      if (Component.contextTypes) {\\n        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');\\n      }\\n    }\\n    return maskedContext;\\n  },\\n\\n  /**\\n   * @param {object} currentContext\\n   * @return {object}\\n   * @private\\n   */\\n  _processChildContext: function (currentContext) {\\n    var Component = this._currentElement.type;\\n    var inst = this._instance;\\n    var childContext;\\n\\n    if (inst.getChildContext) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        ReactInstrumentation.debugTool.onBeginProcessingChildContext();\\n        try {\\n          childContext = inst.getChildContext();\\n        } finally {\\n          ReactInstrumentation.debugTool.onEndProcessingChildContext();\\n        }\\n      } else {\\n        childContext = inst.getChildContext();\\n      }\\n    }\\n\\n    if (childContext) {\\n      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;\\n      if (process.env.NODE_ENV !== 'production') {\\n        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');\\n      }\\n      for (var name in childContext) {\\n        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key \\\"%s\\\" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;\\n      }\\n      return _assign({}, currentContext, childContext);\\n    }\\n    return currentContext;\\n  },\\n\\n  /**\\n   * Assert that the context types are valid\\n   *\\n   * @param {object} typeSpecs Map of context field to a ReactPropType\\n   * @param {object} values Runtime values that need to be type-checked\\n   * @param {string} location e.g. \\\"prop\\\", \\\"context\\\", \\\"child context\\\"\\n   * @private\\n   */\\n  _checkContextTypes: function (typeSpecs, values, location) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);\\n    }\\n  },\\n\\n  receiveComponent: function (nextElement, transaction, nextContext) {\\n    var prevElement = this._currentElement;\\n    var prevContext = this._context;\\n\\n    this._pendingElement = null;\\n\\n    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);\\n  },\\n\\n  /**\\n   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\\n   * is set, update the component.\\n   *\\n   * @param {ReactReconcileTransaction} transaction\\n   * @internal\\n   */\\n  performUpdateIfNecessary: function (transaction) {\\n    if (this._pendingElement != null) {\\n      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);\\n    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\\n      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);\\n    } else {\\n      this._updateBatchNumber = null;\\n    }\\n  },\\n\\n  /**\\n   * Perform an update to a mounted component. The componentWillReceiveProps and\\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\\n   * skipped) the remaining update lifecycle methods are called and the DOM\\n   * representation is updated.\\n   *\\n   * By default, this implements React's rendering and reconciliation algorithm.\\n   * Sophisticated clients may wish to override this.\\n   *\\n   * @param {ReactReconcileTransaction} transaction\\n   * @param {ReactElement} prevParentElement\\n   * @param {ReactElement} nextParentElement\\n   * @internal\\n   * @overridable\\n   */\\n  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {\\n    var inst = this._instance;\\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;\\n\\n    var willReceive = false;\\n    var nextContext;\\n\\n    // Determine if the context has changed or not\\n    if (this._context === nextUnmaskedContext) {\\n      nextContext = inst.context;\\n    } else {\\n      nextContext = this._processContext(nextUnmaskedContext);\\n      willReceive = true;\\n    }\\n\\n    var prevProps = prevParentElement.props;\\n    var nextProps = nextParentElement.props;\\n\\n    // Not a simple state update but a props update\\n    if (prevParentElement !== nextParentElement) {\\n      willReceive = true;\\n    }\\n\\n    // An update here will schedule an update but immediately set\\n    // _pendingStateQueue which will ensure that any state updates gets\\n    // immediately reconciled instead of waiting for the next batch.\\n    if (willReceive && inst.componentWillReceiveProps) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        measureLifeCyclePerf(function () {\\n          return inst.componentWillReceiveProps(nextProps, nextContext);\\n        }, this._debugID, 'componentWillReceiveProps');\\n      } else {\\n        inst.componentWillReceiveProps(nextProps, nextContext);\\n      }\\n    }\\n\\n    var nextState = this._processPendingState(nextProps, nextContext);\\n    var shouldUpdate = true;\\n\\n    if (!this._pendingForceUpdate) {\\n      if (inst.shouldComponentUpdate) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          shouldUpdate = measureLifeCyclePerf(function () {\\n            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);\\n          }, this._debugID, 'shouldComponentUpdate');\\n        } else {\\n          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);\\n        }\\n      } else {\\n        if (this._compositeType === CompositeTypes.PureClass) {\\n          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);\\n        }\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;\\n    }\\n\\n    this._updateBatchNumber = null;\\n    if (shouldUpdate) {\\n      this._pendingForceUpdate = false;\\n      // Will set `this.props`, `this.state` and `this.context`.\\n      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);\\n    } else {\\n      // If it's determined that a component should not update, we still want\\n      // to set props and state but we shortcut the rest of the update.\\n      this._currentElement = nextParentElement;\\n      this._context = nextUnmaskedContext;\\n      inst.props = nextProps;\\n      inst.state = nextState;\\n      inst.context = nextContext;\\n    }\\n  },\\n\\n  _processPendingState: function (props, context) {\\n    var inst = this._instance;\\n    var queue = this._pendingStateQueue;\\n    var replace = this._pendingReplaceState;\\n    this._pendingReplaceState = false;\\n    this._pendingStateQueue = null;\\n\\n    if (!queue) {\\n      return inst.state;\\n    }\\n\\n    if (replace && queue.length === 1) {\\n      return queue[0];\\n    }\\n\\n    var nextState = _assign({}, replace ? queue[0] : inst.state);\\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\\n      var partial = queue[i];\\n      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);\\n    }\\n\\n    return nextState;\\n  },\\n\\n  /**\\n   * Merges new props and state, notifies delegate methods of update and\\n   * performs update.\\n   *\\n   * @param {ReactElement} nextElement Next element\\n   * @param {object} nextProps Next public object to set as properties.\\n   * @param {?object} nextState Next object to set as state.\\n   * @param {?object} nextContext Next public object to set as context.\\n   * @param {ReactReconcileTransaction} transaction\\n   * @param {?object} unmaskedContext\\n   * @private\\n   */\\n  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {\\n    var _this2 = this;\\n\\n    var inst = this._instance;\\n\\n    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);\\n    var prevProps;\\n    var prevState;\\n    var prevContext;\\n    if (hasComponentDidUpdate) {\\n      prevProps = inst.props;\\n      prevState = inst.state;\\n      prevContext = inst.context;\\n    }\\n\\n    if (inst.componentWillUpdate) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        measureLifeCyclePerf(function () {\\n          return inst.componentWillUpdate(nextProps, nextState, nextContext);\\n        }, this._debugID, 'componentWillUpdate');\\n      } else {\\n        inst.componentWillUpdate(nextProps, nextState, nextContext);\\n      }\\n    }\\n\\n    this._currentElement = nextElement;\\n    this._context = unmaskedContext;\\n    inst.props = nextProps;\\n    inst.state = nextState;\\n    inst.context = nextContext;\\n\\n    this._updateRenderedComponent(transaction, unmaskedContext);\\n\\n    if (hasComponentDidUpdate) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        transaction.getReactMountReady().enqueue(function () {\\n          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');\\n        });\\n      } else {\\n        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Call the component's `render` method and update the DOM accordingly.\\n   *\\n   * @param {ReactReconcileTransaction} transaction\\n   * @internal\\n   */\\n  _updateRenderedComponent: function (transaction, context) {\\n    var prevComponentInstance = this._renderedComponent;\\n    var prevRenderedElement = prevComponentInstance._currentElement;\\n    var nextRenderedElement = this._renderValidatedComponent();\\n\\n    var debugID = 0;\\n    if (process.env.NODE_ENV !== 'production') {\\n      debugID = this._debugID;\\n    }\\n\\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\\n      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));\\n    } else {\\n      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\\n      ReactReconciler.unmountComponent(prevComponentInstance, false);\\n\\n      var nodeType = ReactNodeTypes.getType(nextRenderedElement);\\n      this._renderedNodeType = nodeType;\\n      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */\\n      );\\n      this._renderedComponent = child;\\n\\n      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (debugID !== 0) {\\n          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\\n          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\\n        }\\n      }\\n\\n      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);\\n    }\\n  },\\n\\n  /**\\n   * Overridden in shallow rendering.\\n   *\\n   * @protected\\n   */\\n  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {\\n    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);\\n  },\\n\\n  /**\\n   * @protected\\n   */\\n  _renderValidatedComponentWithoutOwnerOrContext: function () {\\n    var inst = this._instance;\\n    var renderedElement;\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      renderedElement = measureLifeCyclePerf(function () {\\n        return inst.render();\\n      }, this._debugID, 'render');\\n    } else {\\n      renderedElement = inst.render();\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      // We allow auto-mocks to proceed as if they're returning null.\\n      if (renderedElement === undefined && inst.render._isMockFunction) {\\n        // This is probably bad practice. Consider warning here and\\n        // deprecating this convenience.\\n        renderedElement = null;\\n      }\\n    }\\n\\n    return renderedElement;\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _renderValidatedComponent: function () {\\n    var renderedElement;\\n    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {\\n      ReactCurrentOwner.current = this;\\n      try {\\n        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\\n      } finally {\\n        ReactCurrentOwner.current = null;\\n      }\\n    } else {\\n      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\\n    }\\n    !(\\n    // TODO: An `isValidNode` function would probably be more appropriate\\n    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;\\n\\n    return renderedElement;\\n  },\\n\\n  /**\\n   * Lazily allocates the refs object and stores `component` as `ref`.\\n   *\\n   * @param {string} ref Reference name.\\n   * @param {component} component Component to store as `ref`.\\n   * @final\\n   * @private\\n   */\\n  attachRef: function (ref, component) {\\n    var inst = this.getPublicInstance();\\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;\\n    var publicComponentInstance = component.getPublicInstance();\\n    if (process.env.NODE_ENV !== 'production') {\\n      var componentName = component && component.getName ? component.getName() : 'a component';\\n      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref \\\"%s\\\" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;\\n    }\\n    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\\n    refs[ref] = publicComponentInstance;\\n  },\\n\\n  /**\\n   * Detaches a reference name.\\n   *\\n   * @param {string} ref Name to dereference.\\n   * @final\\n   * @private\\n   */\\n  detachRef: function (ref) {\\n    var refs = this.getPublicInstance().refs;\\n    delete refs[ref];\\n  },\\n\\n  /**\\n   * Get a text description of the component that can be used to identify it\\n   * in error messages.\\n   * @return {string} The name or null.\\n   * @internal\\n   */\\n  getName: function () {\\n    var type = this._currentElement.type;\\n    var constructor = this._instance && this._instance.constructor;\\n    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;\\n  },\\n\\n  /**\\n   * Get the publicly accessible representation of this component - i.e. what\\n   * is exposed by refs and returned by render. Can be null for stateless\\n   * components.\\n   *\\n   * @return {ReactComponent} the public component instance.\\n   * @internal\\n   */\\n  getPublicInstance: function () {\\n    var inst = this._instance;\\n    if (this._compositeType === CompositeTypes.StatelessFunctional) {\\n      return null;\\n    }\\n    return inst;\\n  },\\n\\n  // Stub\\n  _instantiateReactComponent: null\\n\\n};\\n\\nmodule.exports = ReactCompositeComponent;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"StatelessComponent\",\"Component\",\"warnIfInvalidElement\",\"element\",\"warning\",\"React\",\"isValidElement\",\"displayName\",\"name\",\"childContextTypes\",\"measureLifeCyclePerf\",\"fn\",\"debugID\",\"timerType\",\"ReactInstrumentation\",\"debugTool\",\"onBeginLifeCycleTimer\",\"onEndLifeCycleTimer\",\"_assign\",\"ReactComponentEnvironment\",\"ReactCurrentOwner\",\"ReactErrorUtils\",\"ReactInstanceMap\",\"ReactNodeTypes\",\"ReactReconciler\",\"checkReactTypeSpec\",\"emptyObject\",\"invariant\",\"shallowEqual\",\"shouldUpdateReactComponent\",\"prototype\",\"render\",\"StatelessComponent.prototype.render\",\"get\",\"_currentElement\",\"type\",\"props\",\"context\",\"updater\",\"nextMountID\",\"ReactCompositeComponent\",\"construct\",\"_rootNodeID\",\"_pendingStateQueue\",\"_pendingElement\",\"_updateBatchNumber\",\"_hostContainerInfo\",\"_hostParent\",\"_instance\",\"_compositeType\",\"_pendingForceUpdate\",\"_pendingReplaceState\",\"_context\",\"_renderedComponent\",\"_renderedNodeType\",\"_mountOrder\",\"_pendingCallbacks\",\"_topLevelWrapper\",\"_warnedAboutRefsInRender\",\"_calledComponentWillUnmount\",\"mountComponent\",\"transaction\",\"hostParent\",\"hostContainerInfo\",\"_this\",\"publicProps\",\"publicContext\",\"_processContext\",\"updateQueue\",\"getUpdateQueue\",\"doConstruct\",\"isReactComponent\",\"inst\",\"_constructComponent\",\"isPureReactComponent\",\"PureClass\",\"ImpureClass\",\"renderedElement\",\"StatelessFunctional\",\"propsMutated\",\"componentName\",\"undefined\",\"refs\",\"set\",\"getInitialState\",\"isReactClassApproved\",\"state\",\"getName\",\"getDefaultProps\",\"propTypes\",\"contextTypes\",\"componentShouldUpdate\",\"componentDidUnmount\",\"componentWillRecieveProps\",\"initialState\",\"Array\",\"isArray\",\"markup\",\"unstable_handleError\",\"performInitialMountWithErrorHandling\",\"performInitialMount\",\"componentDidMount\",\"getReactMountReady\",\"enqueue\",\"_debugID\",\"current\",\"_constructComponentWithoutOwner\",\"checkpoint\",\"e\",\"rollback\",\"_processPendingState\",\"unmountComponent\",\"componentWillMount\",\"_renderValidatedComponent\",\"nodeType\",\"getType\",\"child\",\"_instantiateReactComponent\",\"EMPTY\",\"_processChildContext\",\"onSetChildren\",\"childDebugIDs\",\"getHostNode\",\"safely\",\"componentWillUnmount\",\"invokeGuardedCallback\",\"bind\",\"remove\",\"_maskContext\",\"maskedContext\",\"contextName\",\"_checkContextTypes\",\"currentContext\",\"getChildContext\",\"onBeginProcessingChildContext\",\"childContext\",\"onEndProcessingChildContext\",\"typeSpecs\",\"values\",\"location\",\"receiveComponent\",\"nextElement\",\"nextContext\",\"prevElement\",\"prevContext\",\"updateComponent\",\"performUpdateIfNecessary\",\"prevParentElement\",\"nextParentElement\",\"prevUnmaskedContext\",\"nextUnmaskedContext\",\"willReceive\",\"prevProps\",\"nextProps\",\"componentWillReceiveProps\",\"nextState\",\"shouldUpdate\",\"shouldComponentUpdate\",\"_performComponentUpdate\",\"queue\",\"replace\",\"length\",\"i\",\"partial\",\"call\",\"unmaskedContext\",\"_this2\",\"hasComponentDidUpdate\",\"componentDidUpdate\",\"prevState\",\"componentWillUpdate\",\"_updateRenderedComponent\",\"prevComponentInstance\",\"prevRenderedElement\",\"nextRenderedElement\",\"oldHostNode\",\"nextMarkup\",\"_replaceNodeWithMarkup\",\"prevInstance\",\"replaceNodeWithMarkup\",\"_renderValidatedComponentWithoutOwnerOrContext\",\"_isMockFunction\",\"attachRef\",\"ref\",\"component\",\"getPublicInstance\",\"publicComponentInstance\",\"detachRef\",\"constructor\"]\n}\n"]