["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactChildReconciler.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactChildReconciler=function(global,process,require,module,exports,shadow$shims){var ReactReconciler=require(\"module$node_modules$react_dom$lib$ReactReconciler\"),instantiateReactComponent=require(\"module$node_modules$react_dom$lib$instantiateReactComponent\"),KeyEscapeUtils=require(\"module$node_modules$react_dom$lib$KeyEscapeUtils\"),shouldUpdateReactComponent=require(\"module$node_modules$react_dom$lib$shouldUpdateReactComponent\"),traverseAllChildren=\nrequire(\"module$node_modules$react_dom$lib$traverseAllChildren\"),warning=require(\"module$node_modules$fbjs$lib$warning\"),ReactComponentTreeHook;module.exports={instantiateChildren:function(nestedChildNodes,transaction,context,selfDebugID){if(null==nestedChildNodes)return null;transaction={};traverseAllChildren(nestedChildNodes,function(childInsts,child,name){var keyUnique=void 0===childInsts[name];ReactComponentTreeHook||(ReactComponentTreeHook=require(\"module$node_modules$react$lib$ReactComponentTreeHook\"));\nkeyUnique||warning(!1,\"flattenChildren(...): Encountered two children with the same key, `%s`. Child keys must be unique; when two children share a key, only the first child will be used.%s\",KeyEscapeUtils.unescape(name),ReactComponentTreeHook.getStackAddendumByID(selfDebugID));null!=child&&keyUnique&&(childInsts[name]=instantiateReactComponent(child,!0))},transaction);return transaction},updateChildren:function(prevChildren,nextChildren,mountImages,removedNodes,transaction,hostParent,hostContainerInfo,\ncontext,selfDebugID){if(nextChildren||prevChildren){var name,prevChild;for(name in nextChildren)if(nextChildren.hasOwnProperty(name)){var prevElement=(prevChild=prevChildren&&prevChildren[name])&&prevChild._currentElement,nextElement=nextChildren[name];null!=prevChild&&shouldUpdateReactComponent(prevElement,nextElement)?(ReactReconciler.receiveComponent(prevChild,nextElement,transaction,context),nextChildren[name]=prevChild):(prevChild&&(removedNodes[name]=ReactReconciler.getHostNode(prevChild),ReactReconciler.unmountComponent(prevChild,\n!1)),prevChild=instantiateReactComponent(nextElement,!0),nextChildren[name]=prevChild,prevChild=ReactReconciler.mountComponent(prevChild,transaction,hostParent,hostContainerInfo,context,selfDebugID),mountImages.push(prevChild))}for(name in prevChildren)!prevChildren.hasOwnProperty(name)||nextChildren&&nextChildren.hasOwnProperty(name)||(prevChild=prevChildren[name],removedNodes[name]=ReactReconciler.getHostNode(prevChild),ReactReconciler.unmountComponent(prevChild,!1))}},unmountChildren:function(renderedChildren,\nsafely){for(var name in renderedChildren)renderedChildren.hasOwnProperty(name)&&ReactReconciler.unmountComponent(renderedChildren[name],safely)}}}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactChildReconciler\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar instantiateReactComponent = require('./instantiateReactComponent');\nvar KeyEscapeUtils = require('./KeyEscapeUtils');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar traverseAllChildren = require('./traverseAllChildren');\nvar warning = require('fbjs/lib/warning');\n\nvar ReactComponentTreeHook;\n\nif (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {\n  // Temporary hack.\n  // Inline requires don't work well with Jest:\n  // https://github.com/facebook/react/issues/7240\n  // Remove the inline requires when we don't need them anymore:\n  // https://github.com/facebook/react/pull/7178\n  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\n}\n\nfunction instantiateChild(childInstances, child, name, selfDebugID) {\n  // We found a component instance.\n  var keyUnique = childInstances[name] === undefined;\n  if (process.env.NODE_ENV !== 'production') {\n    if (!ReactComponentTreeHook) {\n      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\n    }\n    if (!keyUnique) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;\n    }\n  }\n  if (child != null && keyUnique) {\n    childInstances[name] = instantiateReactComponent(child, true);\n  }\n}\n\n/**\n * ReactChildReconciler provides helpers for initializing or updating a set of\n * children. Its output is suitable for passing it onto ReactMultiChild which\n * does diffed reordering and insertion.\n */\nvar ReactChildReconciler = {\n  /**\n   * Generates a \"mount image\" for each of the supplied children. In the case\n   * of `ReactDOMComponent`, a mount image is a string of markup.\n   *\n   * @param {?object} nestedChildNodes Nested child maps.\n   * @return {?object} A set of child instances.\n   * @internal\n   */\n  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots\n  ) {\n    if (nestedChildNodes == null) {\n      return null;\n    }\n    var childInstances = {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {\n        return instantiateChild(childInsts, child, name, selfDebugID);\n      }, childInstances);\n    } else {\n      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);\n    }\n    return childInstances;\n  },\n\n  /**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextChildren Flat child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots\n  ) {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    if (!nextChildren && !prevChildren) {\n      return;\n    }\n    var name;\n    var prevChild;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {\n        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);\n        nextChildren[name] = prevChild;\n      } else {\n        if (prevChild) {\n          removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n          ReactReconciler.unmountComponent(prevChild, false);\n        }\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(nextElement, true);\n        nextChildren[name] = nextChildInstance;\n        // Creating mount image now ensures refs are resolved in right order\n        // (see https://github.com/facebook/react/pull/7101 for explanation).\n        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);\n        mountImages.push(nextChildMountImage);\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {\n        prevChild = prevChildren[name];\n        removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n        ReactReconciler.unmountComponent(prevChild, false);\n      }\n    }\n  },\n\n  /**\n   * Unmounts all rendered children. This should be used to clean up children\n   * when this component is unmounted.\n   *\n   * @param {?object} renderedChildren Previously initialized set of children.\n   * @internal\n   */\n  unmountChildren: function (renderedChildren, safely) {\n    for (var name in renderedChildren) {\n      if (renderedChildren.hasOwnProperty(name)) {\n        var renderedChild = renderedChildren[name];\n        ReactReconciler.unmountComponent(renderedChild, safely);\n      }\n    }\n  }\n\n};\n\nmodule.exports = ReactChildReconciler;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$lib$ReactComponentTreeHook","~$module$node_modules$react_dom$lib$instantiateReactComponent","~$module$node_modules$react_dom$lib$shouldUpdateReactComponent","~$shadow.js","~$module$node_modules$react_dom$lib$ReactReconciler","~$module$node_modules$react_dom$lib$KeyEscapeUtils","~$module$node_modules$react_dom$lib$traverseAllChildren","~$module$node_modules$fbjs$lib$warning"]],"~:properties",["^5",["unmountChildren","updateChildren","instantiateChildren"]],"~:compiled-at",1635270336845,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactChildReconciler.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/ReactChildReconciler.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactChildReconciler\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2014-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar ReactReconciler = require('./ReactReconciler');\\n\\nvar instantiateReactComponent = require('./instantiateReactComponent');\\nvar KeyEscapeUtils = require('./KeyEscapeUtils');\\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\\nvar traverseAllChildren = require('./traverseAllChildren');\\nvar warning = require('fbjs/lib/warning');\\n\\nvar ReactComponentTreeHook;\\n\\nif (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {\\n  // Temporary hack.\\n  // Inline requires don't work well with Jest:\\n  // https://github.com/facebook/react/issues/7240\\n  // Remove the inline requires when we don't need them anymore:\\n  // https://github.com/facebook/react/pull/7178\\n  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\\n}\\n\\nfunction instantiateChild(childInstances, child, name, selfDebugID) {\\n  // We found a component instance.\\n  var keyUnique = childInstances[name] === undefined;\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (!ReactComponentTreeHook) {\\n      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\\n    }\\n    if (!keyUnique) {\\n      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;\\n    }\\n  }\\n  if (child != null && keyUnique) {\\n    childInstances[name] = instantiateReactComponent(child, true);\\n  }\\n}\\n\\n/**\\n * ReactChildReconciler provides helpers for initializing or updating a set of\\n * children. Its output is suitable for passing it onto ReactMultiChild which\\n * does diffed reordering and insertion.\\n */\\nvar ReactChildReconciler = {\\n  /**\\n   * Generates a \\\"mount image\\\" for each of the supplied children. In the case\\n   * of `ReactDOMComponent`, a mount image is a string of markup.\\n   *\\n   * @param {?object} nestedChildNodes Nested child maps.\\n   * @return {?object} A set of child instances.\\n   * @internal\\n   */\\n  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots\\n  ) {\\n    if (nestedChildNodes == null) {\\n      return null;\\n    }\\n    var childInstances = {};\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {\\n        return instantiateChild(childInsts, child, name, selfDebugID);\\n      }, childInstances);\\n    } else {\\n      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);\\n    }\\n    return childInstances;\\n  },\\n\\n  /**\\n   * Updates the rendered children and returns a new set of children.\\n   *\\n   * @param {?object} prevChildren Previously initialized set of children.\\n   * @param {?object} nextChildren Flat child element maps.\\n   * @param {ReactReconcileTransaction} transaction\\n   * @param {object} context\\n   * @return {?object} A new set of child instances.\\n   * @internal\\n   */\\n  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots\\n  ) {\\n    // We currently don't have a way to track moves here but if we use iterators\\n    // instead of for..in we can zip the iterators and check if an item has\\n    // moved.\\n    // TODO: If nothing has changed, return the prevChildren object so that we\\n    // can quickly bailout if nothing has changed.\\n    if (!nextChildren && !prevChildren) {\\n      return;\\n    }\\n    var name;\\n    var prevChild;\\n    for (name in nextChildren) {\\n      if (!nextChildren.hasOwnProperty(name)) {\\n        continue;\\n      }\\n      prevChild = prevChildren && prevChildren[name];\\n      var prevElement = prevChild && prevChild._currentElement;\\n      var nextElement = nextChildren[name];\\n      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {\\n        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);\\n        nextChildren[name] = prevChild;\\n      } else {\\n        if (prevChild) {\\n          removedNodes[name] = ReactReconciler.getHostNode(prevChild);\\n          ReactReconciler.unmountComponent(prevChild, false);\\n        }\\n        // The child must be instantiated before it's mounted.\\n        var nextChildInstance = instantiateReactComponent(nextElement, true);\\n        nextChildren[name] = nextChildInstance;\\n        // Creating mount image now ensures refs are resolved in right order\\n        // (see https://github.com/facebook/react/pull/7101 for explanation).\\n        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);\\n        mountImages.push(nextChildMountImage);\\n      }\\n    }\\n    // Unmount children that are no longer present.\\n    for (name in prevChildren) {\\n      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {\\n        prevChild = prevChildren[name];\\n        removedNodes[name] = ReactReconciler.getHostNode(prevChild);\\n        ReactReconciler.unmountComponent(prevChild, false);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Unmounts all rendered children. This should be used to clean up children\\n   * when this component is unmounted.\\n   *\\n   * @param {?object} renderedChildren Previously initialized set of children.\\n   * @internal\\n   */\\n  unmountChildren: function (renderedChildren, safely) {\\n    for (var name in renderedChildren) {\\n      if (renderedChildren.hasOwnProperty(name)) {\\n        var renderedChild = renderedChildren[name];\\n        ReactReconciler.unmountComponent(renderedChild, safely);\\n      }\\n    }\\n  }\\n\\n};\\n\\nmodule.exports = ReactChildReconciler;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"ReactReconciler\",\"instantiateReactComponent\",\"KeyEscapeUtils\",\"shouldUpdateReactComponent\",\"traverseAllChildren\",\"warning\",\"ReactComponentTreeHook\",\"ReactChildReconciler\",\"instantiateChildren\",\"nestedChildNodes\",\"transaction\",\"context\",\"selfDebugID\",\"childInstances\",\"childInsts\",\"child\",\"name\",\"keyUnique\",\"undefined\",\"unescape\",\"getStackAddendumByID\",\"updateChildren\",\"prevChildren\",\"nextChildren\",\"mountImages\",\"removedNodes\",\"hostParent\",\"hostContainerInfo\",\"prevChild\",\"hasOwnProperty\",\"prevElement\",\"_currentElement\",\"nextElement\",\"receiveComponent\",\"getHostNode\",\"unmountComponent\",\"nextChildInstance\",\"nextChildMountImage\",\"mountComponent\",\"push\",\"unmountChildren\",\"renderedChildren\",\"safely\",\"renderedChild\"]\n}\n"]