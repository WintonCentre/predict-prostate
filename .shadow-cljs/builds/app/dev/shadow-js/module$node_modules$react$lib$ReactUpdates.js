["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactUpdates.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactUpdates=function(global,require,module,exports){function ensureInjected(){ReactUpdates.ReactReconcileTransaction&&batchingStrategy?void 0:invariant(!1,\"ReactUpdates: must inject a reconcile transaction class and batching strategy\")}function ReactUpdatesFlushTransaction(){this.reinitializeTransaction();this.dirtyComponentsLength=null;this.callbackQueue=CallbackQueue.getPooled();this.reconcileTransaction=ReactUpdates.ReactReconcileTransaction.getPooled(!0)}\nfunction mountOrderComparator(c1,c2){return c1._mountOrder-c2._mountOrder}function runBatchedUpdates(transaction){var len=transaction.dirtyComponentsLength;len!==dirtyComponents.length?invariant(!1,\"Expected flush transaction's stored dirty-components length (%s) to match dirty-components array length (%s).\",len,dirtyComponents.length):void 0;dirtyComponents.sort(mountOrderComparator);updateBatchNumber++;for(var i=0;i<len;i++){var component=dirtyComponents[i],callbacks=component._pendingCallbacks;\ncomponent._pendingCallbacks=null;if(ReactFeatureFlags.logTopLevelRenders){var markerName=component;component._currentElement.props===component._renderedComponent._currentElement&&(markerName=component._renderedComponent);markerName=\"React update: \"+markerName.getName();console.time(markerName)}ReactReconciler.performUpdateIfNecessary(component,transaction.reconcileTransaction,updateBatchNumber);markerName&&console.timeEnd(markerName);if(callbacks)for(var j=0;j<callbacks.length;j++)transaction.callbackQueue.enqueue(callbacks[j],\ncomponent.getPublicInstance())}}function enqueueUpdate(component){ensureInjected();batchingStrategy.isBatchingUpdates?(dirtyComponents.push(component),null==component._updateBatchNumber&&(component._updateBatchNumber=updateBatchNumber+1)):batchingStrategy.batchedUpdates(enqueueUpdate,component)}require(\"module$node_modules$react$lib$reactProdInvariant\");global=require(\"module$node_modules$object_assign$index\");var CallbackQueue=require(\"module$node_modules$react$lib$CallbackQueue\");exports=require(\"module$node_modules$react$lib$PooledClass\");\nvar ReactFeatureFlags=require(\"module$node_modules$react$lib$ReactFeatureFlags\"),ReactReconciler=require(\"module$node_modules$react$lib$ReactReconciler\"),Transaction=require(\"module$node_modules$react$lib$Transaction\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),dirtyComponents=[],updateBatchNumber=0,asapCallbackQueue=CallbackQueue.getPooled(),asapEnqueued=!1,batchingStrategy=null,TRANSACTION_WRAPPERS=[{initialize:function(){this.dirtyComponentsLength=dirtyComponents.length},close:function(){this.dirtyComponentsLength!==\ndirtyComponents.length?(dirtyComponents.splice(0,this.dirtyComponentsLength),flushBatchedUpdates()):dirtyComponents.length=0}},{initialize:function(){this.callbackQueue.reset()},close:function(){this.callbackQueue.notifyAll()}}];global(ReactUpdatesFlushTransaction.prototype,Transaction.Mixin,{getTransactionWrappers:function(){return TRANSACTION_WRAPPERS},destructor:function(){this.dirtyComponentsLength=null;CallbackQueue.release(this.callbackQueue);this.callbackQueue=null;ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\nthis.reconcileTransaction=null},perform:function(method,scope,a){return Transaction.Mixin.perform.call(this,this.reconcileTransaction.perform,this.reconcileTransaction,method,scope,a)}});exports.addPoolingTo(ReactUpdatesFlushTransaction);var flushBatchedUpdates=function(){for(;dirtyComponents.length||asapEnqueued;){if(dirtyComponents.length){var transaction=ReactUpdatesFlushTransaction.getPooled();transaction.perform(runBatchedUpdates,null,transaction);ReactUpdatesFlushTransaction.release(transaction)}asapEnqueued&&\n(asapEnqueued=!1,transaction=asapCallbackQueue,asapCallbackQueue=CallbackQueue.getPooled(),transaction.notifyAll(),CallbackQueue.release(transaction))}},ReactUpdates={ReactReconcileTransaction:null,batchedUpdates:function(callback,a,b,c,d,e){ensureInjected();batchingStrategy.batchedUpdates(callback,a,b,c,d,e)},enqueueUpdate,flushBatchedUpdates,injection:{injectReconcileTransaction:function(ReconcileTransaction){ReconcileTransaction?void 0:invariant(!1,\"ReactUpdates: must provide a reconcile transaction class\");\nReactUpdates.ReactReconcileTransaction=ReconcileTransaction},injectBatchingStrategy:function(_batchingStrategy){_batchingStrategy?void 0:invariant(!1,\"ReactUpdates: must provide a batching strategy\");\"function\"!==typeof _batchingStrategy.batchedUpdates?invariant(!1,\"ReactUpdates: must provide a batchedUpdates() function\"):void 0;\"boolean\"!==typeof _batchingStrategy.isBatchingUpdates?invariant(!1,\"ReactUpdates: must provide an isBatchingUpdates boolean attribute\"):void 0;batchingStrategy=_batchingStrategy}},\nasap:function(callback,context){batchingStrategy.isBatchingUpdates?void 0:invariant(!1,\"ReactUpdates.asap: Can't enqueue an asap callback in a context whereupdates are not being batched.\");asapCallbackQueue.enqueue(callback,context);asapEnqueued=!0}};module.exports=ReactUpdates}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactUpdates\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n    _assign = require('object-assign');\n\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar updateBatchNumber = 0;\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* useCreateElement */true);\n}\n\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    var markerName;\n    if (ReactFeatureFlags.logTopLevelRenders) {\n      var namedComponent = component;\n      // Duck type TopLevelWrapper. This is probably always true.\n      if (component._currentElement.props === component._renderedComponent._currentElement) {\n        namedComponent = component._renderedComponent;\n      }\n      markerName = 'React update: ' + namedComponent.getName();\n      console.time(markerName);\n    }\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\n\n    if (markerName) {\n      console.timeEnd(markerName);\n    }\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$lib$CallbackQueue","~$module$node_modules$object_assign$index","~$module$node_modules$react$lib$ReactFeatureFlags","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react$lib$reactProdInvariant","~$module$node_modules$react$lib$ReactReconciler","~$module$node_modules$react$lib$PooledClass","~$module$node_modules$react$lib$Transaction"]],"~:properties",["^5",["flushBatchedUpdates","injection","enqueueUpdate","_updateBatchNumber","batchedUpdates","_pendingCallbacks","getTransactionWrappers","reconcileTransaction","asap","injectReconcileTransaction","length","close","perform","ReactReconcileTransaction","initialize","destructor","callbackQueue","injectBatchingStrategy","dirtyComponentsLength"]],"~:compiled-at",1635250628389,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactUpdates.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/ReactUpdates.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactUpdates\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule ReactUpdates\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant'),\\n    _assign = require('object-assign');\\n\\nvar CallbackQueue = require('./CallbackQueue');\\nvar PooledClass = require('./PooledClass');\\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\\nvar ReactReconciler = require('./ReactReconciler');\\nvar Transaction = require('./Transaction');\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\nvar dirtyComponents = [];\\nvar updateBatchNumber = 0;\\nvar asapCallbackQueue = CallbackQueue.getPooled();\\nvar asapEnqueued = false;\\n\\nvar batchingStrategy = null;\\n\\nfunction ensureInjected() {\\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\\n}\\n\\nvar NESTED_UPDATES = {\\n  initialize: function () {\\n    this.dirtyComponentsLength = dirtyComponents.length;\\n  },\\n  close: function () {\\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\\n      // Additional updates were enqueued by componentDidUpdate handlers or\\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\\n      // these new updates so that if A's componentDidUpdate calls setState on\\n      // B, B will update before the callback A's updater provided when calling\\n      // setState.\\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\\n      flushBatchedUpdates();\\n    } else {\\n      dirtyComponents.length = 0;\\n    }\\n  }\\n};\\n\\nvar UPDATE_QUEUEING = {\\n  initialize: function () {\\n    this.callbackQueue.reset();\\n  },\\n  close: function () {\\n    this.callbackQueue.notifyAll();\\n  }\\n};\\n\\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\\n\\nfunction ReactUpdatesFlushTransaction() {\\n  this.reinitializeTransaction();\\n  this.dirtyComponentsLength = null;\\n  this.callbackQueue = CallbackQueue.getPooled();\\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\\n  /* useCreateElement */true);\\n}\\n\\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\\n  getTransactionWrappers: function () {\\n    return TRANSACTION_WRAPPERS;\\n  },\\n\\n  destructor: function () {\\n    this.dirtyComponentsLength = null;\\n    CallbackQueue.release(this.callbackQueue);\\n    this.callbackQueue = null;\\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\\n    this.reconcileTransaction = null;\\n  },\\n\\n  perform: function (method, scope, a) {\\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\\n    // with this transaction's wrappers around it.\\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\\n  }\\n});\\n\\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\\n\\nfunction batchedUpdates(callback, a, b, c, d, e) {\\n  ensureInjected();\\n  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\\n}\\n\\n/**\\n * Array comparator for ReactComponents by mount ordering.\\n *\\n * @param {ReactComponent} c1 first component you're comparing\\n * @param {ReactComponent} c2 second component you're comparing\\n * @return {number} Return value usable by Array.prototype.sort().\\n */\\nfunction mountOrderComparator(c1, c2) {\\n  return c1._mountOrder - c2._mountOrder;\\n}\\n\\nfunction runBatchedUpdates(transaction) {\\n  var len = transaction.dirtyComponentsLength;\\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;\\n\\n  // Since reconciling a component higher in the owner hierarchy usually (not\\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\\n  // them before their children by sorting the array.\\n  dirtyComponents.sort(mountOrderComparator);\\n\\n  // Any updates enqueued while reconciling must be performed after this entire\\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\\n  // C, B could update twice in a single batch if C's render enqueues an update\\n  // to B (since B would have already updated, we should skip it, and the only\\n  // way we can know to do so is by checking the batch counter).\\n  updateBatchNumber++;\\n\\n  for (var i = 0; i < len; i++) {\\n    // If a component is unmounted before pending changes apply, it will still\\n    // be here, but we assume that it has cleared its _pendingCallbacks and\\n    // that performUpdateIfNecessary is a noop.\\n    var component = dirtyComponents[i];\\n\\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\\n    // shouldn't execute the callbacks until the next render happens, so\\n    // stash the callbacks first\\n    var callbacks = component._pendingCallbacks;\\n    component._pendingCallbacks = null;\\n\\n    var markerName;\\n    if (ReactFeatureFlags.logTopLevelRenders) {\\n      var namedComponent = component;\\n      // Duck type TopLevelWrapper. This is probably always true.\\n      if (component._currentElement.props === component._renderedComponent._currentElement) {\\n        namedComponent = component._renderedComponent;\\n      }\\n      markerName = 'React update: ' + namedComponent.getName();\\n      console.time(markerName);\\n    }\\n\\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\\n\\n    if (markerName) {\\n      console.timeEnd(markerName);\\n    }\\n\\n    if (callbacks) {\\n      for (var j = 0; j < callbacks.length; j++) {\\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\\n      }\\n    }\\n  }\\n}\\n\\nvar flushBatchedUpdates = function () {\\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\\n  // componentDidUpdate) but we need to check here too in order to catch\\n  // updates enqueued by setState callbacks and asap calls.\\n  while (dirtyComponents.length || asapEnqueued) {\\n    if (dirtyComponents.length) {\\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\\n      transaction.perform(runBatchedUpdates, null, transaction);\\n      ReactUpdatesFlushTransaction.release(transaction);\\n    }\\n\\n    if (asapEnqueued) {\\n      asapEnqueued = false;\\n      var queue = asapCallbackQueue;\\n      asapCallbackQueue = CallbackQueue.getPooled();\\n      queue.notifyAll();\\n      CallbackQueue.release(queue);\\n    }\\n  }\\n};\\n\\n/**\\n * Mark a component as needing a rerender, adding an optional callback to a\\n * list of functions which will be executed once the rerender occurs.\\n */\\nfunction enqueueUpdate(component) {\\n  ensureInjected();\\n\\n  // Various parts of our code (such as ReactCompositeComponent's\\n  // _renderValidatedComponent) assume that calls to render aren't nested;\\n  // verify that that's the case. (This is called by each top-level update\\n  // function, like setState, forceUpdate, etc.; creation and\\n  // destruction of top-level components is guarded in ReactMount.)\\n\\n  if (!batchingStrategy.isBatchingUpdates) {\\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\\n    return;\\n  }\\n\\n  dirtyComponents.push(component);\\n  if (component._updateBatchNumber == null) {\\n    component._updateBatchNumber = updateBatchNumber + 1;\\n  }\\n}\\n\\n/**\\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\\n * if no updates are currently being performed.\\n */\\nfunction asap(callback, context) {\\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\\\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;\\n  asapCallbackQueue.enqueue(callback, context);\\n  asapEnqueued = true;\\n}\\n\\nvar ReactUpdatesInjection = {\\n  injectReconcileTransaction: function (ReconcileTransaction) {\\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\\n  },\\n\\n  injectBatchingStrategy: function (_batchingStrategy) {\\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\\n    batchingStrategy = _batchingStrategy;\\n  }\\n};\\n\\nvar ReactUpdates = {\\n  /**\\n   * React references `ReactReconcileTransaction` using this property in order\\n   * to allow dependency injection.\\n   *\\n   * @internal\\n   */\\n  ReactReconcileTransaction: null,\\n\\n  batchedUpdates: batchedUpdates,\\n  enqueueUpdate: enqueueUpdate,\\n  flushBatchedUpdates: flushBatchedUpdates,\\n  injection: ReactUpdatesInjection,\\n  asap: asap\\n};\\n\\nmodule.exports = ReactUpdates;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ensureInjected\",\"ReactUpdates\",\"ReactReconcileTransaction\",\"batchingStrategy\",\"invariant\",\"ReactUpdatesFlushTransaction\",\"reinitializeTransaction\",\"dirtyComponentsLength\",\"callbackQueue\",\"CallbackQueue\",\"getPooled\",\"reconcileTransaction\",\"mountOrderComparator\",\"c1\",\"c2\",\"_mountOrder\",\"runBatchedUpdates\",\"transaction\",\"len\",\"dirtyComponents\",\"length\",\"sort\",\"updateBatchNumber\",\"i\",\"component\",\"callbacks\",\"_pendingCallbacks\",\"ReactFeatureFlags\",\"logTopLevelRenders\",\"namedComponent\",\"_currentElement\",\"props\",\"_renderedComponent\",\"markerName\",\"getName\",\"console\",\"time\",\"ReactReconciler\",\"performUpdateIfNecessary\",\"timeEnd\",\"j\",\"enqueue\",\"getPublicInstance\",\"enqueueUpdate\",\"isBatchingUpdates\",\"push\",\"_updateBatchNumber\",\"batchedUpdates\",\"_assign\",\"PooledClass\",\"Transaction\",\"asapCallbackQueue\",\"asapEnqueued\",\"TRANSACTION_WRAPPERS\",\"NESTED_UPDATES\",\"initialize\",\"close\",\"splice\",\"flushBatchedUpdates\",\"UPDATE_QUEUEING\",\"reset\",\"notifyAll\",\"prototype\",\"Mixin\",\"getTransactionWrappers\",\"destructor\",\"release\",\"perform\",\"method\",\"scope\",\"a\",\"call\",\"addPoolingTo\",\"queue\",\"callback\",\"b\",\"c\",\"d\",\"e\",\"injection\",\"ReactUpdatesInjection\",\"injectReconcileTransaction\",\"ReconcileTransaction\",\"injectBatchingStrategy\",\"_batchingStrategy\",\"asap\",\"context\"]\n}\n"]