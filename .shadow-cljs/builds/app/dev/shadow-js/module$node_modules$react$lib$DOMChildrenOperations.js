["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/DOMChildrenOperations.js"],"~:js","shadow$provide.module$node_modules$react$lib$DOMChildrenOperations=function(global,require,module,exports){function getNodeAfter(parentNode,node){Array.isArray(node)&&(node=node[1]);return node?node.nextSibling:parentNode.firstChild}function removeDelimitedText(parentNode,startNode,closingComment){for(;;){var node=startNode.nextSibling;if(node===closingComment)break;else parentNode.removeChild(node)}}var DOMLazyTree=require(\"module$node_modules$react$lib$DOMLazyTree\"),Danger=require(\"module$node_modules$react$lib$Danger\"),\nReactMultiChildUpdateTypes=require(\"module$node_modules$react$lib$ReactMultiChildUpdateTypes\"),ReactDOMComponentTree=require(\"module$node_modules$react$lib$ReactDOMComponentTree\"),ReactInstrumentation=require(\"module$node_modules$react$lib$ReactInstrumentation\");global=require(\"module$node_modules$react$lib$createMicrosoftUnsafeLocalFunction\");var setInnerHTML=require(\"module$node_modules$react$lib$setInnerHTML\"),setTextContent=require(\"module$node_modules$react$lib$setTextContent\"),insertChildAt=\nglobal(function(parentNode,childNode,referenceNode){parentNode.insertBefore(childNode,referenceNode)});require=Danger.dangerouslyReplaceNodeWithMarkup;require=function(oldChild,markup,prevInstance){Danger.dangerouslyReplaceNodeWithMarkup(oldChild,markup);if(0!==prevInstance._debugID)ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID,\"replace with\",markup.toString());else if(oldChild=ReactDOMComponentTree.getInstanceFromNode(markup.node),0!==oldChild._debugID)ReactInstrumentation.debugTool.onHostOperation(oldChild._debugID,\n\"mount\",markup.toString())};module.exports={dangerouslyReplaceNodeWithMarkup:require,replaceDelimitedText:function(openingComment,closingComment,stringText){var parentNode=openingComment.parentNode,nodeAfterComment=openingComment.nextSibling;nodeAfterComment===closingComment?stringText&&insertChildAt(parentNode,document.createTextNode(stringText),nodeAfterComment):stringText?(setTextContent(nodeAfterComment,stringText),removeDelimitedText(parentNode,nodeAfterComment,closingComment)):removeDelimitedText(parentNode,\nopeningComment,closingComment);ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,\"replace text\",stringText)},processUpdates:function(parentNode,updates){for(var parentNodeDebugID=ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID,k=0;k<updates.length;k++){var update=updates[k];switch(update.type){case ReactMultiChildUpdateTypes.INSERT_MARKUP:var referenceNode=getNodeAfter(parentNode,update.afterNode);DOMLazyTree.insertTreeBefore(parentNode,\nupdate.content,referenceNode);ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID,\"insert child\",{toIndex:update.toIndex,content:update.content.toString()});break;case ReactMultiChildUpdateTypes.MOVE_EXISTING:referenceNode=parentNode;var childNode=update.fromNode,referenceNode$jscomp$0=getNodeAfter(parentNode,update.afterNode);if(Array.isArray(childNode)){var closingComment=childNode[1];for(childNode=childNode[0];;){var nextNode=childNode.nextSibling;insertChildAt(referenceNode,childNode,\nreferenceNode$jscomp$0);if(childNode===closingComment)break;childNode=nextNode}}else insertChildAt(referenceNode,childNode,referenceNode$jscomp$0);ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID,\"move child\",{fromIndex:update.fromIndex,toIndex:update.toIndex});break;case ReactMultiChildUpdateTypes.SET_MARKUP:setInnerHTML(parentNode,update.content);ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID,\"replace children\",update.content.toString());break;case ReactMultiChildUpdateTypes.TEXT_CONTENT:setTextContent(parentNode,\nupdate.content);ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID,\"replace text\",update.content.toString());break;case ReactMultiChildUpdateTypes.REMOVE_NODE:referenceNode=parentNode,closingComment=update.fromNode,Array.isArray(closingComment)&&(childNode=closingComment[1],closingComment=closingComment[0],removeDelimitedText(referenceNode,closingComment,childNode),referenceNode.removeChild(childNode)),referenceNode.removeChild(closingComment),ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID,\n\"remove child\",{fromIndex:update.fromIndex})}}}}}","~:source","shadow$provide[\"module$node_modules$react$lib$DOMChildrenOperations\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMChildrenOperations\n */\n\n'use strict';\n\nvar DOMLazyTree = require('./DOMLazyTree');\nvar Danger = require('./Danger');\nvar ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\nvar ReactInstrumentation = require('./ReactInstrumentation');\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\nvar setInnerHTML = require('./setInnerHTML');\nvar setTextContent = require('./setTextContent');\n\nfunction getNodeAfter(parentNode, node) {\n  // Special case for text components, which return [open, close] comments\n  // from getHostNode.\n  if (Array.isArray(node)) {\n    node = node[1];\n  }\n  return node ? node.nextSibling : parentNode.firstChild;\n}\n\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\nvar insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {\n  // We rely exclusively on `insertBefore(node, null)` instead of also using\n  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so\n  // we are careful to use `null`.)\n  parentNode.insertBefore(childNode, referenceNode);\n});\n\nfunction insertLazyTreeChildAt(parentNode, childTree, referenceNode) {\n  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);\n}\n\nfunction moveChild(parentNode, childNode, referenceNode) {\n  if (Array.isArray(childNode)) {\n    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);\n  } else {\n    insertChildAt(parentNode, childNode, referenceNode);\n  }\n}\n\nfunction removeChild(parentNode, childNode) {\n  if (Array.isArray(childNode)) {\n    var closingComment = childNode[1];\n    childNode = childNode[0];\n    removeDelimitedText(parentNode, childNode, closingComment);\n    parentNode.removeChild(closingComment);\n  }\n  parentNode.removeChild(childNode);\n}\n\nfunction moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {\n  var node = openingComment;\n  while (true) {\n    var nextNode = node.nextSibling;\n    insertChildAt(parentNode, node, referenceNode);\n    if (node === closingComment) {\n      break;\n    }\n    node = nextNode;\n  }\n}\n\nfunction removeDelimitedText(parentNode, startNode, closingComment) {\n  while (true) {\n    var node = startNode.nextSibling;\n    if (node === closingComment) {\n      // The closing comment is removed by ReactMultiChild.\n      break;\n    } else {\n      parentNode.removeChild(node);\n    }\n  }\n}\n\nfunction replaceDelimitedText(openingComment, closingComment, stringText) {\n  var parentNode = openingComment.parentNode;\n  var nodeAfterComment = openingComment.nextSibling;\n  if (nodeAfterComment === closingComment) {\n    // There are no text nodes between the opening and closing comments; insert\n    // a new one if stringText isn't empty.\n    if (stringText) {\n      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);\n    }\n  } else {\n    if (stringText) {\n      // Set the text content of the first node after the opening comment, and\n      // remove all following nodes up until the closing comment.\n      setTextContent(nodeAfterComment, stringText);\n      removeDelimitedText(parentNode, nodeAfterComment, closingComment);\n    } else {\n      removeDelimitedText(parentNode, openingComment, closingComment);\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);\n  }\n}\n\nvar dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;\nif (process.env.NODE_ENV !== 'production') {\n  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {\n    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);\n    if (prevInstance._debugID !== 0) {\n      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());\n    } else {\n      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);\n      if (nextInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());\n      }\n    }\n  };\n}\n\n/**\n * Operations for updating with DOM children.\n */\nvar DOMChildrenOperations = {\n\n  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,\n\n  replaceDelimitedText: replaceDelimitedText,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @internal\n   */\n  processUpdates: function (parentNode, updates) {\n    if (process.env.NODE_ENV !== 'production') {\n      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;\n    }\n\n    for (var k = 0; k < updates.length; k++) {\n      var update = updates[k];\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));\n          if (process.env.NODE_ENV !== 'production') {\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });\n          }\n          break;\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));\n          if (process.env.NODE_ENV !== 'production') {\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });\n          }\n          break;\n        case ReactMultiChildUpdateTypes.SET_MARKUP:\n          setInnerHTML(parentNode, update.content);\n          if (process.env.NODE_ENV !== 'production') {\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());\n          }\n          break;\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          setTextContent(parentNode, update.content);\n          if (process.env.NODE_ENV !== 'production') {\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());\n          }\n          break;\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          removeChild(parentNode, update.fromNode);\n          if (process.env.NODE_ENV !== 'production') {\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });\n          }\n          break;\n      }\n    }\n  }\n\n};\n\nmodule.exports = DOMChildrenOperations;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$lib$createMicrosoftUnsafeLocalFunction","~$module$node_modules$react$lib$ReactDOMComponentTree","~$module$node_modules$react$lib$setTextContent","~$module$node_modules$react$lib$ReactMultiChildUpdateTypes","~$shadow.js","~$module$node_modules$react$lib$setInnerHTML","~$module$node_modules$react$lib$Danger","~$module$node_modules$react$lib$DOMLazyTree","~$module$node_modules$react$lib$ReactInstrumentation"]],"~:properties",["^5",["replaceDelimitedText","toIndex","dangerouslyReplaceNodeWithMarkup","fromIndex","processUpdates","content"]],"~:compiled-at",1635250628394,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$DOMChildrenOperations.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/DOMChildrenOperations.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$DOMChildrenOperations\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule DOMChildrenOperations\\n */\\n\\n'use strict';\\n\\nvar DOMLazyTree = require('./DOMLazyTree');\\nvar Danger = require('./Danger');\\nvar ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');\\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\n\\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\\nvar setInnerHTML = require('./setInnerHTML');\\nvar setTextContent = require('./setTextContent');\\n\\nfunction getNodeAfter(parentNode, node) {\\n  // Special case for text components, which return [open, close] comments\\n  // from getHostNode.\\n  if (Array.isArray(node)) {\\n    node = node[1];\\n  }\\n  return node ? node.nextSibling : parentNode.firstChild;\\n}\\n\\n/**\\n * Inserts `childNode` as a child of `parentNode` at the `index`.\\n *\\n * @param {DOMElement} parentNode Parent node in which to insert.\\n * @param {DOMElement} childNode Child node to insert.\\n * @param {number} index Index at which to insert the child.\\n * @internal\\n */\\nvar insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {\\n  // We rely exclusively on `insertBefore(node, null)` instead of also using\\n  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so\\n  // we are careful to use `null`.)\\n  parentNode.insertBefore(childNode, referenceNode);\\n});\\n\\nfunction insertLazyTreeChildAt(parentNode, childTree, referenceNode) {\\n  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);\\n}\\n\\nfunction moveChild(parentNode, childNode, referenceNode) {\\n  if (Array.isArray(childNode)) {\\n    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);\\n  } else {\\n    insertChildAt(parentNode, childNode, referenceNode);\\n  }\\n}\\n\\nfunction removeChild(parentNode, childNode) {\\n  if (Array.isArray(childNode)) {\\n    var closingComment = childNode[1];\\n    childNode = childNode[0];\\n    removeDelimitedText(parentNode, childNode, closingComment);\\n    parentNode.removeChild(closingComment);\\n  }\\n  parentNode.removeChild(childNode);\\n}\\n\\nfunction moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {\\n  var node = openingComment;\\n  while (true) {\\n    var nextNode = node.nextSibling;\\n    insertChildAt(parentNode, node, referenceNode);\\n    if (node === closingComment) {\\n      break;\\n    }\\n    node = nextNode;\\n  }\\n}\\n\\nfunction removeDelimitedText(parentNode, startNode, closingComment) {\\n  while (true) {\\n    var node = startNode.nextSibling;\\n    if (node === closingComment) {\\n      // The closing comment is removed by ReactMultiChild.\\n      break;\\n    } else {\\n      parentNode.removeChild(node);\\n    }\\n  }\\n}\\n\\nfunction replaceDelimitedText(openingComment, closingComment, stringText) {\\n  var parentNode = openingComment.parentNode;\\n  var nodeAfterComment = openingComment.nextSibling;\\n  if (nodeAfterComment === closingComment) {\\n    // There are no text nodes between the opening and closing comments; insert\\n    // a new one if stringText isn't empty.\\n    if (stringText) {\\n      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);\\n    }\\n  } else {\\n    if (stringText) {\\n      // Set the text content of the first node after the opening comment, and\\n      // remove all following nodes up until the closing comment.\\n      setTextContent(nodeAfterComment, stringText);\\n      removeDelimitedText(parentNode, nodeAfterComment, closingComment);\\n    } else {\\n      removeDelimitedText(parentNode, openingComment, closingComment);\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);\\n  }\\n}\\n\\nvar dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;\\nif (process.env.NODE_ENV !== 'production') {\\n  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {\\n    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);\\n    if (prevInstance._debugID !== 0) {\\n      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());\\n    } else {\\n      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);\\n      if (nextInstance._debugID !== 0) {\\n        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());\\n      }\\n    }\\n  };\\n}\\n\\n/**\\n * Operations for updating with DOM children.\\n */\\nvar DOMChildrenOperations = {\\n\\n  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,\\n\\n  replaceDelimitedText: replaceDelimitedText,\\n\\n  /**\\n   * Updates a component's children by processing a series of updates. The\\n   * update configurations are each expected to have a `parentNode` property.\\n   *\\n   * @param {array<object>} updates List of update configurations.\\n   * @internal\\n   */\\n  processUpdates: function (parentNode, updates) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;\\n    }\\n\\n    for (var k = 0; k < updates.length; k++) {\\n      var update = updates[k];\\n      switch (update.type) {\\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\\n          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));\\n          if (process.env.NODE_ENV !== 'production') {\\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });\\n          }\\n          break;\\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\\n          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));\\n          if (process.env.NODE_ENV !== 'production') {\\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });\\n          }\\n          break;\\n        case ReactMultiChildUpdateTypes.SET_MARKUP:\\n          setInnerHTML(parentNode, update.content);\\n          if (process.env.NODE_ENV !== 'production') {\\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());\\n          }\\n          break;\\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\\n          setTextContent(parentNode, update.content);\\n          if (process.env.NODE_ENV !== 'production') {\\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());\\n          }\\n          break;\\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\\n          removeChild(parentNode, update.fromNode);\\n          if (process.env.NODE_ENV !== 'production') {\\n            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });\\n          }\\n          break;\\n      }\\n    }\\n  }\\n\\n};\\n\\nmodule.exports = DOMChildrenOperations;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getNodeAfter\",\"parentNode\",\"node\",\"Array\",\"isArray\",\"nextSibling\",\"firstChild\",\"removeDelimitedText\",\"startNode\",\"closingComment\",\"removeChild\",\"DOMLazyTree\",\"Danger\",\"ReactMultiChildUpdateTypes\",\"ReactDOMComponentTree\",\"ReactInstrumentation\",\"createMicrosoftUnsafeLocalFunction\",\"setInnerHTML\",\"setTextContent\",\"insertChildAt\",\"childNode\",\"referenceNode\",\"insertBefore\",\"dangerouslyReplaceNodeWithMarkup\",\"oldChild\",\"markup\",\"prevInstance\",\"_debugID\",\"debugTool\",\"onHostOperation\",\"toString\",\"nextInstance\",\"getInstanceFromNode\",\"DOMChildrenOperations\",\"replaceDelimitedText\",\"openingComment\",\"stringText\",\"nodeAfterComment\",\"document\",\"createTextNode\",\"processUpdates\",\"updates\",\"parentNodeDebugID\",\"k\",\"length\",\"update\",\"type\",\"INSERT_MARKUP\",\"afterNode\",\"insertTreeBefore\",\"content\",\"toIndex\",\"MOVE_EXISTING\",\"fromNode\",\"nextNode\",\"fromIndex\",\"SET_MARKUP\",\"TEXT_CONTENT\",\"REMOVE_NODE\"]\n}\n"]