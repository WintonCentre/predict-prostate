["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactUpdates.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactUpdates=function(global,process,require,module,exports,shadow$shims){function ensureInjected(){ReactUpdates.ReactReconcileTransaction&&batchingStrategy?void 0:invariant(!1,\"ReactUpdates: must inject a reconcile transaction class and batching strategy\")}function ReactUpdatesFlushTransaction(){this.reinitializeTransaction();this.dirtyComponentsLength=null;this.callbackQueue=CallbackQueue.getPooled();this.reconcileTransaction=ReactUpdates.ReactReconcileTransaction.getPooled(!0)}\nfunction mountOrderComparator(c1,c2){return c1._mountOrder-c2._mountOrder}function runBatchedUpdates(transaction){var len=transaction.dirtyComponentsLength;len!==dirtyComponents.length?invariant(!1,\"Expected flush transaction's stored dirty-components length (%s) to match dirty-components array length (%s).\",len,dirtyComponents.length):void 0;dirtyComponents.sort(mountOrderComparator);updateBatchNumber++;for(var i=0;i<len;i++){var component=dirtyComponents[i],callbacks=component._pendingCallbacks;\ncomponent._pendingCallbacks=null;if(ReactFeatureFlags.logTopLevelRenders){var markerName=component;component._currentElement.type.isReactTopLevelWrapper&&(markerName=component._renderedComponent);markerName=\"React update: \"+markerName.getName();console.time(markerName)}ReactReconciler.performUpdateIfNecessary(component,transaction.reconcileTransaction,updateBatchNumber);markerName&&console.timeEnd(markerName);if(callbacks)for(var j=0;j<callbacks.length;j++)transaction.callbackQueue.enqueue(callbacks[j],\ncomponent.getPublicInstance())}}function enqueueUpdate(component){ensureInjected();batchingStrategy.isBatchingUpdates?(dirtyComponents.push(component),null==component._updateBatchNumber&&(component._updateBatchNumber=updateBatchNumber+1)):batchingStrategy.batchedUpdates(enqueueUpdate,component)}require(\"module$node_modules$react_dom$lib$reactProdInvariant\");global=require(\"module$node_modules$object_assign$index\");var CallbackQueue=require(\"module$node_modules$react_dom$lib$CallbackQueue\");process=\nrequire(\"module$node_modules$react_dom$lib$PooledClass\");var ReactFeatureFlags=require(\"module$node_modules$react_dom$lib$ReactFeatureFlags\"),ReactReconciler=require(\"module$node_modules$react_dom$lib$ReactReconciler\"),Transaction=require(\"module$node_modules$react_dom$lib$Transaction\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),dirtyComponents=[],updateBatchNumber=0,asapCallbackQueue=CallbackQueue.getPooled(),asapEnqueued=!1,batchingStrategy=null,TRANSACTION_WRAPPERS=[{initialize:function(){this.dirtyComponentsLength=\ndirtyComponents.length},close:function(){this.dirtyComponentsLength!==dirtyComponents.length?(dirtyComponents.splice(0,this.dirtyComponentsLength),flushBatchedUpdates()):dirtyComponents.length=0}},{initialize:function(){this.callbackQueue.reset()},close:function(){this.callbackQueue.notifyAll()}}];global(ReactUpdatesFlushTransaction.prototype,Transaction,{getTransactionWrappers:function(){return TRANSACTION_WRAPPERS},destructor:function(){this.dirtyComponentsLength=null;CallbackQueue.release(this.callbackQueue);\nthis.callbackQueue=null;ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);this.reconcileTransaction=null},perform:function(method,scope,a){return Transaction.perform.call(this,this.reconcileTransaction.perform,this.reconcileTransaction,method,scope,a)}});process.addPoolingTo(ReactUpdatesFlushTransaction);var flushBatchedUpdates=function(){for(;dirtyComponents.length||asapEnqueued;){if(dirtyComponents.length){var transaction=ReactUpdatesFlushTransaction.getPooled();transaction.perform(runBatchedUpdates,\nnull,transaction);ReactUpdatesFlushTransaction.release(transaction)}asapEnqueued&&(asapEnqueued=!1,transaction=asapCallbackQueue,asapCallbackQueue=CallbackQueue.getPooled(),transaction.notifyAll(),CallbackQueue.release(transaction))}},ReactUpdates={ReactReconcileTransaction:null,batchedUpdates:function(callback,a,b,c,d,e){ensureInjected();return batchingStrategy.batchedUpdates(callback,a,b,c,d,e)},enqueueUpdate:enqueueUpdate,flushBatchedUpdates:flushBatchedUpdates,injection:{injectReconcileTransaction:function(ReconcileTransaction){ReconcileTransaction?\nvoid 0:invariant(!1,\"ReactUpdates: must provide a reconcile transaction class\");ReactUpdates.ReactReconcileTransaction=ReconcileTransaction},injectBatchingStrategy:function(_batchingStrategy){_batchingStrategy?void 0:invariant(!1,\"ReactUpdates: must provide a batching strategy\");\"function\"!==typeof _batchingStrategy.batchedUpdates?invariant(!1,\"ReactUpdates: must provide a batchedUpdates() function\"):void 0;\"boolean\"!==typeof _batchingStrategy.isBatchingUpdates?invariant(!1,\"ReactUpdates: must provide an isBatchingUpdates boolean attribute\"):\nvoid 0;batchingStrategy=_batchingStrategy}},asap:function(callback,context){batchingStrategy.isBatchingUpdates?void 0:invariant(!1,\"ReactUpdates.asap: Can't enqueue an asap callback in a context whereupdates are not being batched.\");asapCallbackQueue.enqueue(callback,context);asapEnqueued=!0}};module.exports=ReactUpdates}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactUpdates\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n    _assign = require('object-assign');\n\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar updateBatchNumber = 0;\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* useCreateElement */true);\n}\n\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    var markerName;\n    if (ReactFeatureFlags.logTopLevelRenders) {\n      var namedComponent = component;\n      // Duck type TopLevelWrapper. This is probably always true.\n      if (component._currentElement.type.isReactTopLevelWrapper) {\n        namedComponent = component._renderedComponent;\n      }\n      markerName = 'React update: ' + namedComponent.getName();\n      console.time(markerName);\n    }\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\n\n    if (markerName) {\n      console.timeEnd(markerName);\n    }\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$object_assign$index","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react_dom$lib$PooledClass","~$module$node_modules$react_dom$lib$ReactFeatureFlags","~$module$node_modules$react_dom$lib$reactProdInvariant","~$module$node_modules$react_dom$lib$ReactReconciler","~$module$node_modules$react_dom$lib$CallbackQueue","~$module$node_modules$react_dom$lib$Transaction"]],"~:properties",["^5",["flushBatchedUpdates","injection","enqueueUpdate","_updateBatchNumber","batchedUpdates","_pendingCallbacks","getTransactionWrappers","reconcileTransaction","asap","injectReconcileTransaction","length","close","perform","ReactReconcileTransaction","initialize","destructor","callbackQueue","injectBatchingStrategy","dirtyComponentsLength"]],"~:compiled-at",1635270336825,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactUpdates.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/ReactUpdates.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactUpdates\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant'),\\n    _assign = require('object-assign');\\n\\nvar CallbackQueue = require('./CallbackQueue');\\nvar PooledClass = require('./PooledClass');\\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\\nvar ReactReconciler = require('./ReactReconciler');\\nvar Transaction = require('./Transaction');\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\nvar dirtyComponents = [];\\nvar updateBatchNumber = 0;\\nvar asapCallbackQueue = CallbackQueue.getPooled();\\nvar asapEnqueued = false;\\n\\nvar batchingStrategy = null;\\n\\nfunction ensureInjected() {\\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\\n}\\n\\nvar NESTED_UPDATES = {\\n  initialize: function () {\\n    this.dirtyComponentsLength = dirtyComponents.length;\\n  },\\n  close: function () {\\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\\n      // Additional updates were enqueued by componentDidUpdate handlers or\\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\\n      // these new updates so that if A's componentDidUpdate calls setState on\\n      // B, B will update before the callback A's updater provided when calling\\n      // setState.\\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\\n      flushBatchedUpdates();\\n    } else {\\n      dirtyComponents.length = 0;\\n    }\\n  }\\n};\\n\\nvar UPDATE_QUEUEING = {\\n  initialize: function () {\\n    this.callbackQueue.reset();\\n  },\\n  close: function () {\\n    this.callbackQueue.notifyAll();\\n  }\\n};\\n\\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\\n\\nfunction ReactUpdatesFlushTransaction() {\\n  this.reinitializeTransaction();\\n  this.dirtyComponentsLength = null;\\n  this.callbackQueue = CallbackQueue.getPooled();\\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\\n  /* useCreateElement */true);\\n}\\n\\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {\\n  getTransactionWrappers: function () {\\n    return TRANSACTION_WRAPPERS;\\n  },\\n\\n  destructor: function () {\\n    this.dirtyComponentsLength = null;\\n    CallbackQueue.release(this.callbackQueue);\\n    this.callbackQueue = null;\\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\\n    this.reconcileTransaction = null;\\n  },\\n\\n  perform: function (method, scope, a) {\\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\\n    // with this transaction's wrappers around it.\\n    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\\n  }\\n});\\n\\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\\n\\nfunction batchedUpdates(callback, a, b, c, d, e) {\\n  ensureInjected();\\n  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\\n}\\n\\n/**\\n * Array comparator for ReactComponents by mount ordering.\\n *\\n * @param {ReactComponent} c1 first component you're comparing\\n * @param {ReactComponent} c2 second component you're comparing\\n * @return {number} Return value usable by Array.prototype.sort().\\n */\\nfunction mountOrderComparator(c1, c2) {\\n  return c1._mountOrder - c2._mountOrder;\\n}\\n\\nfunction runBatchedUpdates(transaction) {\\n  var len = transaction.dirtyComponentsLength;\\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;\\n\\n  // Since reconciling a component higher in the owner hierarchy usually (not\\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\\n  // them before their children by sorting the array.\\n  dirtyComponents.sort(mountOrderComparator);\\n\\n  // Any updates enqueued while reconciling must be performed after this entire\\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\\n  // C, B could update twice in a single batch if C's render enqueues an update\\n  // to B (since B would have already updated, we should skip it, and the only\\n  // way we can know to do so is by checking the batch counter).\\n  updateBatchNumber++;\\n\\n  for (var i = 0; i < len; i++) {\\n    // If a component is unmounted before pending changes apply, it will still\\n    // be here, but we assume that it has cleared its _pendingCallbacks and\\n    // that performUpdateIfNecessary is a noop.\\n    var component = dirtyComponents[i];\\n\\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\\n    // shouldn't execute the callbacks until the next render happens, so\\n    // stash the callbacks first\\n    var callbacks = component._pendingCallbacks;\\n    component._pendingCallbacks = null;\\n\\n    var markerName;\\n    if (ReactFeatureFlags.logTopLevelRenders) {\\n      var namedComponent = component;\\n      // Duck type TopLevelWrapper. This is probably always true.\\n      if (component._currentElement.type.isReactTopLevelWrapper) {\\n        namedComponent = component._renderedComponent;\\n      }\\n      markerName = 'React update: ' + namedComponent.getName();\\n      console.time(markerName);\\n    }\\n\\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\\n\\n    if (markerName) {\\n      console.timeEnd(markerName);\\n    }\\n\\n    if (callbacks) {\\n      for (var j = 0; j < callbacks.length; j++) {\\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\\n      }\\n    }\\n  }\\n}\\n\\nvar flushBatchedUpdates = function () {\\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\\n  // componentDidUpdate) but we need to check here too in order to catch\\n  // updates enqueued by setState callbacks and asap calls.\\n  while (dirtyComponents.length || asapEnqueued) {\\n    if (dirtyComponents.length) {\\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\\n      transaction.perform(runBatchedUpdates, null, transaction);\\n      ReactUpdatesFlushTransaction.release(transaction);\\n    }\\n\\n    if (asapEnqueued) {\\n      asapEnqueued = false;\\n      var queue = asapCallbackQueue;\\n      asapCallbackQueue = CallbackQueue.getPooled();\\n      queue.notifyAll();\\n      CallbackQueue.release(queue);\\n    }\\n  }\\n};\\n\\n/**\\n * Mark a component as needing a rerender, adding an optional callback to a\\n * list of functions which will be executed once the rerender occurs.\\n */\\nfunction enqueueUpdate(component) {\\n  ensureInjected();\\n\\n  // Various parts of our code (such as ReactCompositeComponent's\\n  // _renderValidatedComponent) assume that calls to render aren't nested;\\n  // verify that that's the case. (This is called by each top-level update\\n  // function, like setState, forceUpdate, etc.; creation and\\n  // destruction of top-level components is guarded in ReactMount.)\\n\\n  if (!batchingStrategy.isBatchingUpdates) {\\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\\n    return;\\n  }\\n\\n  dirtyComponents.push(component);\\n  if (component._updateBatchNumber == null) {\\n    component._updateBatchNumber = updateBatchNumber + 1;\\n  }\\n}\\n\\n/**\\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\\n * if no updates are currently being performed.\\n */\\nfunction asap(callback, context) {\\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\\\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;\\n  asapCallbackQueue.enqueue(callback, context);\\n  asapEnqueued = true;\\n}\\n\\nvar ReactUpdatesInjection = {\\n  injectReconcileTransaction: function (ReconcileTransaction) {\\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\\n  },\\n\\n  injectBatchingStrategy: function (_batchingStrategy) {\\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\\n    batchingStrategy = _batchingStrategy;\\n  }\\n};\\n\\nvar ReactUpdates = {\\n  /**\\n   * React references `ReactReconcileTransaction` using this property in order\\n   * to allow dependency injection.\\n   *\\n   * @internal\\n   */\\n  ReactReconcileTransaction: null,\\n\\n  batchedUpdates: batchedUpdates,\\n  enqueueUpdate: enqueueUpdate,\\n  flushBatchedUpdates: flushBatchedUpdates,\\n  injection: ReactUpdatesInjection,\\n  asap: asap\\n};\\n\\nmodule.exports = ReactUpdates;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"ensureInjected\",\"ReactUpdates\",\"ReactReconcileTransaction\",\"batchingStrategy\",\"invariant\",\"ReactUpdatesFlushTransaction\",\"reinitializeTransaction\",\"dirtyComponentsLength\",\"callbackQueue\",\"CallbackQueue\",\"getPooled\",\"reconcileTransaction\",\"mountOrderComparator\",\"c1\",\"c2\",\"_mountOrder\",\"runBatchedUpdates\",\"transaction\",\"len\",\"dirtyComponents\",\"length\",\"sort\",\"updateBatchNumber\",\"i\",\"component\",\"callbacks\",\"_pendingCallbacks\",\"ReactFeatureFlags\",\"logTopLevelRenders\",\"namedComponent\",\"_currentElement\",\"type\",\"isReactTopLevelWrapper\",\"_renderedComponent\",\"markerName\",\"getName\",\"console\",\"time\",\"ReactReconciler\",\"performUpdateIfNecessary\",\"timeEnd\",\"j\",\"enqueue\",\"getPublicInstance\",\"enqueueUpdate\",\"isBatchingUpdates\",\"push\",\"_updateBatchNumber\",\"batchedUpdates\",\"_assign\",\"PooledClass\",\"Transaction\",\"asapCallbackQueue\",\"asapEnqueued\",\"TRANSACTION_WRAPPERS\",\"NESTED_UPDATES\",\"initialize\",\"close\",\"splice\",\"flushBatchedUpdates\",\"UPDATE_QUEUEING\",\"reset\",\"notifyAll\",\"prototype\",\"getTransactionWrappers\",\"destructor\",\"release\",\"perform\",\"method\",\"scope\",\"a\",\"call\",\"addPoolingTo\",\"queue\",\"callback\",\"b\",\"c\",\"d\",\"e\",\"injection\",\"ReactUpdatesInjection\",\"injectReconcileTransaction\",\"ReconcileTransaction\",\"injectBatchingStrategy\",\"_batchingStrategy\",\"asap\",\"context\"]\n}\n"]