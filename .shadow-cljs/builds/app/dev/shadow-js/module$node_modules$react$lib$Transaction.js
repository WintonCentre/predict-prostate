["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/Transaction.js"],"~:js","shadow$provide.module$node_modules$react$lib$Transaction=function(global,require,module,exports){require(\"module$node_modules$react$lib$reactProdInvariant\");var invariant=require(\"module$node_modules$fbjs$lib$invariant\"),Transaction={Mixin:{reinitializeTransaction:function(){this.transactionWrappers=this.getTransactionWrappers();this.wrapperInitData?this.wrapperInitData.length=0:this.wrapperInitData=[];this._isInTransaction=!1},_isInTransaction:!1,getTransactionWrappers:null,isInTransaction:function(){return!!this._isInTransaction},\nperform:function(method,scope,a,b,c,d,e,f){this.isInTransaction()?invariant(!1,\"Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.\"):void 0;try{var errorThrown=this._isInTransaction=!0;this.initializeAll(0);var ret=method.call(scope,a,b,c,d,e,f);errorThrown=!1}finally{try{if(errorThrown)try{this.closeAll(0)}catch(err){}else this.closeAll(0)}finally{this._isInTransaction=!1}}return ret},initializeAll:function(startIndex){for(var transactionWrappers=\nthis.transactionWrappers;startIndex<transactionWrappers.length;startIndex++){var wrapper=transactionWrappers[startIndex];try{this.wrapperInitData[startIndex]=Transaction.OBSERVED_ERROR,this.wrapperInitData[startIndex]=wrapper.initialize?wrapper.initialize.call(this):null}finally{if(this.wrapperInitData[startIndex]===Transaction.OBSERVED_ERROR)try{this.initializeAll(startIndex+1)}catch(err){}}}},closeAll:function(startIndex){this.isInTransaction()?void 0:invariant(!1,\"Transaction.closeAll(): Cannot close transaction when none are open.\");\nfor(var transactionWrappers=this.transactionWrappers;startIndex<transactionWrappers.length;startIndex++){var wrapper=transactionWrappers[startIndex],initData=this.wrapperInitData[startIndex];try{var errorThrown=!0;initData!==Transaction.OBSERVED_ERROR&&wrapper.close&&wrapper.close.call(this,initData);errorThrown=!1}finally{if(errorThrown)try{this.closeAll(startIndex+1)}catch(e){}}}this.wrapperInitData.length=0}},OBSERVED_ERROR:{}};module.exports=Transaction}","~:source","shadow$provide[\"module$node_modules$react$lib$Transaction\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Transaction\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * `Transaction` creates a black box that is able to wrap any method such that\n * certain invariants are maintained before and after the method is invoked\n * (Even if an exception is thrown while invoking the wrapped method). Whoever\n * instantiates a transaction can provide enforcers of the invariants at\n * creation time. The `Transaction` class itself will supply one additional\n * automatic invariant for you - the invariant that any transaction instance\n * should not be run while it is already being run. You would typically create a\n * single instance of a `Transaction` for reuse multiple times, that potentially\n * is used to wrap several different methods. Wrappers are extremely simple -\n * they only require implementing two methods.\n *\n * <pre>\n *                       wrappers (injected at creation time)\n *                                      +        +\n *                                      |        |\n *                    +-----------------|--------|--------------+\n *                    |                 v        |              |\n *                    |      +---------------+   |              |\n *                    |   +--|    wrapper1   |---|----+         |\n *                    |   |  +---------------+   v    |         |\n *                    |   |          +-------------+  |         |\n *                    |   |     +----|   wrapper2  |--------+   |\n *                    |   |     |    +-------------+  |     |   |\n *                    |   |     |                     |     |   |\n *                    |   v     v                     v     v   | wrapper\n *                    | +---+ +---+   +---------+   +---+ +---+ | invariants\n * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained\n * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | +---+ +---+   +---------+   +---+ +---+ |\n *                    |  initialize                    close    |\n *                    +-----------------------------------------+\n * </pre>\n *\n * Use cases:\n * - Preserving the input selection ranges before/after reconciliation.\n *   Restoring selection even in the event of an unexpected error.\n * - Deactivating events while rearranging the DOM, preventing blurs/focuses,\n *   while guaranteeing that afterwards, the event system is reactivated.\n * - Flushing a queue of collected DOM mutations to the main UI thread after a\n *   reconciliation takes place in a worker thread.\n * - Invoking any collected `componentDidUpdate` callbacks after rendering new\n *   content.\n * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue\n *   to preserve the `scrollTop` (an automatic scroll aware DOM).\n * - (Future use case): Layout calculations before and after DOM updates.\n *\n * Transactional plugin API:\n * - A module that has an `initialize` method that returns any precomputation.\n * - and a `close` method that accepts the precomputation. `close` is invoked\n *   when the wrapped process is completed, or has failed.\n *\n * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules\n * that implement `initialize` and `close`.\n * @return {Transaction} Single transaction for reuse in thread.\n *\n * @class Transaction\n */\nvar Mixin = {\n  /**\n   * Sets up this instance so that it is prepared for collecting metrics. Does\n   * so such that this setup method may be used on an instance that is already\n   * initialized, in a way that does not consume additional memory upon reuse.\n   * That can be useful if you decide to make your subclass of this mixin a\n   * \"PooledClass\".\n   */\n  reinitializeTransaction: function () {\n    this.transactionWrappers = this.getTransactionWrappers();\n    if (this.wrapperInitData) {\n      this.wrapperInitData.length = 0;\n    } else {\n      this.wrapperInitData = [];\n    }\n    this._isInTransaction = false;\n  },\n\n  _isInTransaction: false,\n\n  /**\n   * @abstract\n   * @return {Array<TransactionWrapper>} Array of transaction wrappers.\n   */\n  getTransactionWrappers: null,\n\n  isInTransaction: function () {\n    return !!this._isInTransaction;\n  },\n\n  /**\n   * Executes the function within a safety window. Use this for the top level\n   * methods that result in large amounts of computation/mutations that would\n   * need to be safety checked. The optional arguments helps prevent the need\n   * to bind in many cases.\n   *\n   * @param {function} method Member of scope to call.\n   * @param {Object} scope Scope to invoke from.\n   * @param {Object?=} a Argument to pass to the method.\n   * @param {Object?=} b Argument to pass to the method.\n   * @param {Object?=} c Argument to pass to the method.\n   * @param {Object?=} d Argument to pass to the method.\n   * @param {Object?=} e Argument to pass to the method.\n   * @param {Object?=} f Argument to pass to the method.\n   *\n   * @return {*} Return value from `method`.\n   */\n  perform: function (method, scope, a, b, c, d, e, f) {\n    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;\n    var errorThrown;\n    var ret;\n    try {\n      this._isInTransaction = true;\n      // Catching errors makes debugging more difficult, so we start with\n      // errorThrown set to true before setting it to false after calling\n      // close -- if it's still set to true in the finally block, it means\n      // one of these calls threw.\n      errorThrown = true;\n      this.initializeAll(0);\n      ret = method.call(scope, a, b, c, d, e, f);\n      errorThrown = false;\n    } finally {\n      try {\n        if (errorThrown) {\n          // If `method` throws, prefer to show that stack trace over any thrown\n          // by invoking `closeAll`.\n          try {\n            this.closeAll(0);\n          } catch (err) {}\n        } else {\n          // Since `method` didn't throw, we don't want to silence the exception\n          // here.\n          this.closeAll(0);\n        }\n      } finally {\n        this._isInTransaction = false;\n      }\n    }\n    return ret;\n  },\n\n  initializeAll: function (startIndex) {\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      try {\n        // Catching errors makes debugging more difficult, so we start with the\n        // OBSERVED_ERROR state before overwriting it with the real return value\n        // of initialize -- if it's still set to OBSERVED_ERROR in the finally\n        // block, it means wrapper.initialize threw.\n        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;\n        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;\n      } finally {\n        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {\n          // The initializer for wrapper i threw an error; initialize the\n          // remaining wrappers but silence any exceptions from them to ensure\n          // that the first error is the one to bubble up.\n          try {\n            this.initializeAll(i + 1);\n          } catch (err) {}\n        }\n      }\n    }\n  },\n\n  /**\n   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into\n   * them the respective return values of `this.transactionWrappers.init[i]`\n   * (`close`rs that correspond to initializers that failed will not be\n   * invoked).\n   */\n  closeAll: function (startIndex) {\n    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      var initData = this.wrapperInitData[i];\n      var errorThrown;\n      try {\n        // Catching errors makes debugging more difficult, so we start with\n        // errorThrown set to true before setting it to false after calling\n        // close -- if it's still set to true in the finally block, it means\n        // wrapper.close threw.\n        errorThrown = true;\n        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {\n          wrapper.close.call(this, initData);\n        }\n        errorThrown = false;\n      } finally {\n        if (errorThrown) {\n          // The closer for wrapper i threw an error; close the remaining\n          // wrappers but silence any exceptions from them to ensure that the\n          // first error is the one to bubble up.\n          try {\n            this.closeAll(i + 1);\n          } catch (e) {}\n        }\n      }\n    }\n    this.wrapperInitData.length = 0;\n  }\n};\n\nvar Transaction = {\n\n  Mixin: Mixin,\n\n  /**\n   * Token to look for to determine if an error occurred.\n   */\n  OBSERVED_ERROR: {}\n\n};\n\nmodule.exports = Transaction;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react$lib$reactProdInvariant"]],"~:properties",["^5",["isInTransaction","wrapperInitData","Mixin","reinitializeTransaction","transactionWrappers","closeAll","getTransactionWrappers","OBSERVED_ERROR","length","initializeAll","perform","_isInTransaction"]],"~:compiled-at",1635250628388,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$Transaction.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/Transaction.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$Transaction\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule Transaction\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * `Transaction` creates a black box that is able to wrap any method such that\\n * certain invariants are maintained before and after the method is invoked\\n * (Even if an exception is thrown while invoking the wrapped method). Whoever\\n * instantiates a transaction can provide enforcers of the invariants at\\n * creation time. The `Transaction` class itself will supply one additional\\n * automatic invariant for you - the invariant that any transaction instance\\n * should not be run while it is already being run. You would typically create a\\n * single instance of a `Transaction` for reuse multiple times, that potentially\\n * is used to wrap several different methods. Wrappers are extremely simple -\\n * they only require implementing two methods.\\n *\\n * <pre>\\n *                       wrappers (injected at creation time)\\n *                                      +        +\\n *                                      |        |\\n *                    +-----------------|--------|--------------+\\n *                    |                 v        |              |\\n *                    |      +---------------+   |              |\\n *                    |   +--|    wrapper1   |---|----+         |\\n *                    |   |  +---------------+   v    |         |\\n *                    |   |          +-------------+  |         |\\n *                    |   |     +----|   wrapper2  |--------+   |\\n *                    |   |     |    +-------------+  |     |   |\\n *                    |   |     |                     |     |   |\\n *                    |   v     v                     v     v   | wrapper\\n *                    | +---+ +---+   +---------+   +---+ +---+ | invariants\\n * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained\\n * +-----------------\\u003e|-|---|-|---|--\\u003e|anyMethod|---|---|-|---|-|--------\\u003e\\n *                    | |   | |   |   |         |   |   | |   | |\\n *                    | |   | |   |   |         |   |   | |   | |\\n *                    | |   | |   |   |         |   |   | |   | |\\n *                    | +---+ +---+   +---------+   +---+ +---+ |\\n *                    |  initialize                    close    |\\n *                    +-----------------------------------------+\\n * </pre>\\n *\\n * Use cases:\\n * - Preserving the input selection ranges before/after reconciliation.\\n *   Restoring selection even in the event of an unexpected error.\\n * - Deactivating events while rearranging the DOM, preventing blurs/focuses,\\n *   while guaranteeing that afterwards, the event system is reactivated.\\n * - Flushing a queue of collected DOM mutations to the main UI thread after a\\n *   reconciliation takes place in a worker thread.\\n * - Invoking any collected `componentDidUpdate` callbacks after rendering new\\n *   content.\\n * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue\\n *   to preserve the `scrollTop` (an automatic scroll aware DOM).\\n * - (Future use case): Layout calculations before and after DOM updates.\\n *\\n * Transactional plugin API:\\n * - A module that has an `initialize` method that returns any precomputation.\\n * - and a `close` method that accepts the precomputation. `close` is invoked\\n *   when the wrapped process is completed, or has failed.\\n *\\n * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules\\n * that implement `initialize` and `close`.\\n * @return {Transaction} Single transaction for reuse in thread.\\n *\\n * @class Transaction\\n */\\nvar Mixin = {\\n  /**\\n   * Sets up this instance so that it is prepared for collecting metrics. Does\\n   * so such that this setup method may be used on an instance that is already\\n   * initialized, in a way that does not consume additional memory upon reuse.\\n   * That can be useful if you decide to make your subclass of this mixin a\\n   * \\\"PooledClass\\\".\\n   */\\n  reinitializeTransaction: function () {\\n    this.transactionWrappers = this.getTransactionWrappers();\\n    if (this.wrapperInitData) {\\n      this.wrapperInitData.length = 0;\\n    } else {\\n      this.wrapperInitData = [];\\n    }\\n    this._isInTransaction = false;\\n  },\\n\\n  _isInTransaction: false,\\n\\n  /**\\n   * @abstract\\n   * @return {Array<TransactionWrapper>} Array of transaction wrappers.\\n   */\\n  getTransactionWrappers: null,\\n\\n  isInTransaction: function () {\\n    return !!this._isInTransaction;\\n  },\\n\\n  /**\\n   * Executes the function within a safety window. Use this for the top level\\n   * methods that result in large amounts of computation/mutations that would\\n   * need to be safety checked. The optional arguments helps prevent the need\\n   * to bind in many cases.\\n   *\\n   * @param {function} method Member of scope to call.\\n   * @param {Object} scope Scope to invoke from.\\n   * @param {Object?=} a Argument to pass to the method.\\n   * @param {Object?=} b Argument to pass to the method.\\n   * @param {Object?=} c Argument to pass to the method.\\n   * @param {Object?=} d Argument to pass to the method.\\n   * @param {Object?=} e Argument to pass to the method.\\n   * @param {Object?=} f Argument to pass to the method.\\n   *\\n   * @return {*} Return value from `method`.\\n   */\\n  perform: function (method, scope, a, b, c, d, e, f) {\\n    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;\\n    var errorThrown;\\n    var ret;\\n    try {\\n      this._isInTransaction = true;\\n      // Catching errors makes debugging more difficult, so we start with\\n      // errorThrown set to true before setting it to false after calling\\n      // close -- if it's still set to true in the finally block, it means\\n      // one of these calls threw.\\n      errorThrown = true;\\n      this.initializeAll(0);\\n      ret = method.call(scope, a, b, c, d, e, f);\\n      errorThrown = false;\\n    } finally {\\n      try {\\n        if (errorThrown) {\\n          // If `method` throws, prefer to show that stack trace over any thrown\\n          // by invoking `closeAll`.\\n          try {\\n            this.closeAll(0);\\n          } catch (err) {}\\n        } else {\\n          // Since `method` didn't throw, we don't want to silence the exception\\n          // here.\\n          this.closeAll(0);\\n        }\\n      } finally {\\n        this._isInTransaction = false;\\n      }\\n    }\\n    return ret;\\n  },\\n\\n  initializeAll: function (startIndex) {\\n    var transactionWrappers = this.transactionWrappers;\\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\\n      var wrapper = transactionWrappers[i];\\n      try {\\n        // Catching errors makes debugging more difficult, so we start with the\\n        // OBSERVED_ERROR state before overwriting it with the real return value\\n        // of initialize -- if it's still set to OBSERVED_ERROR in the finally\\n        // block, it means wrapper.initialize threw.\\n        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;\\n        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;\\n      } finally {\\n        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {\\n          // The initializer for wrapper i threw an error; initialize the\\n          // remaining wrappers but silence any exceptions from them to ensure\\n          // that the first error is the one to bubble up.\\n          try {\\n            this.initializeAll(i + 1);\\n          } catch (err) {}\\n        }\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into\\n   * them the respective return values of `this.transactionWrappers.init[i]`\\n   * (`close`rs that correspond to initializers that failed will not be\\n   * invoked).\\n   */\\n  closeAll: function (startIndex) {\\n    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;\\n    var transactionWrappers = this.transactionWrappers;\\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\\n      var wrapper = transactionWrappers[i];\\n      var initData = this.wrapperInitData[i];\\n      var errorThrown;\\n      try {\\n        // Catching errors makes debugging more difficult, so we start with\\n        // errorThrown set to true before setting it to false after calling\\n        // close -- if it's still set to true in the finally block, it means\\n        // wrapper.close threw.\\n        errorThrown = true;\\n        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {\\n          wrapper.close.call(this, initData);\\n        }\\n        errorThrown = false;\\n      } finally {\\n        if (errorThrown) {\\n          // The closer for wrapper i threw an error; close the remaining\\n          // wrappers but silence any exceptions from them to ensure that the\\n          // first error is the one to bubble up.\\n          try {\\n            this.closeAll(i + 1);\\n          } catch (e) {}\\n        }\\n      }\\n    }\\n    this.wrapperInitData.length = 0;\\n  }\\n};\\n\\nvar Transaction = {\\n\\n  Mixin: Mixin,\\n\\n  /**\\n   * Token to look for to determine if an error occurred.\\n   */\\n  OBSERVED_ERROR: {}\\n\\n};\\n\\nmodule.exports = Transaction;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"invariant\",\"Transaction\",\"Mixin\",\"reinitializeTransaction\",\"transactionWrappers\",\"getTransactionWrappers\",\"wrapperInitData\",\"length\",\"_isInTransaction\",\"isInTransaction\",\"perform\",\"method\",\"scope\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"errorThrown\",\"initializeAll\",\"ret\",\"call\",\"closeAll\",\"err\",\"startIndex\",\"i\",\"wrapper\",\"OBSERVED_ERROR\",\"initialize\",\"initData\",\"close\"]\n}\n"]