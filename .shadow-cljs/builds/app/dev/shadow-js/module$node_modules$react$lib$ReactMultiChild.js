["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactMultiChild.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactMultiChild=function(global,require,module,exports){function enqueue(queue,update){update&&(queue=queue||[],queue.push(update));return queue}require(\"module$node_modules$react$lib$reactProdInvariant\");var ReactComponentEnvironment=require(\"module$node_modules$react$lib$ReactComponentEnvironment\"),ReactInstanceMap=require(\"module$node_modules$react$lib$ReactInstanceMap\"),ReactInstrumentation=require(\"module$node_modules$react$lib$ReactInstrumentation\"),\nReactMultiChildUpdateTypes=require(\"module$node_modules$react$lib$ReactMultiChildUpdateTypes\"),ReactCurrentOwner=require(\"module$node_modules$react$lib$ReactCurrentOwner\"),ReactReconciler=require(\"module$node_modules$react$lib$ReactReconciler\"),ReactChildReconciler=require(\"module$node_modules$react$lib$ReactChildReconciler\");global=require(\"module$node_modules$fbjs$lib$emptyFunction\");var flattenChildren=require(\"module$node_modules$react$lib$flattenChildren\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),\nsetChildrenForInstrumentation=global,getDebugID=function(inst){if(!inst._debugID){var internal;if(internal=ReactInstanceMap.get(inst))inst=internal}return inst._debugID};setChildrenForInstrumentation=function(children){var debugID=getDebugID(this);if(0!==debugID)ReactInstrumentation.debugTool.onSetChildren(debugID,children?Object.keys(children).map(function(key){return children[key]._debugID}):[])};module.exports={Mixin:{_reconcilerInstantiateChildren:function(nestedChildren,transaction,context){var selfDebugID=\ngetDebugID(this);if(this._currentElement)try{return ReactCurrentOwner.current=this._currentElement._owner,ReactChildReconciler.instantiateChildren(nestedChildren,transaction,context,selfDebugID)}finally{ReactCurrentOwner.current=null}return ReactChildReconciler.instantiateChildren(nestedChildren,transaction,context)},_reconcilerUpdateChildren:function(prevChildren,nextNestedChildrenElements,mountImages,removedNodes,transaction,context){var selfDebugID=getDebugID(this);if(this._currentElement){try{ReactCurrentOwner.current=\nthis._currentElement._owner;var nextChildren=flattenChildren(nextNestedChildrenElements,selfDebugID)}finally{ReactCurrentOwner.current=null}ReactChildReconciler.updateChildren(prevChildren,nextChildren,mountImages,removedNodes,transaction,this,this._hostContainerInfo,context,selfDebugID);return nextChildren}nextChildren=flattenChildren(nextNestedChildrenElements,selfDebugID);ReactChildReconciler.updateChildren(prevChildren,nextChildren,mountImages,removedNodes,transaction,this,this._hostContainerInfo,\ncontext,selfDebugID);return nextChildren},mountChildren:function(nestedChildren,transaction,context){this._renderedChildren=nestedChildren=this._reconcilerInstantiateChildren(nestedChildren,transaction,context);var mountImages=[],index=0,name;for(name in nestedChildren)if(nestedChildren.hasOwnProperty(name)){var child=nestedChildren[name];var selfDebugID=getDebugID(this);selfDebugID=ReactReconciler.mountComponent(child,transaction,this,this._hostContainerInfo,context,selfDebugID);child._mountIndex=\nindex++;mountImages.push(selfDebugID)}setChildrenForInstrumentation.call(this,nestedChildren);return mountImages},updateTextContent:function(nextContent){var prevChildren=this._renderedChildren;ReactChildReconciler.unmountChildren(prevChildren,!1);for(var name in prevChildren)prevChildren.hasOwnProperty(name)&&invariant(!1,\"updateTextContent called on non-empty component.\");ReactComponentEnvironment.processChildrenUpdates(this,[{type:ReactMultiChildUpdateTypes.TEXT_CONTENT,content:nextContent,fromIndex:null,\nfromNode:null,toIndex:null,afterNode:null}])},updateMarkup:function(nextMarkup){var prevChildren=this._renderedChildren;ReactChildReconciler.unmountChildren(prevChildren,!1);for(var name in prevChildren)prevChildren.hasOwnProperty(name)&&invariant(!1,\"updateTextContent called on non-empty component.\");ReactComponentEnvironment.processChildrenUpdates(this,[{type:ReactMultiChildUpdateTypes.SET_MARKUP,content:nextMarkup,fromIndex:null,fromNode:null,toIndex:null,afterNode:null}])},updateChildren:function(nextNestedChildrenElements,\ntransaction,context){this._updateChildren(nextNestedChildrenElements,transaction,context)},_updateChildren:function(nextNestedChildrenElements,transaction,context){var prevChildren=this._renderedChildren,removedNodes={},mountImages=[];if((nextNestedChildrenElements=this._reconcilerUpdateChildren(prevChildren,nextNestedChildrenElements,mountImages,removedNodes,transaction,context))||prevChildren){var updates=null,name,nextIndex=0,lastIndex=0,nextMountIndex=0,lastPlacedNode=null;for(name in nextNestedChildrenElements)if(nextNestedChildrenElements.hasOwnProperty(name)){var prevChild=\nprevChildren&&prevChildren[name],nextChild=nextNestedChildrenElements[name];prevChild===nextChild?(updates=enqueue(updates,this.moveChild(prevChild,lastPlacedNode,nextIndex,lastIndex)),lastIndex=Math.max(prevChild._mountIndex,lastIndex),prevChild._mountIndex=nextIndex):(prevChild&&(lastIndex=Math.max(prevChild._mountIndex,lastIndex)),updates=enqueue(updates,this._mountChildAtIndex(nextChild,mountImages[nextMountIndex],lastPlacedNode,nextIndex,transaction,context)),nextMountIndex++);nextIndex++;lastPlacedNode=\nReactReconciler.getHostNode(nextChild)}for(name in removedNodes)removedNodes.hasOwnProperty(name)&&(updates=enqueue(updates,this._unmountChild(prevChildren[name],removedNodes[name])));updates&&ReactComponentEnvironment.processChildrenUpdates(this,updates);this._renderedChildren=nextNestedChildrenElements;setChildrenForInstrumentation.call(this,nextNestedChildrenElements)}},unmountChildren:function(safely){ReactChildReconciler.unmountChildren(this._renderedChildren,safely);this._renderedChildren=null},\nmoveChild:function(child,afterNode,toIndex,lastIndex){if(child._mountIndex<lastIndex)return{type:ReactMultiChildUpdateTypes.MOVE_EXISTING,content:null,fromIndex:child._mountIndex,fromNode:ReactReconciler.getHostNode(child),toIndex,afterNode}},createChild:function(child,afterNode,mountImage){return{type:ReactMultiChildUpdateTypes.INSERT_MARKUP,content:mountImage,fromIndex:null,fromNode:null,toIndex:child._mountIndex,afterNode}},removeChild:function(child,node){return{type:ReactMultiChildUpdateTypes.REMOVE_NODE,\ncontent:null,fromIndex:child._mountIndex,fromNode:node,toIndex:null,afterNode:null}},_mountChildAtIndex:function(child,mountImage,afterNode,index,transaction,context){child._mountIndex=index;return this.createChild(child,afterNode,mountImage)},_unmountChild:function(child,node){node=this.removeChild(child,node);child._mountIndex=null;return node}}}}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactMultiChild\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMultiChild\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactInstrumentation = require('./ReactInstrumentation');\nvar ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactChildReconciler = require('./ReactChildReconciler');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar flattenChildren = require('./flattenChildren');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Make an update for markup to be rendered and inserted at a supplied index.\n *\n * @param {string} markup Markup that renders into an element.\n * @param {number} toIndex Destination index.\n * @private\n */\nfunction makeInsertMarkup(markup, afterNode, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,\n    content: markup,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: toIndex,\n    afterNode: afterNode\n  };\n}\n\n/**\n * Make an update for moving an existing element to another index.\n *\n * @param {number} fromIndex Source index of the existing element.\n * @param {number} toIndex Destination index of the element.\n * @private\n */\nfunction makeMove(child, afterNode, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,\n    content: null,\n    fromIndex: child._mountIndex,\n    fromNode: ReactReconciler.getHostNode(child),\n    toIndex: toIndex,\n    afterNode: afterNode\n  };\n}\n\n/**\n * Make an update for removing an element at an index.\n *\n * @param {number} fromIndex Index of the element to remove.\n * @private\n */\nfunction makeRemove(child, node) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: ReactMultiChildUpdateTypes.REMOVE_NODE,\n    content: null,\n    fromIndex: child._mountIndex,\n    fromNode: node,\n    toIndex: null,\n    afterNode: null\n  };\n}\n\n/**\n * Make an update for setting the markup of a node.\n *\n * @param {string} markup Markup that renders into an element.\n * @private\n */\nfunction makeSetMarkup(markup) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: ReactMultiChildUpdateTypes.SET_MARKUP,\n    content: markup,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: null,\n    afterNode: null\n  };\n}\n\n/**\n * Make an update for setting the text content.\n *\n * @param {string} textContent Text content to set.\n * @private\n */\nfunction makeTextContent(textContent) {\n  // NOTE: Null values reduce hidden classes.\n  return {\n    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,\n    content: textContent,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: null,\n    afterNode: null\n  };\n}\n\n/**\n * Push an update, if any, onto the queue. Creates a new queue if none is\n * passed and always returns the queue. Mutative.\n */\nfunction enqueue(queue, update) {\n  if (update) {\n    queue = queue || [];\n    queue.push(update);\n  }\n  return queue;\n}\n\n/**\n * Processes any enqueued updates.\n *\n * @private\n */\nfunction processQueue(inst, updateQueue) {\n  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);\n}\n\nvar setChildrenForInstrumentation = emptyFunction;\nif (process.env.NODE_ENV !== 'production') {\n  var getDebugID = function (inst) {\n    if (!inst._debugID) {\n      // Check for ART-like instances. TODO: This is silly/gross.\n      var internal;\n      if (internal = ReactInstanceMap.get(inst)) {\n        inst = internal;\n      }\n    }\n    return inst._debugID;\n  };\n  setChildrenForInstrumentation = function (children) {\n    var debugID = getDebugID(this);\n    // TODO: React Native empty components are also multichild.\n    // This means they still get into this method but don't have _debugID.\n    if (debugID !== 0) {\n      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {\n        return children[key]._debugID;\n      }) : []);\n    }\n  };\n}\n\n/**\n * ReactMultiChild are capable of reconciling multiple children.\n *\n * @class ReactMultiChild\n * @internal\n */\nvar ReactMultiChild = {\n\n  /**\n   * Provides common functionality for components that must reconcile multiple\n   * children. This is used by `ReactDOMComponent` to mount, update, and\n   * unmount child components.\n   *\n   * @lends {ReactMultiChild.prototype}\n   */\n  Mixin: {\n\n    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {\n      if (process.env.NODE_ENV !== 'production') {\n        var selfDebugID = getDebugID(this);\n        if (this._currentElement) {\n          try {\n            ReactCurrentOwner.current = this._currentElement._owner;\n            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);\n          } finally {\n            ReactCurrentOwner.current = null;\n          }\n        }\n      }\n      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);\n    },\n\n    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {\n      var nextChildren;\n      var selfDebugID = 0;\n      if (process.env.NODE_ENV !== 'production') {\n        selfDebugID = getDebugID(this);\n        if (this._currentElement) {\n          try {\n            ReactCurrentOwner.current = this._currentElement._owner;\n            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\n          } finally {\n            ReactCurrentOwner.current = null;\n          }\n          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\n          return nextChildren;\n        }\n      }\n      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\n      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\n      return nextChildren;\n    },\n\n    /**\n     * Generates a \"mount image\" for each of the supplied children. In the case\n     * of `ReactDOMComponent`, a mount image is a string of markup.\n     *\n     * @param {?object} nestedChildren Nested child maps.\n     * @return {array} An array of mounted representations.\n     * @internal\n     */\n    mountChildren: function (nestedChildren, transaction, context) {\n      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);\n      this._renderedChildren = children;\n\n      var mountImages = [];\n      var index = 0;\n      for (var name in children) {\n        if (children.hasOwnProperty(name)) {\n          var child = children[name];\n          var selfDebugID = 0;\n          if (process.env.NODE_ENV !== 'production') {\n            selfDebugID = getDebugID(this);\n          }\n          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);\n          child._mountIndex = index++;\n          mountImages.push(mountImage);\n        }\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        setChildrenForInstrumentation.call(this, children);\n      }\n\n      return mountImages;\n    },\n\n    /**\n     * Replaces any rendered children with a text content string.\n     *\n     * @param {string} nextContent String of content.\n     * @internal\n     */\n    updateTextContent: function (nextContent) {\n      var prevChildren = this._renderedChildren;\n      // Remove any rendered children.\n      ReactChildReconciler.unmountChildren(prevChildren, false);\n      for (var name in prevChildren) {\n        if (prevChildren.hasOwnProperty(name)) {\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\n        }\n      }\n      // Set new text content.\n      var updates = [makeTextContent(nextContent)];\n      processQueue(this, updates);\n    },\n\n    /**\n     * Replaces any rendered children with a markup string.\n     *\n     * @param {string} nextMarkup String of markup.\n     * @internal\n     */\n    updateMarkup: function (nextMarkup) {\n      var prevChildren = this._renderedChildren;\n      // Remove any rendered children.\n      ReactChildReconciler.unmountChildren(prevChildren, false);\n      for (var name in prevChildren) {\n        if (prevChildren.hasOwnProperty(name)) {\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\n        }\n      }\n      var updates = [makeSetMarkup(nextMarkup)];\n      processQueue(this, updates);\n    },\n\n    /**\n     * Updates the rendered children with new children.\n     *\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    updateChildren: function (nextNestedChildrenElements, transaction, context) {\n      // Hook used by React ART\n      this._updateChildren(nextNestedChildrenElements, transaction, context);\n    },\n\n    /**\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @final\n     * @protected\n     */\n    _updateChildren: function (nextNestedChildrenElements, transaction, context) {\n      var prevChildren = this._renderedChildren;\n      var removedNodes = {};\n      var mountImages = [];\n      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);\n      if (!nextChildren && !prevChildren) {\n        return;\n      }\n      var updates = null;\n      var name;\n      // `nextIndex` will increment for each child in `nextChildren`, but\n      // `lastIndex` will be the last index visited in `prevChildren`.\n      var nextIndex = 0;\n      var lastIndex = 0;\n      // `nextMountIndex` will increment for each newly mounted child.\n      var nextMountIndex = 0;\n      var lastPlacedNode = null;\n      for (name in nextChildren) {\n        if (!nextChildren.hasOwnProperty(name)) {\n          continue;\n        }\n        var prevChild = prevChildren && prevChildren[name];\n        var nextChild = nextChildren[name];\n        if (prevChild === nextChild) {\n          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          prevChild._mountIndex = nextIndex;\n        } else {\n          if (prevChild) {\n            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\n            lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n            // The `removedNodes` loop below will actually remove the child.\n          }\n          // The child must be instantiated before it's mounted.\n          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));\n          nextMountIndex++;\n        }\n        nextIndex++;\n        lastPlacedNode = ReactReconciler.getHostNode(nextChild);\n      }\n      // Remove children that are no longer present.\n      for (name in removedNodes) {\n        if (removedNodes.hasOwnProperty(name)) {\n          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));\n        }\n      }\n      if (updates) {\n        processQueue(this, updates);\n      }\n      this._renderedChildren = nextChildren;\n\n      if (process.env.NODE_ENV !== 'production') {\n        setChildrenForInstrumentation.call(this, nextChildren);\n      }\n    },\n\n    /**\n     * Unmounts all rendered children. This should be used to clean up children\n     * when this component is unmounted. It does not actually perform any\n     * backend operations.\n     *\n     * @internal\n     */\n    unmountChildren: function (safely) {\n      var renderedChildren = this._renderedChildren;\n      ReactChildReconciler.unmountChildren(renderedChildren, safely);\n      this._renderedChildren = null;\n    },\n\n    /**\n     * Moves a child component to the supplied index.\n     *\n     * @param {ReactComponent} child Component to move.\n     * @param {number} toIndex Destination index of the element.\n     * @param {number} lastIndex Last index visited of the siblings of `child`.\n     * @protected\n     */\n    moveChild: function (child, afterNode, toIndex, lastIndex) {\n      // If the index of `child` is less than `lastIndex`, then it needs to\n      // be moved. Otherwise, we do not need to move it because a child will be\n      // inserted or moved before `child`.\n      if (child._mountIndex < lastIndex) {\n        return makeMove(child, afterNode, toIndex);\n      }\n    },\n\n    /**\n     * Creates a child component.\n     *\n     * @param {ReactComponent} child Component to create.\n     * @param {string} mountImage Markup to insert.\n     * @protected\n     */\n    createChild: function (child, afterNode, mountImage) {\n      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);\n    },\n\n    /**\n     * Removes a child component.\n     *\n     * @param {ReactComponent} child Child to remove.\n     * @protected\n     */\n    removeChild: function (child, node) {\n      return makeRemove(child, node);\n    },\n\n    /**\n     * Mounts a child with the supplied name.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to mount.\n     * @param {string} name Name of the child.\n     * @param {number} index Index at which to insert the child.\n     * @param {ReactReconcileTransaction} transaction\n     * @private\n     */\n    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {\n      child._mountIndex = index;\n      return this.createChild(child, afterNode, mountImage);\n    },\n\n    /**\n     * Unmounts a rendered child.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to unmount.\n     * @private\n     */\n    _unmountChild: function (child, node) {\n      var update = this.removeChild(child, node);\n      child._mountIndex = null;\n      return update;\n    }\n\n  }\n\n};\n\nmodule.exports = ReactMultiChild;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$lib$ReactComponentEnvironment","~$module$node_modules$react$lib$ReactMultiChildUpdateTypes","~$module$node_modules$react$lib$ReactInstanceMap","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react$lib$reactProdInvariant","~$module$node_modules$react$lib$ReactChildReconciler","~$module$node_modules$react$lib$ReactInstrumentation","~$module$node_modules$fbjs$lib$emptyFunction","~$module$node_modules$react$lib$ReactReconciler","~$module$node_modules$react$lib$flattenChildren","~$module$node_modules$react$lib$ReactCurrentOwner"]],"~:properties",["^5",["unmountChildren","Mixin","fromNode","toIndex","_reconcilerInstantiateChildren","createChild","updateChildren","fromIndex","_reconcilerUpdateChildren","moveChild","current","content","_mountIndex","_mountChildAtIndex","_updateChildren","_unmountChild","type","updateTextContent","updateMarkup","_renderedChildren","removeChild","mountChildren","afterNode"]],"~:compiled-at",1635250628407,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactMultiChild.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/ReactMultiChild.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactMultiChild\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule ReactMultiChild\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\\nvar ReactInstanceMap = require('./ReactInstanceMap');\\nvar ReactInstrumentation = require('./ReactInstrumentation');\\nvar ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');\\n\\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\\nvar ReactReconciler = require('./ReactReconciler');\\nvar ReactChildReconciler = require('./ReactChildReconciler');\\n\\nvar emptyFunction = require('fbjs/lib/emptyFunction');\\nvar flattenChildren = require('./flattenChildren');\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Make an update for markup to be rendered and inserted at a supplied index.\\n *\\n * @param {string} markup Markup that renders into an element.\\n * @param {number} toIndex Destination index.\\n * @private\\n */\\nfunction makeInsertMarkup(markup, afterNode, toIndex) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,\\n    content: markup,\\n    fromIndex: null,\\n    fromNode: null,\\n    toIndex: toIndex,\\n    afterNode: afterNode\\n  };\\n}\\n\\n/**\\n * Make an update for moving an existing element to another index.\\n *\\n * @param {number} fromIndex Source index of the existing element.\\n * @param {number} toIndex Destination index of the element.\\n * @private\\n */\\nfunction makeMove(child, afterNode, toIndex) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,\\n    content: null,\\n    fromIndex: child._mountIndex,\\n    fromNode: ReactReconciler.getHostNode(child),\\n    toIndex: toIndex,\\n    afterNode: afterNode\\n  };\\n}\\n\\n/**\\n * Make an update for removing an element at an index.\\n *\\n * @param {number} fromIndex Index of the element to remove.\\n * @private\\n */\\nfunction makeRemove(child, node) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: ReactMultiChildUpdateTypes.REMOVE_NODE,\\n    content: null,\\n    fromIndex: child._mountIndex,\\n    fromNode: node,\\n    toIndex: null,\\n    afterNode: null\\n  };\\n}\\n\\n/**\\n * Make an update for setting the markup of a node.\\n *\\n * @param {string} markup Markup that renders into an element.\\n * @private\\n */\\nfunction makeSetMarkup(markup) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: ReactMultiChildUpdateTypes.SET_MARKUP,\\n    content: markup,\\n    fromIndex: null,\\n    fromNode: null,\\n    toIndex: null,\\n    afterNode: null\\n  };\\n}\\n\\n/**\\n * Make an update for setting the text content.\\n *\\n * @param {string} textContent Text content to set.\\n * @private\\n */\\nfunction makeTextContent(textContent) {\\n  // NOTE: Null values reduce hidden classes.\\n  return {\\n    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,\\n    content: textContent,\\n    fromIndex: null,\\n    fromNode: null,\\n    toIndex: null,\\n    afterNode: null\\n  };\\n}\\n\\n/**\\n * Push an update, if any, onto the queue. Creates a new queue if none is\\n * passed and always returns the queue. Mutative.\\n */\\nfunction enqueue(queue, update) {\\n  if (update) {\\n    queue = queue || [];\\n    queue.push(update);\\n  }\\n  return queue;\\n}\\n\\n/**\\n * Processes any enqueued updates.\\n *\\n * @private\\n */\\nfunction processQueue(inst, updateQueue) {\\n  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);\\n}\\n\\nvar setChildrenForInstrumentation = emptyFunction;\\nif (process.env.NODE_ENV !== 'production') {\\n  var getDebugID = function (inst) {\\n    if (!inst._debugID) {\\n      // Check for ART-like instances. TODO: This is silly/gross.\\n      var internal;\\n      if (internal = ReactInstanceMap.get(inst)) {\\n        inst = internal;\\n      }\\n    }\\n    return inst._debugID;\\n  };\\n  setChildrenForInstrumentation = function (children) {\\n    var debugID = getDebugID(this);\\n    // TODO: React Native empty components are also multichild.\\n    // This means they still get into this method but don't have _debugID.\\n    if (debugID !== 0) {\\n      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {\\n        return children[key]._debugID;\\n      }) : []);\\n    }\\n  };\\n}\\n\\n/**\\n * ReactMultiChild are capable of reconciling multiple children.\\n *\\n * @class ReactMultiChild\\n * @internal\\n */\\nvar ReactMultiChild = {\\n\\n  /**\\n   * Provides common functionality for components that must reconcile multiple\\n   * children. This is used by `ReactDOMComponent` to mount, update, and\\n   * unmount child components.\\n   *\\n   * @lends {ReactMultiChild.prototype}\\n   */\\n  Mixin: {\\n\\n    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        var selfDebugID = getDebugID(this);\\n        if (this._currentElement) {\\n          try {\\n            ReactCurrentOwner.current = this._currentElement._owner;\\n            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);\\n          } finally {\\n            ReactCurrentOwner.current = null;\\n          }\\n        }\\n      }\\n      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);\\n    },\\n\\n    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {\\n      var nextChildren;\\n      var selfDebugID = 0;\\n      if (process.env.NODE_ENV !== 'production') {\\n        selfDebugID = getDebugID(this);\\n        if (this._currentElement) {\\n          try {\\n            ReactCurrentOwner.current = this._currentElement._owner;\\n            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\\n          } finally {\\n            ReactCurrentOwner.current = null;\\n          }\\n          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\\n          return nextChildren;\\n        }\\n      }\\n      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);\\n      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);\\n      return nextChildren;\\n    },\\n\\n    /**\\n     * Generates a \\\"mount image\\\" for each of the supplied children. In the case\\n     * of `ReactDOMComponent`, a mount image is a string of markup.\\n     *\\n     * @param {?object} nestedChildren Nested child maps.\\n     * @return {array} An array of mounted representations.\\n     * @internal\\n     */\\n    mountChildren: function (nestedChildren, transaction, context) {\\n      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);\\n      this._renderedChildren = children;\\n\\n      var mountImages = [];\\n      var index = 0;\\n      for (var name in children) {\\n        if (children.hasOwnProperty(name)) {\\n          var child = children[name];\\n          var selfDebugID = 0;\\n          if (process.env.NODE_ENV !== 'production') {\\n            selfDebugID = getDebugID(this);\\n          }\\n          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);\\n          child._mountIndex = index++;\\n          mountImages.push(mountImage);\\n        }\\n      }\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        setChildrenForInstrumentation.call(this, children);\\n      }\\n\\n      return mountImages;\\n    },\\n\\n    /**\\n     * Replaces any rendered children with a text content string.\\n     *\\n     * @param {string} nextContent String of content.\\n     * @internal\\n     */\\n    updateTextContent: function (nextContent) {\\n      var prevChildren = this._renderedChildren;\\n      // Remove any rendered children.\\n      ReactChildReconciler.unmountChildren(prevChildren, false);\\n      for (var name in prevChildren) {\\n        if (prevChildren.hasOwnProperty(name)) {\\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\\n        }\\n      }\\n      // Set new text content.\\n      var updates = [makeTextContent(nextContent)];\\n      processQueue(this, updates);\\n    },\\n\\n    /**\\n     * Replaces any rendered children with a markup string.\\n     *\\n     * @param {string} nextMarkup String of markup.\\n     * @internal\\n     */\\n    updateMarkup: function (nextMarkup) {\\n      var prevChildren = this._renderedChildren;\\n      // Remove any rendered children.\\n      ReactChildReconciler.unmountChildren(prevChildren, false);\\n      for (var name in prevChildren) {\\n        if (prevChildren.hasOwnProperty(name)) {\\n          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;\\n        }\\n      }\\n      var updates = [makeSetMarkup(nextMarkup)];\\n      processQueue(this, updates);\\n    },\\n\\n    /**\\n     * Updates the rendered children with new children.\\n     *\\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\\n     * @param {ReactReconcileTransaction} transaction\\n     * @internal\\n     */\\n    updateChildren: function (nextNestedChildrenElements, transaction, context) {\\n      // Hook used by React ART\\n      this._updateChildren(nextNestedChildrenElements, transaction, context);\\n    },\\n\\n    /**\\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\\n     * @param {ReactReconcileTransaction} transaction\\n     * @final\\n     * @protected\\n     */\\n    _updateChildren: function (nextNestedChildrenElements, transaction, context) {\\n      var prevChildren = this._renderedChildren;\\n      var removedNodes = {};\\n      var mountImages = [];\\n      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);\\n      if (!nextChildren && !prevChildren) {\\n        return;\\n      }\\n      var updates = null;\\n      var name;\\n      // `nextIndex` will increment for each child in `nextChildren`, but\\n      // `lastIndex` will be the last index visited in `prevChildren`.\\n      var nextIndex = 0;\\n      var lastIndex = 0;\\n      // `nextMountIndex` will increment for each newly mounted child.\\n      var nextMountIndex = 0;\\n      var lastPlacedNode = null;\\n      for (name in nextChildren) {\\n        if (!nextChildren.hasOwnProperty(name)) {\\n          continue;\\n        }\\n        var prevChild = prevChildren && prevChildren[name];\\n        var nextChild = nextChildren[name];\\n        if (prevChild === nextChild) {\\n          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));\\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\\n          prevChild._mountIndex = nextIndex;\\n        } else {\\n          if (prevChild) {\\n            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\\n            lastIndex = Math.max(prevChild._mountIndex, lastIndex);\\n            // The `removedNodes` loop below will actually remove the child.\\n          }\\n          // The child must be instantiated before it's mounted.\\n          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));\\n          nextMountIndex++;\\n        }\\n        nextIndex++;\\n        lastPlacedNode = ReactReconciler.getHostNode(nextChild);\\n      }\\n      // Remove children that are no longer present.\\n      for (name in removedNodes) {\\n        if (removedNodes.hasOwnProperty(name)) {\\n          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));\\n        }\\n      }\\n      if (updates) {\\n        processQueue(this, updates);\\n      }\\n      this._renderedChildren = nextChildren;\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        setChildrenForInstrumentation.call(this, nextChildren);\\n      }\\n    },\\n\\n    /**\\n     * Unmounts all rendered children. This should be used to clean up children\\n     * when this component is unmounted. It does not actually perform any\\n     * backend operations.\\n     *\\n     * @internal\\n     */\\n    unmountChildren: function (safely) {\\n      var renderedChildren = this._renderedChildren;\\n      ReactChildReconciler.unmountChildren(renderedChildren, safely);\\n      this._renderedChildren = null;\\n    },\\n\\n    /**\\n     * Moves a child component to the supplied index.\\n     *\\n     * @param {ReactComponent} child Component to move.\\n     * @param {number} toIndex Destination index of the element.\\n     * @param {number} lastIndex Last index visited of the siblings of `child`.\\n     * @protected\\n     */\\n    moveChild: function (child, afterNode, toIndex, lastIndex) {\\n      // If the index of `child` is less than `lastIndex`, then it needs to\\n      // be moved. Otherwise, we do not need to move it because a child will be\\n      // inserted or moved before `child`.\\n      if (child._mountIndex < lastIndex) {\\n        return makeMove(child, afterNode, toIndex);\\n      }\\n    },\\n\\n    /**\\n     * Creates a child component.\\n     *\\n     * @param {ReactComponent} child Component to create.\\n     * @param {string} mountImage Markup to insert.\\n     * @protected\\n     */\\n    createChild: function (child, afterNode, mountImage) {\\n      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);\\n    },\\n\\n    /**\\n     * Removes a child component.\\n     *\\n     * @param {ReactComponent} child Child to remove.\\n     * @protected\\n     */\\n    removeChild: function (child, node) {\\n      return makeRemove(child, node);\\n    },\\n\\n    /**\\n     * Mounts a child with the supplied name.\\n     *\\n     * NOTE: This is part of `updateChildren` and is here for readability.\\n     *\\n     * @param {ReactComponent} child Component to mount.\\n     * @param {string} name Name of the child.\\n     * @param {number} index Index at which to insert the child.\\n     * @param {ReactReconcileTransaction} transaction\\n     * @private\\n     */\\n    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {\\n      child._mountIndex = index;\\n      return this.createChild(child, afterNode, mountImage);\\n    },\\n\\n    /**\\n     * Unmounts a rendered child.\\n     *\\n     * NOTE: This is part of `updateChildren` and is here for readability.\\n     *\\n     * @param {ReactComponent} child Component to unmount.\\n     * @private\\n     */\\n    _unmountChild: function (child, node) {\\n      var update = this.removeChild(child, node);\\n      child._mountIndex = null;\\n      return update;\\n    }\\n\\n  }\\n\\n};\\n\\nmodule.exports = ReactMultiChild;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"enqueue\",\"queue\",\"update\",\"push\",\"ReactComponentEnvironment\",\"ReactInstanceMap\",\"ReactInstrumentation\",\"ReactMultiChildUpdateTypes\",\"ReactCurrentOwner\",\"ReactReconciler\",\"ReactChildReconciler\",\"emptyFunction\",\"flattenChildren\",\"invariant\",\"setChildrenForInstrumentation\",\"getDebugID\",\"inst\",\"_debugID\",\"internal\",\"get\",\"children\",\"debugID\",\"debugTool\",\"onSetChildren\",\"Object\",\"keys\",\"map\",\"key\",\"ReactMultiChild\",\"Mixin\",\"_reconcilerInstantiateChildren\",\"nestedChildren\",\"transaction\",\"context\",\"selfDebugID\",\"_currentElement\",\"current\",\"_owner\",\"instantiateChildren\",\"_reconcilerUpdateChildren\",\"prevChildren\",\"nextNestedChildrenElements\",\"mountImages\",\"removedNodes\",\"nextChildren\",\"updateChildren\",\"_hostContainerInfo\",\"mountChildren\",\"_renderedChildren\",\"index\",\"name\",\"hasOwnProperty\",\"child\",\"mountImage\",\"mountComponent\",\"_mountIndex\",\"call\",\"updateTextContent\",\"nextContent\",\"unmountChildren\",\"processChildrenUpdates\",\"updates\",\"type\",\"TEXT_CONTENT\",\"content\",\"fromIndex\",\"fromNode\",\"toIndex\",\"afterNode\",\"updateMarkup\",\"nextMarkup\",\"SET_MARKUP\",\"_updateChildren\",\"nextIndex\",\"lastIndex\",\"nextMountIndex\",\"lastPlacedNode\",\"prevChild\",\"nextChild\",\"moveChild\",\"Math\",\"max\",\"_mountChildAtIndex\",\"getHostNode\",\"_unmountChild\",\"safely\",\"MOVE_EXISTING\",\"createChild\",\"INSERT_MARKUP\",\"removeChild\",\"node\",\"REMOVE_NODE\"]\n}\n"]