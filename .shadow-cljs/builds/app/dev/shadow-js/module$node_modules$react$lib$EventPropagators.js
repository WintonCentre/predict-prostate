["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/EventPropagators.js"],"~:js","shadow$provide.module$node_modules$react$lib$EventPropagators=function(global,require,module,exports){function accumulateDirectionalDispatches(inst,upwards,event){warning(inst,\"Dispatching inst must not be null\");if(upwards=getListener(inst,event.dispatchConfig.phasedRegistrationNames[upwards?PropagationPhases.bubbled:PropagationPhases.captured]))event._dispatchListeners=accumulateInto(event._dispatchListeners,upwards),event._dispatchInstances=accumulateInto(event._dispatchInstances,inst)}function accumulateTwoPhaseDispatchesSingle(event){event&&\nevent.dispatchConfig.phasedRegistrationNames&&EventPluginUtils.traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event)}function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;targetInst=targetInst?EventPluginUtils.getParentInstance(targetInst):null;EventPluginUtils.traverseTwoPhase(targetInst,accumulateDirectionalDispatches,event)}}function accumulateDispatches(inst,ignoredDirection,event){event&&\nevent.dispatchConfig.registrationName&&(ignoredDirection=getListener(inst,event.dispatchConfig.registrationName))&&(event._dispatchListeners=accumulateInto(event._dispatchListeners,ignoredDirection),event._dispatchInstances=accumulateInto(event._dispatchInstances,inst))}function accumulateDirectDispatchesSingle(event){event&&event.dispatchConfig.registrationName&&accumulateDispatches(event._targetInst,null,event)}global=require(\"module$node_modules$react$lib$EventConstants\");exports=require(\"module$node_modules$react$lib$EventPluginHub\");\nvar EventPluginUtils=require(\"module$node_modules$react$lib$EventPluginUtils\"),accumulateInto=require(\"module$node_modules$react$lib$accumulateInto\"),forEachAccumulated=require(\"module$node_modules$react$lib$forEachAccumulated\"),warning=require(\"module$node_modules$fbjs$lib$warning\"),PropagationPhases=global.PropagationPhases,getListener=exports.getListener;module.exports={accumulateTwoPhaseDispatches:function(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle)},accumulateTwoPhaseDispatchesSkipTarget:function(events){forEachAccumulated(events,\naccumulateTwoPhaseDispatchesSingleSkipTarget)},accumulateDirectDispatches:function(events){forEachAccumulated(events,accumulateDirectDispatchesSingle)},accumulateEnterLeaveDispatches:function(leave,enter,from,to){EventPluginUtils.traverseEnterLeave(from,to,accumulateDispatches,leave,enter)}}}","~:source","shadow$provide[\"module$node_modules$react$lib$EventPropagators\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n'use strict';\n\nvar EventConstants = require('./EventConstants');\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPluginUtils = require('./EventPluginUtils');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\nvar warning = require('fbjs/lib/warning');\n\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, upwards, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$lib$forEachAccumulated","~$module$node_modules$react$lib$EventPluginHub","~$shadow.js","~$module$node_modules$react$lib$accumulateInto","~$module$node_modules$react$lib$EventPluginUtils","~$module$node_modules$react$lib$EventConstants","~$module$node_modules$fbjs$lib$warning"]],"~:properties",["^5",["_dispatchListeners","accumulateDirectDispatches","accumulateTwoPhaseDispatches","accumulateEnterLeaveDispatches","accumulateTwoPhaseDispatchesSkipTarget","_dispatchInstances"]],"~:compiled-at",1635250628381,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$EventPropagators.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/EventPropagators.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$EventPropagators\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule EventPropagators\\n */\\n\\n'use strict';\\n\\nvar EventConstants = require('./EventConstants');\\nvar EventPluginHub = require('./EventPluginHub');\\nvar EventPluginUtils = require('./EventPluginUtils');\\n\\nvar accumulateInto = require('./accumulateInto');\\nvar forEachAccumulated = require('./forEachAccumulated');\\nvar warning = require('fbjs/lib/warning');\\n\\nvar PropagationPhases = EventConstants.PropagationPhases;\\nvar getListener = EventPluginHub.getListener;\\n\\n/**\\n * Some event types have a notion of different registration names for different\\n * \\\"phases\\\" of propagation. This finds listeners by a given phase.\\n */\\nfunction listenerAtPhase(inst, event, propagationPhase) {\\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\\n  return getListener(inst, registrationName);\\n}\\n\\n/**\\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\\n * here, allows us to not have to bind or create functions for each event.\\n * Mutating the event's members allows us to not have to create a wrapping\\n * \\\"dispatch\\\" object that pairs the event with the listener.\\n */\\nfunction accumulateDirectionalDispatches(inst, upwards, event) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;\\n  }\\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\\n  var listener = listenerAtPhase(inst, event, phase);\\n  if (listener) {\\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\\n  }\\n}\\n\\n/**\\n * Collect dispatches (must be entirely collected before dispatching - see unit\\n * tests). Lazily allocate the array to conserve memory.  We must loop through\\n * each event and perform the traversal for each one. We cannot perform a\\n * single traversal for the entire collection of events because each event may\\n * have a different target.\\n */\\nfunction accumulateTwoPhaseDispatchesSingle(event) {\\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\\n    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\\n  }\\n}\\n\\n/**\\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\\n */\\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\\n    var targetInst = event._targetInst;\\n    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;\\n    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\\n  }\\n}\\n\\n/**\\n * Accumulates without regard to direction, does not look for phased\\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\\n */\\nfunction accumulateDispatches(inst, ignoredDirection, event) {\\n  if (event && event.dispatchConfig.registrationName) {\\n    var registrationName = event.dispatchConfig.registrationName;\\n    var listener = getListener(inst, registrationName);\\n    if (listener) {\\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\\n    }\\n  }\\n}\\n\\n/**\\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\\n * `dispatchMarker`.\\n * @param {SyntheticEvent} event\\n */\\nfunction accumulateDirectDispatchesSingle(event) {\\n  if (event && event.dispatchConfig.registrationName) {\\n    accumulateDispatches(event._targetInst, null, event);\\n  }\\n}\\n\\nfunction accumulateTwoPhaseDispatches(events) {\\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\\n}\\n\\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\\n}\\n\\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\\n  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\\n}\\n\\nfunction accumulateDirectDispatches(events) {\\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\\n}\\n\\n/**\\n * A small set of propagation patterns, each of which will accept a small amount\\n * of information, and generate a set of \\\"dispatch ready event objects\\\" - which\\n * are sets of events that have already been annotated with a set of dispatched\\n * listener functions/ids. The API is designed this way to discourage these\\n * propagation strategies from actually executing the dispatches, since we\\n * always want to collect the entire set of dispatches before executing event a\\n * single one.\\n *\\n * @constructor EventPropagators\\n */\\nvar EventPropagators = {\\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\\n  accumulateDirectDispatches: accumulateDirectDispatches,\\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\\n};\\n\\nmodule.exports = EventPropagators;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"accumulateDirectionalDispatches\",\"inst\",\"upwards\",\"event\",\"warning\",\"getListener\",\"dispatchConfig\",\"phasedRegistrationNames\",\"registrationName\",\"phase\",\"PropagationPhases\",\"bubbled\",\"captured\",\"_dispatchListeners\",\"accumulateInto\",\"listener\",\"_dispatchInstances\",\"accumulateTwoPhaseDispatchesSingle\",\"EventPluginUtils\",\"traverseTwoPhase\",\"_targetInst\",\"accumulateTwoPhaseDispatchesSingleSkipTarget\",\"targetInst\",\"parentInst\",\"getParentInstance\",\"accumulateDispatches\",\"ignoredDirection\",\"accumulateDirectDispatchesSingle\",\"EventConstants\",\"EventPluginHub\",\"forEachAccumulated\",\"EventPropagators\",\"accumulateTwoPhaseDispatches\",\"events\",\"accumulateTwoPhaseDispatchesSkipTarget\",\"accumulateDirectDispatches\",\"accumulateEnterLeaveDispatches\",\"leave\",\"enter\",\"from\",\"to\",\"traverseEnterLeave\"]\n}\n"]