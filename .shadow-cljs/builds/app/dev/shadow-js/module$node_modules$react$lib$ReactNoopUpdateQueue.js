["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactNoopUpdateQueue.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactNoopUpdateQueue=function(global,process,require,module,exports,shadow$shims){function warnNoop(publicInstance,callerName){publicInstance=publicInstance.constructor;warning(!1,\"%s(...): Can only update a mounted or mounting component. This usually means you called %s() on an unmounted component. This is a no-op. Please check the code for the %s component.\",callerName,callerName,publicInstance&&(publicInstance.displayName||publicInstance.name)||\"ReactClass\")}\nvar warning=require(\"module$node_modules$fbjs$lib$warning\");module.exports={isMounted:function(publicInstance){return!1},enqueueCallback:function(publicInstance,callback){},enqueueForceUpdate:function(publicInstance){warnNoop(publicInstance,\"forceUpdate\")},enqueueReplaceState:function(publicInstance,completeState){warnNoop(publicInstance,\"replaceState\")},enqueueSetState:function(publicInstance,partialState){warnNoop(publicInstance,\"setState\")}}}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactNoopUpdateQueue\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar warning = require('fbjs/lib/warning');\n\nfunction warnNoop(publicInstance, callerName) {\n  if (process.env.NODE_ENV !== 'production') {\n    var constructor = publicInstance.constructor;\n    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {},\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nmodule.exports = ReactNoopUpdateQueue;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$warning"]],"~:properties",["^5",["enqueueForceUpdate","enqueueReplaceState","enqueueCallback","isMounted","enqueueSetState"]],"~:compiled-at",1635270336773,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactNoopUpdateQueue.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,mDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAepIC,QAASA,SAAQ,CAACC,cAAD,CAAiBC,UAAjB,CAA6B,CAEtCC,cAAAA,CAAcF,cAAAE,YACsBC,QAAA,CAAQ,CAAA,CAAR,CAAe,sLAAf,CAAiNF,UAAjN,CAA6NA,UAA7N,CAAyOC,cAAzO,GAAyPA,cAAAE,YAAzP,EAAoRF,cAAAG,KAApR,GAAyS,YAAzS,CAHE;AAF9C,IAAIF,QAAUR,OAAA,CAAQ,sCAAR,CAkFdC,OAAAC,QAAA,CAtE2BS,CASzBC,UAAWA,QAAS,CAACP,cAAD,CAAiB,CACnC,MAAO,CAAA,CAD4B,CATZM,CAqBzBE,gBAAiBA,QAAS,CAACR,cAAD,CAAiBS,QAAjB,CAA2B,EArB5BH,CAoCzBI,mBAAoBA,QAAS,CAACV,cAAD,CAAiB,CAC5CD,QAAA,CAASC,cAAT,CAAyB,aAAzB,CAD4C,CApCrBM,CAmDzBK,oBAAqBA,QAAS,CAACX,cAAD,CAAiBY,aAAjB,CAAgC,CAC5Db,QAAA,CAASC,cAAT,CAAyB,cAAzB,CAD4D,CAnDrCM,CAiEzBO,gBAAiBA,QAAS,CAACb,cAAD,CAAiBc,YAAjB,CAA+B,CACvDf,QAAA,CAASC,cAAT,CAAyB,UAAzB,CADuD,CAjEhCM,CAzByG;\",\n\"sources\":[\"node_modules/react/lib/ReactNoopUpdateQueue.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactNoopUpdateQueue\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2015-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar warning = require('fbjs/lib/warning');\\n\\nfunction warnNoop(publicInstance, callerName) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    var constructor = publicInstance.constructor;\\n    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;\\n  }\\n}\\n\\n/**\\n * This is the abstract API for an update queue.\\n */\\nvar ReactNoopUpdateQueue = {\\n\\n  /**\\n   * Checks whether or not this composite component is mounted.\\n   * @param {ReactClass} publicInstance The instance we want to test.\\n   * @return {boolean} True if mounted, false otherwise.\\n   * @protected\\n   * @final\\n   */\\n  isMounted: function (publicInstance) {\\n    return false;\\n  },\\n\\n  /**\\n   * Enqueue a callback that will be executed after all the pending updates\\n   * have processed.\\n   *\\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\\n   * @param {?function} callback Called after state is updated.\\n   * @internal\\n   */\\n  enqueueCallback: function (publicInstance, callback) {},\\n\\n  /**\\n   * Forces an update. This should only be invoked when it is known with\\n   * certainty that we are **not** in a DOM transaction.\\n   *\\n   * You may want to call this when you know that some deeper aspect of the\\n   * component's state has changed but `setState` was not called.\\n   *\\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\\n   * `componentWillUpdate` and `componentDidUpdate`.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @internal\\n   */\\n  enqueueForceUpdate: function (publicInstance) {\\n    warnNoop(publicInstance, 'forceUpdate');\\n  },\\n\\n  /**\\n   * Replaces all of the state. Always use this or `setState` to mutate state.\\n   * You should treat `this.state` as immutable.\\n   *\\n   * There is no guarantee that `this.state` will be immediately updated, so\\n   * accessing `this.state` after calling this method may return the old value.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @param {object} completeState Next state.\\n   * @internal\\n   */\\n  enqueueReplaceState: function (publicInstance, completeState) {\\n    warnNoop(publicInstance, 'replaceState');\\n  },\\n\\n  /**\\n   * Sets a subset of the state. This only exists because _pendingState is\\n   * internal. This provides a merging strategy that is not available to deep\\n   * properties which is confusing. TODO: Expose pendingState or don't use it\\n   * during the merge.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @param {object} partialState Next partial state to be merged with state.\\n   * @internal\\n   */\\n  enqueueSetState: function (publicInstance, partialState) {\\n    warnNoop(publicInstance, 'setState');\\n  }\\n};\\n\\nmodule.exports = ReactNoopUpdateQueue;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"warnNoop\",\"publicInstance\",\"callerName\",\"constructor\",\"warning\",\"displayName\",\"name\",\"ReactNoopUpdateQueue\",\"isMounted\",\"enqueueCallback\",\"callback\",\"enqueueForceUpdate\",\"enqueueReplaceState\",\"completeState\",\"enqueueSetState\",\"partialState\"]\n}\n"]