["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/DOMLazyTree.js"],"~:js","shadow$provide.module$node_modules$react$lib$DOMLazyTree=function(global,require,module,exports){function insertTreeChildren(tree){if(enableLazy){var node=tree.node,children=tree.children;if(children.length)for(tree=0;tree<children.length;tree++)insertTreeBefore(node,children[tree],null);else null!=tree.html?setInnerHTML(node,tree.html):null!=tree.text&&setTextContent(node,tree.text)}}function toString(){return this.node.nodeName}function DOMLazyTree(node){return{node,children:[],html:null,text:null,\ntoString}}var DOMNamespaces=require(\"module$node_modules$react$lib$DOMNamespaces\"),setInnerHTML=require(\"module$node_modules$react$lib$setInnerHTML\");global=require(\"module$node_modules$react$lib$createMicrosoftUnsafeLocalFunction\");var setTextContent=require(\"module$node_modules$react$lib$setTextContent\"),enableLazy=\"undefined\"!==typeof document&&\"number\"===typeof document.documentMode||\"undefined\"!==typeof navigator&&\"string\"===typeof navigator.userAgent&&/\\bEdge\\/\\d/.test(navigator.userAgent),\ninsertTreeBefore=global(function(parentNode,tree,referenceNode){11===tree.node.nodeType||1===tree.node.nodeType&&\"object\"===tree.node.nodeName.toLowerCase()&&(null==tree.node.namespaceURI||tree.node.namespaceURI===DOMNamespaces.html)?(insertTreeChildren(tree),parentNode.insertBefore(tree.node,referenceNode)):(parentNode.insertBefore(tree.node,referenceNode),insertTreeChildren(tree))});DOMLazyTree.insertTreeBefore=insertTreeBefore;DOMLazyTree.replaceChildWithTree=function(oldNode,newTree){oldNode.parentNode.replaceChild(newTree.node,\noldNode);insertTreeChildren(newTree)};DOMLazyTree.queueChild=function(parentTree,childTree){enableLazy?parentTree.children.push(childTree):parentTree.node.appendChild(childTree.node)};DOMLazyTree.queueHTML=function(tree,html){enableLazy?tree.html=html:setInnerHTML(tree.node,html)};DOMLazyTree.queueText=function(tree,text){enableLazy?tree.text=text:setTextContent(tree.node,text)};module.exports=DOMLazyTree}","~:source","shadow$provide[\"module$node_modules$react$lib$DOMLazyTree\"] = function(global,require,module,exports) {\n/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMLazyTree\n */\n\n'use strict';\n\nvar DOMNamespaces = require('./DOMNamespaces');\nvar setInnerHTML = require('./setInnerHTML');\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\nvar setTextContent = require('./setTextContent');\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\n/**\n * In IE (8-11) and Edge, appending nodes with no children is dramatically\n * faster than appending a full subtree, so we essentially queue up the\n * .appendChild calls here and apply them so each node is added to its parent\n * before any children are added.\n *\n * In other browsers, doing so is slower or neutral compared to the other order\n * (in Firefox, twice as slow) so we only do this inversion in IE.\n *\n * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.\n */\nvar enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\\bEdge\\/\\d/.test(navigator.userAgent);\n\nfunction insertTreeChildren(tree) {\n  if (!enableLazy) {\n    return;\n  }\n  var node = tree.node;\n  var children = tree.children;\n  if (children.length) {\n    for (var i = 0; i < children.length; i++) {\n      insertTreeBefore(node, children[i], null);\n    }\n  } else if (tree.html != null) {\n    setInnerHTML(node, tree.html);\n  } else if (tree.text != null) {\n    setTextContent(node, tree.text);\n  }\n}\n\nvar insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {\n  // DocumentFragments aren't actually part of the DOM after insertion so\n  // appending children won't update the DOM. We need to ensure the fragment\n  // is properly populated first, breaking out of our lazy approach for just\n  // this level. Also, some <object> plugins (like Flash Player) will read\n  // <param> nodes immediately upon insertion into the DOM, so <object>\n  // must also be populated prior to insertion into the DOM.\n  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {\n    insertTreeChildren(tree);\n    parentNode.insertBefore(tree.node, referenceNode);\n  } else {\n    parentNode.insertBefore(tree.node, referenceNode);\n    insertTreeChildren(tree);\n  }\n});\n\nfunction replaceChildWithTree(oldNode, newTree) {\n  oldNode.parentNode.replaceChild(newTree.node, oldNode);\n  insertTreeChildren(newTree);\n}\n\nfunction queueChild(parentTree, childTree) {\n  if (enableLazy) {\n    parentTree.children.push(childTree);\n  } else {\n    parentTree.node.appendChild(childTree.node);\n  }\n}\n\nfunction queueHTML(tree, html) {\n  if (enableLazy) {\n    tree.html = html;\n  } else {\n    setInnerHTML(tree.node, html);\n  }\n}\n\nfunction queueText(tree, text) {\n  if (enableLazy) {\n    tree.text = text;\n  } else {\n    setTextContent(tree.node, text);\n  }\n}\n\nfunction toString() {\n  return this.node.nodeName;\n}\n\nfunction DOMLazyTree(node) {\n  return {\n    node: node,\n    children: [],\n    html: null,\n    text: null,\n    toString: toString\n  };\n}\n\nDOMLazyTree.insertTreeBefore = insertTreeBefore;\nDOMLazyTree.replaceChildWithTree = replaceChildWithTree;\nDOMLazyTree.queueChild = queueChild;\nDOMLazyTree.queueHTML = queueHTML;\nDOMLazyTree.queueText = queueText;\n\nmodule.exports = DOMLazyTree;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$lib$createMicrosoftUnsafeLocalFunction","~$module$node_modules$react$lib$setTextContent","~$shadow.js","~$module$node_modules$react$lib$setInnerHTML","~$module$node_modules$react$lib$DOMNamespaces"]],"~:properties",["^5",["queueText","queueChild","children","toString","replaceChildWithTree","insertTreeBefore","text","queueHTML","html","node"]],"~:compiled-at",1635250628393,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$DOMLazyTree.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/DOMLazyTree.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$DOMLazyTree\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2015-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule DOMLazyTree\\n */\\n\\n'use strict';\\n\\nvar DOMNamespaces = require('./DOMNamespaces');\\nvar setInnerHTML = require('./setInnerHTML');\\n\\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\\nvar setTextContent = require('./setTextContent');\\n\\nvar ELEMENT_NODE_TYPE = 1;\\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\\n\\n/**\\n * In IE (8-11) and Edge, appending nodes with no children is dramatically\\n * faster than appending a full subtree, so we essentially queue up the\\n * .appendChild calls here and apply them so each node is added to its parent\\n * before any children are added.\\n *\\n * In other browsers, doing so is slower or neutral compared to the other order\\n * (in Firefox, twice as slow) so we only do this inversion in IE.\\n *\\n * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.\\n */\\nvar enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\\\\bEdge\\\\/\\\\d/.test(navigator.userAgent);\\n\\nfunction insertTreeChildren(tree) {\\n  if (!enableLazy) {\\n    return;\\n  }\\n  var node = tree.node;\\n  var children = tree.children;\\n  if (children.length) {\\n    for (var i = 0; i < children.length; i++) {\\n      insertTreeBefore(node, children[i], null);\\n    }\\n  } else if (tree.html != null) {\\n    setInnerHTML(node, tree.html);\\n  } else if (tree.text != null) {\\n    setTextContent(node, tree.text);\\n  }\\n}\\n\\nvar insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {\\n  // DocumentFragments aren't actually part of the DOM after insertion so\\n  // appending children won't update the DOM. We need to ensure the fragment\\n  // is properly populated first, breaking out of our lazy approach for just\\n  // this level. Also, some <object> plugins (like Flash Player) will read\\n  // <param> nodes immediately upon insertion into the DOM, so <object>\\n  // must also be populated prior to insertion into the DOM.\\n  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {\\n    insertTreeChildren(tree);\\n    parentNode.insertBefore(tree.node, referenceNode);\\n  } else {\\n    parentNode.insertBefore(tree.node, referenceNode);\\n    insertTreeChildren(tree);\\n  }\\n});\\n\\nfunction replaceChildWithTree(oldNode, newTree) {\\n  oldNode.parentNode.replaceChild(newTree.node, oldNode);\\n  insertTreeChildren(newTree);\\n}\\n\\nfunction queueChild(parentTree, childTree) {\\n  if (enableLazy) {\\n    parentTree.children.push(childTree);\\n  } else {\\n    parentTree.node.appendChild(childTree.node);\\n  }\\n}\\n\\nfunction queueHTML(tree, html) {\\n  if (enableLazy) {\\n    tree.html = html;\\n  } else {\\n    setInnerHTML(tree.node, html);\\n  }\\n}\\n\\nfunction queueText(tree, text) {\\n  if (enableLazy) {\\n    tree.text = text;\\n  } else {\\n    setTextContent(tree.node, text);\\n  }\\n}\\n\\nfunction toString() {\\n  return this.node.nodeName;\\n}\\n\\nfunction DOMLazyTree(node) {\\n  return {\\n    node: node,\\n    children: [],\\n    html: null,\\n    text: null,\\n    toString: toString\\n  };\\n}\\n\\nDOMLazyTree.insertTreeBefore = insertTreeBefore;\\nDOMLazyTree.replaceChildWithTree = replaceChildWithTree;\\nDOMLazyTree.queueChild = queueChild;\\nDOMLazyTree.queueHTML = queueHTML;\\nDOMLazyTree.queueText = queueText;\\n\\nmodule.exports = DOMLazyTree;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"insertTreeChildren\",\"tree\",\"enableLazy\",\"node\",\"children\",\"length\",\"i\",\"insertTreeBefore\",\"html\",\"setInnerHTML\",\"text\",\"setTextContent\",\"toString\",\"nodeName\",\"DOMLazyTree\",\"DOMNamespaces\",\"createMicrosoftUnsafeLocalFunction\",\"document\",\"documentMode\",\"navigator\",\"userAgent\",\"test\",\"parentNode\",\"referenceNode\",\"DOCUMENT_FRAGMENT_NODE_TYPE\",\"nodeType\",\"ELEMENT_NODE_TYPE\",\"toLowerCase\",\"namespaceURI\",\"insertBefore\",\"replaceChildWithTree\",\"oldNode\",\"newTree\",\"replaceChild\",\"queueChild\",\"parentTree\",\"childTree\",\"push\",\"appendChild\",\"queueHTML\",\"queueText\"]\n}\n"]