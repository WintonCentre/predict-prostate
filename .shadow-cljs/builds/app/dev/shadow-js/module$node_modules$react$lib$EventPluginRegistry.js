["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/EventPluginRegistry.js"],"~:js","shadow$provide.module$node_modules$react$lib$EventPluginRegistry=function(global,require,module,exports){function recomputePluginOrdering(){if(EventPluginOrder)for(var pluginName in namesToPlugins){var PluginModule=namesToPlugins[pluginName],pluginIndex=EventPluginOrder.indexOf(pluginName);-1<pluginIndex?void 0:invariant(!1,\"EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.\",pluginName);if(!EventPluginRegistry.plugins[pluginIndex]){PluginModule.extractEvents?\nvoid 0:invariant(!1,\"EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.\",pluginName);EventPluginRegistry.plugins[pluginIndex]=PluginModule;pluginIndex=PluginModule.eventTypes;for(var eventName in pluginIndex){var JSCompiler_inline_result=void 0;var dispatchConfig=pluginIndex[eventName],PluginModule$jscomp$0=PluginModule,eventName$jscomp$0=eventName;EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0)?invariant(!1,\"EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.\",\neventName$jscomp$0):void 0;EventPluginRegistry.eventNameDispatchConfigs[eventName$jscomp$0]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(JSCompiler_inline_result in phasedRegistrationNames)phasedRegistrationNames.hasOwnProperty(JSCompiler_inline_result)&&publishRegistrationName(phasedRegistrationNames[JSCompiler_inline_result],PluginModule$jscomp$0,eventName$jscomp$0);JSCompiler_inline_result=!0}else dispatchConfig.registrationName?\n(publishRegistrationName(dispatchConfig.registrationName,PluginModule$jscomp$0,eventName$jscomp$0),JSCompiler_inline_result=!0):JSCompiler_inline_result=!1;JSCompiler_inline_result?void 0:invariant(!1,\"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",eventName,pluginName)}}}}function publishRegistrationName(registrationName,PluginModule,eventName){EventPluginRegistry.registrationNameModules[registrationName]?invariant(!1,\"EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.\",\nregistrationName):void 0;EventPluginRegistry.registrationNameModules[registrationName]=PluginModule;EventPluginRegistry.registrationNameDependencies[registrationName]=PluginModule.eventTypes[eventName].dependencies;PluginModule=registrationName.toLowerCase();EventPluginRegistry.possibleRegistrationNames[PluginModule]=registrationName;\"onDoubleClick\"===registrationName&&(EventPluginRegistry.possibleRegistrationNames.ondblclick=registrationName)}require(\"module$node_modules$react$lib$reactProdInvariant\");\nvar invariant=require(\"module$node_modules$fbjs$lib$invariant\"),EventPluginOrder=null,namesToPlugins={},EventPluginRegistry={plugins:[],eventNameDispatchConfigs:{},registrationNameModules:{},registrationNameDependencies:{},possibleRegistrationNames:{},injectEventPluginOrder:function(InjectedEventPluginOrder){EventPluginOrder?invariant(!1,\"EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.\"):void 0;EventPluginOrder=Array.prototype.slice.call(InjectedEventPluginOrder);\nrecomputePluginOrdering()},injectEventPluginsByName:function(injectedNamesToPlugins){var isOrderingDirty=!1,pluginName;for(pluginName in injectedNamesToPlugins)if(injectedNamesToPlugins.hasOwnProperty(pluginName)){var PluginModule=injectedNamesToPlugins[pluginName];namesToPlugins.hasOwnProperty(pluginName)&&namesToPlugins[pluginName]===PluginModule||(namesToPlugins[pluginName]?invariant(!1,\"EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.\",pluginName):void 0,\nnamesToPlugins[pluginName]=PluginModule,isOrderingDirty=!0)}isOrderingDirty&&recomputePluginOrdering()},getPluginModuleForEvent:function(event){event=event.dispatchConfig;if(event.registrationName)return EventPluginRegistry.registrationNameModules[event.registrationName]||null;for(var phase in event.phasedRegistrationNames)if(event.phasedRegistrationNames.hasOwnProperty(phase)){var PluginModule=EventPluginRegistry.registrationNameModules[event.phasedRegistrationNames[phase]];if(PluginModule)return PluginModule}return null},\n_resetEventPlugins:function(){EventPluginOrder=null;for(var pluginName in namesToPlugins)namesToPlugins.hasOwnProperty(pluginName)&&delete namesToPlugins[pluginName];EventPluginRegistry.plugins.length=0;pluginName=EventPluginRegistry.eventNameDispatchConfigs;for(var eventName in pluginName)pluginName.hasOwnProperty(eventName)&&delete pluginName[eventName];eventName=EventPluginRegistry.registrationNameModules;for(var registrationName in eventName)eventName.hasOwnProperty(registrationName)&&delete eventName[registrationName];\nregistrationName=EventPluginRegistry.possibleRegistrationNames;for(var lowerCasedName in registrationName)registrationName.hasOwnProperty(lowerCasedName)&&delete registrationName[lowerCasedName]}};module.exports=EventPluginRegistry}","~:source","shadow$provide[\"module$node_modules$react$lib$EventPluginRegistry\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginRegistry\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Injectable ordering of event plugins.\n */\nvar EventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!EventPluginOrder) {\n    // Wait until an `EventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var PluginModule = namesToPlugins[pluginName];\n    var pluginIndex = EventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;\n    if (EventPluginRegistry.plugins[pluginIndex]) {\n      continue;\n    }\n    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;\n    EventPluginRegistry.plugins[pluginIndex] = PluginModule;\n    var publishedEvents = PluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, PluginModule, eventName) {\n  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events and\n * can be used with `EventPluginHub.putListener` to register listeners.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, PluginModule, eventName) {\n  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;\n  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;\n  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var lowerCasedName = registrationName.toLowerCase();\n    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\nvar EventPluginRegistry = {\n\n  /**\n   * Ordered list of injected plugins.\n   */\n  plugins: [],\n\n  /**\n   * Mapping from event name to dispatch config\n   */\n  eventNameDispatchConfigs: {},\n\n  /**\n   * Mapping from registration name to plugin module\n   */\n  registrationNameModules: {},\n\n  /**\n   * Mapping from registration name to event name\n   */\n  registrationNameDependencies: {},\n\n  /**\n   * Mapping from lowercase registration names to the properly cased version,\n   * used to warn in the case of missing event handlers. Available\n   * only in __DEV__.\n   * @type {Object}\n   */\n  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,\n\n  /**\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\n   * to be decoupled from injection of the actual plugins so that ordering is\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\n   *\n   * @param {array} InjectedEventPluginOrder\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\n   */\n  injectEventPluginOrder: function (InjectedEventPluginOrder) {\n    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;\n    // Clone the ordering so it cannot be dynamically mutated.\n    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);\n    recomputePluginOrdering();\n  },\n\n  /**\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n   * in the ordering injected by `injectEventPluginOrder`.\n   *\n   * Plugins can be injected as part of page initialization or on-the-fly.\n   *\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\n   */\n  injectEventPluginsByName: function (injectedNamesToPlugins) {\n    var isOrderingDirty = false;\n    for (var pluginName in injectedNamesToPlugins) {\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n        continue;\n      }\n      var PluginModule = injectedNamesToPlugins[pluginName];\n      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {\n        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;\n        namesToPlugins[pluginName] = PluginModule;\n        isOrderingDirty = true;\n      }\n    }\n    if (isOrderingDirty) {\n      recomputePluginOrdering();\n    }\n  },\n\n  /**\n   * Looks up the plugin for the supplied event.\n   *\n   * @param {object} event A synthetic event.\n   * @return {?object} The plugin that created the supplied event.\n   * @internal\n   */\n  getPluginModuleForEvent: function (event) {\n    var dispatchConfig = event.dispatchConfig;\n    if (dispatchConfig.registrationName) {\n      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;\n    }\n    for (var phase in dispatchConfig.phasedRegistrationNames) {\n      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {\n        continue;\n      }\n      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];\n      if (PluginModule) {\n        return PluginModule;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _resetEventPlugins: function () {\n    EventPluginOrder = null;\n    for (var pluginName in namesToPlugins) {\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\n        delete namesToPlugins[pluginName];\n      }\n    }\n    EventPluginRegistry.plugins.length = 0;\n\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\n    for (var eventName in eventNameDispatchConfigs) {\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\n        delete eventNameDispatchConfigs[eventName];\n      }\n    }\n\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\n    for (var registrationName in registrationNameModules) {\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\n        delete registrationNameModules[registrationName];\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;\n      for (var lowerCasedName in possibleRegistrationNames) {\n        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {\n          delete possibleRegistrationNames[lowerCasedName];\n        }\n      }\n    }\n  }\n\n};\n\nmodule.exports = EventPluginRegistry;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react$lib$reactProdInvariant"]],"~:properties",["^5",["registrationNameDependencies","injectEventPluginOrder","ondblclick","possibleRegistrationNames","eventNameDispatchConfigs","length","registrationNameModules","injectEventPluginsByName","_resetEventPlugins","getPluginModuleForEvent","plugins"]],"~:compiled-at",1635250628376,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$EventPluginRegistry.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/EventPluginRegistry.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$EventPluginRegistry\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule EventPluginRegistry\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Injectable ordering of event plugins.\\n */\\nvar EventPluginOrder = null;\\n\\n/**\\n * Injectable mapping from names to event plugin modules.\\n */\\nvar namesToPlugins = {};\\n\\n/**\\n * Recomputes the plugin list using the injected plugins and plugin ordering.\\n *\\n * @private\\n */\\nfunction recomputePluginOrdering() {\\n  if (!EventPluginOrder) {\\n    // Wait until an `EventPluginOrder` is injected.\\n    return;\\n  }\\n  for (var pluginName in namesToPlugins) {\\n    var PluginModule = namesToPlugins[pluginName];\\n    var pluginIndex = EventPluginOrder.indexOf(pluginName);\\n    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;\\n    if (EventPluginRegistry.plugins[pluginIndex]) {\\n      continue;\\n    }\\n    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;\\n    EventPluginRegistry.plugins[pluginIndex] = PluginModule;\\n    var publishedEvents = PluginModule.eventTypes;\\n    for (var eventName in publishedEvents) {\\n      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;\\n    }\\n  }\\n}\\n\\n/**\\n * Publishes an event so that it can be dispatched by the supplied plugin.\\n *\\n * @param {object} dispatchConfig Dispatch configuration for the event.\\n * @param {object} PluginModule Plugin publishing the event.\\n * @return {boolean} True if the event was successfully published.\\n * @private\\n */\\nfunction publishEventForPlugin(dispatchConfig, PluginModule, eventName) {\\n  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;\\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\\n\\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\\n  if (phasedRegistrationNames) {\\n    for (var phaseName in phasedRegistrationNames) {\\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\\n        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);\\n      }\\n    }\\n    return true;\\n  } else if (dispatchConfig.registrationName) {\\n    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);\\n    return true;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Publishes a registration name that is used to identify dispatched events and\\n * can be used with `EventPluginHub.putListener` to register listeners.\\n *\\n * @param {string} registrationName Registration name to add.\\n * @param {object} PluginModule Plugin publishing the event.\\n * @private\\n */\\nfunction publishRegistrationName(registrationName, PluginModule, eventName) {\\n  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;\\n  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;\\n  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    var lowerCasedName = registrationName.toLowerCase();\\n    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;\\n\\n    if (registrationName === 'onDoubleClick') {\\n      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;\\n    }\\n  }\\n}\\n\\n/**\\n * Registers plugins so that they can extract and dispatch events.\\n *\\n * @see {EventPluginHub}\\n */\\nvar EventPluginRegistry = {\\n\\n  /**\\n   * Ordered list of injected plugins.\\n   */\\n  plugins: [],\\n\\n  /**\\n   * Mapping from event name to dispatch config\\n   */\\n  eventNameDispatchConfigs: {},\\n\\n  /**\\n   * Mapping from registration name to plugin module\\n   */\\n  registrationNameModules: {},\\n\\n  /**\\n   * Mapping from registration name to event name\\n   */\\n  registrationNameDependencies: {},\\n\\n  /**\\n   * Mapping from lowercase registration names to the properly cased version,\\n   * used to warn in the case of missing event handlers. Available\\n   * only in __DEV__.\\n   * @type {Object}\\n   */\\n  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,\\n\\n  /**\\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\\n   * to be decoupled from injection of the actual plugins so that ordering is\\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\\n   *\\n   * @param {array} InjectedEventPluginOrder\\n   * @internal\\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\\n   */\\n  injectEventPluginOrder: function (InjectedEventPluginOrder) {\\n    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;\\n    // Clone the ordering so it cannot be dynamically mutated.\\n    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);\\n    recomputePluginOrdering();\\n  },\\n\\n  /**\\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\\n   * in the ordering injected by `injectEventPluginOrder`.\\n   *\\n   * Plugins can be injected as part of page initialization or on-the-fly.\\n   *\\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\\n   * @internal\\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\\n   */\\n  injectEventPluginsByName: function (injectedNamesToPlugins) {\\n    var isOrderingDirty = false;\\n    for (var pluginName in injectedNamesToPlugins) {\\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\\n        continue;\\n      }\\n      var PluginModule = injectedNamesToPlugins[pluginName];\\n      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {\\n        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;\\n        namesToPlugins[pluginName] = PluginModule;\\n        isOrderingDirty = true;\\n      }\\n    }\\n    if (isOrderingDirty) {\\n      recomputePluginOrdering();\\n    }\\n  },\\n\\n  /**\\n   * Looks up the plugin for the supplied event.\\n   *\\n   * @param {object} event A synthetic event.\\n   * @return {?object} The plugin that created the supplied event.\\n   * @internal\\n   */\\n  getPluginModuleForEvent: function (event) {\\n    var dispatchConfig = event.dispatchConfig;\\n    if (dispatchConfig.registrationName) {\\n      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;\\n    }\\n    for (var phase in dispatchConfig.phasedRegistrationNames) {\\n      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {\\n        continue;\\n      }\\n      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];\\n      if (PluginModule) {\\n        return PluginModule;\\n      }\\n    }\\n    return null;\\n  },\\n\\n  /**\\n   * Exposed for unit testing.\\n   * @private\\n   */\\n  _resetEventPlugins: function () {\\n    EventPluginOrder = null;\\n    for (var pluginName in namesToPlugins) {\\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\\n        delete namesToPlugins[pluginName];\\n      }\\n    }\\n    EventPluginRegistry.plugins.length = 0;\\n\\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\\n    for (var eventName in eventNameDispatchConfigs) {\\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\\n        delete eventNameDispatchConfigs[eventName];\\n      }\\n    }\\n\\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\\n    for (var registrationName in registrationNameModules) {\\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\\n        delete registrationNameModules[registrationName];\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;\\n      for (var lowerCasedName in possibleRegistrationNames) {\\n        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {\\n          delete possibleRegistrationNames[lowerCasedName];\\n        }\\n      }\\n    }\\n  }\\n\\n};\\n\\nmodule.exports = EventPluginRegistry;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"recomputePluginOrdering\",\"EventPluginOrder\",\"pluginName\",\"namesToPlugins\",\"PluginModule\",\"pluginIndex\",\"indexOf\",\"invariant\",\"EventPluginRegistry\",\"plugins\",\"extractEvents\",\"publishedEvents\",\"eventTypes\",\"eventName\",\"phaseName\",\"eventNameDispatchConfigs\",\"hasOwnProperty\",\"dispatchConfig\",\"phasedRegistrationNames\",\"publishRegistrationName\",\"phasedRegistrationName\",\"registrationName\",\"registrationNameModules\",\"registrationNameDependencies\",\"dependencies\",\"lowerCasedName\",\"toLowerCase\",\"possibleRegistrationNames\",\"ondblclick\",\"injectEventPluginOrder\",\"InjectedEventPluginOrder\",\"Array\",\"prototype\",\"slice\",\"call\",\"injectEventPluginsByName\",\"injectedNamesToPlugins\",\"isOrderingDirty\",\"getPluginModuleForEvent\",\"event\",\"phase\",\"_resetEventPlugins\",\"length\"]\n}\n"]