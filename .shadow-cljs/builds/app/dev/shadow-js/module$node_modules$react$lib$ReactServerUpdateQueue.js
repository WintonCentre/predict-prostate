["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactServerUpdateQueue.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactServerUpdateQueue=function(global,require,module,exports){function warnNoop(publicInstance,callerName){publicInstance=publicInstance.constructor;warning(!1,\"%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op. Please check the code for the %s component.\",callerName,callerName,publicInstance&&(publicInstance.displayName||publicInstance.name)||\"ReactClass\")}var ReactUpdateQueue=\nrequire(\"module$node_modules$react$lib$ReactUpdateQueue\");require(\"module$node_modules$react$lib$Transaction\");var warning=require(\"module$node_modules$fbjs$lib$warning\");global=function(){function ReactServerUpdateQueue(transaction){if(!(this instanceof ReactServerUpdateQueue))throw new TypeError(\"Cannot call a class as a function\");this.transaction=transaction}ReactServerUpdateQueue.prototype.isMounted=function(publicInstance){return!1};ReactServerUpdateQueue.prototype.enqueueCallback=function(publicInstance,\ncallback,callerName){this.transaction.isInTransaction()&&ReactUpdateQueue.enqueueCallback(publicInstance,callback,callerName)};ReactServerUpdateQueue.prototype.enqueueForceUpdate=function(publicInstance){this.transaction.isInTransaction()?ReactUpdateQueue.enqueueForceUpdate(publicInstance):warnNoop(publicInstance,\"forceUpdate\")};ReactServerUpdateQueue.prototype.enqueueReplaceState=function(publicInstance,completeState){this.transaction.isInTransaction()?ReactUpdateQueue.enqueueReplaceState(publicInstance,\ncompleteState):warnNoop(publicInstance,\"replaceState\")};ReactServerUpdateQueue.prototype.enqueueSetState=function(publicInstance,partialState){this.transaction.isInTransaction()?ReactUpdateQueue.enqueueSetState(publicInstance,partialState):warnNoop(publicInstance,\"setState\")};return ReactServerUpdateQueue}();module.exports=global}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactServerUpdateQueue\"] = function(global,require,module,exports) {\n/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerUpdateQueue\n * \n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\nvar Transaction = require('./Transaction');\nvar warning = require('fbjs/lib/warning');\n\nfunction warnNoop(publicInstance, callerName) {\n  if (process.env.NODE_ENV !== 'production') {\n    var constructor = publicInstance.constructor;\n    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;\n  }\n}\n\n/**\n * This is the update queue used for server rendering.\n * It delegates to ReactUpdateQueue while server rendering is in progress and\n * switches to ReactNoopUpdateQueue after the transaction has completed.\n * @class ReactServerUpdateQueue\n * @param {Transaction} transaction\n */\n\nvar ReactServerUpdateQueue = function () {\n  /* :: transaction: Transaction; */\n\n  function ReactServerUpdateQueue(transaction) {\n    _classCallCheck(this, ReactServerUpdateQueue);\n\n    this.transaction = transaction;\n  }\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n\n\n  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {\n    return false;\n  };\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n\n\n  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {\n    if (this.transaction.isInTransaction()) {\n      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);\n    }\n  };\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n\n\n  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {\n    if (this.transaction.isInTransaction()) {\n      ReactUpdateQueue.enqueueForceUpdate(publicInstance);\n    } else {\n      warnNoop(publicInstance, 'forceUpdate');\n    }\n  };\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object|function} completeState Next state.\n   * @internal\n   */\n\n\n  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {\n    if (this.transaction.isInTransaction()) {\n      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);\n    } else {\n      warnNoop(publicInstance, 'replaceState');\n    }\n  };\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object|function} partialState Next partial state to be merged with state.\n   * @internal\n   */\n\n\n  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {\n    if (this.transaction.isInTransaction()) {\n      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);\n    } else {\n      warnNoop(publicInstance, 'setState');\n    }\n  };\n\n  return ReactServerUpdateQueue;\n}();\n\nmodule.exports = ReactServerUpdateQueue;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$react$lib$ReactUpdateQueue","~$module$node_modules$fbjs$lib$warning","~$module$node_modules$react$lib$Transaction"]],"~:properties",["^5",["enqueueForceUpdate","enqueueReplaceState","enqueueCallback","transaction","isMounted","enqueueSetState"]],"~:compiled-at",1635250628408,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactServerUpdateQueue.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,oDAAA,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAqBjHC,QAASA,SAAQ,CAACC,cAAD,CAAiBC,UAAjB,CAA6B,CAEtCC,cAAAA,CAAcF,cAAeE,CAAAA,WACOC,QAAA,CAAQ,CAAA,CAAR,CAAe,4LAAf,CAAuNF,UAAvN,CAAmOA,UAAnO,CAA+OC,cAA/O,GAA+PA,cAAYE,CAAAA,WAA3Q,EAA0RF,cAAYG,CAAAA,IAAtS,GAA+S,YAA/S,CAHE,CAJ9C,IAAIC;AAAmBV,OAAA,CAAQ,gDAAR,CACLA,QAAA,CAAQ,2CAAR,CAClB,KAAIO,QAAUP,OAAA,CAAQ,sCAAR,CAiBVW,OAAAA,CAAyB,QAAS,EAAG,CAGvCA,QAASA,uBAAsB,CAACC,WAAD,CAAc,CAxBG,GAAI,EAyBlCC,IAzBkC,WAyB5BF,uBAzB4B,CAAJ,CAA0C,KAAM,KAAIG,SAAJ,CAAc,mCAAd,CAAN,CA2BxF,IAAKF,CAAAA,WAAL,CAAmBA,WAHwB,CAe7CD,sBAAuBI,CAAAA,SAAUC,CAAAA,SAAjC,CAA6CC,QAAkB,CAACb,cAAD,CAAiB,CAC9E,MAAO,CAAA,CADuE,CAchFO,uBAAuBI,CAAAA,SAAUG,CAAAA,eAAjC,CAAmDC,QAAwB,CAACf,cAAD;AAAiBgB,QAAjB,CAA2Bf,UAA3B,CAAuC,CAC5G,IAAKO,CAAAA,WAAYS,CAAAA,eAAjB,EAAJ,EACEX,gBAAiBQ,CAAAA,eAAjB,CAAiCd,cAAjC,CAAiDgB,QAAjD,CAA2Df,UAA3D,CAF8G,CAqBlHM,uBAAuBI,CAAAA,SAAUO,CAAAA,kBAAjC,CAAsDC,QAA2B,CAACnB,cAAD,CAAiB,CAC5F,IAAKQ,CAAAA,WAAYS,CAAAA,eAAjB,EAAJ,CACEX,gBAAiBY,CAAAA,kBAAjB,CAAoClB,cAApC,CADF,CAGED,QAAA,CAASC,cAAT,CAAyB,aAAzB,CAJ8F,CAqBlGO,uBAAuBI,CAAAA,SAAUS,CAAAA,mBAAjC,CAAuDC,QAA4B,CAACrB,cAAD,CAAiBsB,aAAjB,CAAgC,CAC7G,IAAKd,CAAAA,WAAYS,CAAAA,eAAjB,EAAJ,CACEX,gBAAiBc,CAAAA,mBAAjB,CAAqCpB,cAArC;AAAqDsB,aAArD,CADF,CAGEvB,QAAA,CAASC,cAAT,CAAyB,cAAzB,CAJ+G,CAoBnHO,uBAAuBI,CAAAA,SAAUY,CAAAA,eAAjC,CAAmDC,QAAwB,CAACxB,cAAD,CAAiByB,YAAjB,CAA+B,CACpG,IAAKjB,CAAAA,WAAYS,CAAAA,eAAjB,EAAJ,CACEX,gBAAiBiB,CAAAA,eAAjB,CAAiCvB,cAAjC,CAAiDyB,YAAjD,CADF,CAGE1B,QAAA,CAASC,cAAT,CAAyB,UAAzB,CAJsG,CAQ1G,OAAOO,uBAtGgC,CAAZ,EAyG7BV,OAAOC,CAAAA,OAAP,CAAiBS,MA7IgG;\",\n\"sources\":[\"node_modules/react/lib/ReactServerUpdateQueue.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactServerUpdateQueue\\\"] = function(global,require,module,exports) {\\n/**\\n * Copyright 2015-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n * @providesModule ReactServerUpdateQueue\\n * \\n */\\n\\n'use strict';\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\\nvar Transaction = require('./Transaction');\\nvar warning = require('fbjs/lib/warning');\\n\\nfunction warnNoop(publicInstance, callerName) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    var constructor = publicInstance.constructor;\\n    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;\\n  }\\n}\\n\\n/**\\n * This is the update queue used for server rendering.\\n * It delegates to ReactUpdateQueue while server rendering is in progress and\\n * switches to ReactNoopUpdateQueue after the transaction has completed.\\n * @class ReactServerUpdateQueue\\n * @param {Transaction} transaction\\n */\\n\\nvar ReactServerUpdateQueue = function () {\\n  /* :: transaction: Transaction; */\\n\\n  function ReactServerUpdateQueue(transaction) {\\n    _classCallCheck(this, ReactServerUpdateQueue);\\n\\n    this.transaction = transaction;\\n  }\\n\\n  /**\\n   * Checks whether or not this composite component is mounted.\\n   * @param {ReactClass} publicInstance The instance we want to test.\\n   * @return {boolean} True if mounted, false otherwise.\\n   * @protected\\n   * @final\\n   */\\n\\n\\n  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {\\n    return false;\\n  };\\n\\n  /**\\n   * Enqueue a callback that will be executed after all the pending updates\\n   * have processed.\\n   *\\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\\n   * @param {?function} callback Called after state is updated.\\n   * @internal\\n   */\\n\\n\\n  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {\\n    if (this.transaction.isInTransaction()) {\\n      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);\\n    }\\n  };\\n\\n  /**\\n   * Forces an update. This should only be invoked when it is known with\\n   * certainty that we are **not** in a DOM transaction.\\n   *\\n   * You may want to call this when you know that some deeper aspect of the\\n   * component's state has changed but `setState` was not called.\\n   *\\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\\n   * `componentWillUpdate` and `componentDidUpdate`.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @internal\\n   */\\n\\n\\n  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {\\n    if (this.transaction.isInTransaction()) {\\n      ReactUpdateQueue.enqueueForceUpdate(publicInstance);\\n    } else {\\n      warnNoop(publicInstance, 'forceUpdate');\\n    }\\n  };\\n\\n  /**\\n   * Replaces all of the state. Always use this or `setState` to mutate state.\\n   * You should treat `this.state` as immutable.\\n   *\\n   * There is no guarantee that `this.state` will be immediately updated, so\\n   * accessing `this.state` after calling this method may return the old value.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @param {object|function} completeState Next state.\\n   * @internal\\n   */\\n\\n\\n  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {\\n    if (this.transaction.isInTransaction()) {\\n      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);\\n    } else {\\n      warnNoop(publicInstance, 'replaceState');\\n    }\\n  };\\n\\n  /**\\n   * Sets a subset of the state. This only exists because _pendingState is\\n   * internal. This provides a merging strategy that is not available to deep\\n   * properties which is confusing. TODO: Expose pendingState or don't use it\\n   * during the merge.\\n   *\\n   * @param {ReactClass} publicInstance The instance that should rerender.\\n   * @param {object|function} partialState Next partial state to be merged with state.\\n   * @internal\\n   */\\n\\n\\n  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {\\n    if (this.transaction.isInTransaction()) {\\n      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);\\n    } else {\\n      warnNoop(publicInstance, 'setState');\\n    }\\n  };\\n\\n  return ReactServerUpdateQueue;\\n}();\\n\\nmodule.exports = ReactServerUpdateQueue;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"warnNoop\",\"publicInstance\",\"callerName\",\"constructor\",\"warning\",\"displayName\",\"name\",\"ReactUpdateQueue\",\"ReactServerUpdateQueue\",\"transaction\",\"instance\",\"TypeError\",\"prototype\",\"isMounted\",\"ReactServerUpdateQueue.prototype.isMounted\",\"enqueueCallback\",\"ReactServerUpdateQueue.prototype.enqueueCallback\",\"callback\",\"isInTransaction\",\"enqueueForceUpdate\",\"ReactServerUpdateQueue.prototype.enqueueForceUpdate\",\"enqueueReplaceState\",\"ReactServerUpdateQueue.prototype.enqueueReplaceState\",\"completeState\",\"enqueueSetState\",\"ReactServerUpdateQueue.prototype.enqueueSetState\",\"partialState\"]\n}\n"]