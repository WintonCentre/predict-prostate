["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/ReactDOMTreeTraversal.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$ReactDOMTreeTraversal=function(global,process,require,module,exports,shadow$shims){function getLowestCommonAncestor(instA,instB){\"_hostNode\"in instA?void 0:invariant(!1,\"getNodeFromInstance: Invalid argument.\");\"_hostNode\"in instB?void 0:invariant(!1,\"getNodeFromInstance: Invalid argument.\");for(var depthA=0,tempA=instA;tempA;tempA=tempA._hostParent)depthA++;tempA=0;for(var tempB=instB;tempB;tempB=tempB._hostParent)tempA++;for(;0<depthA-tempA;)instA=\ninstA._hostParent,depthA--;for(;0<tempA-depthA;)instB=instB._hostParent,tempA--;for(;depthA--;){if(instA===instB)return instA;instA=instA._hostParent;instB=instB._hostParent}return null}require(\"module$node_modules$react_dom$lib$reactProdInvariant\");var invariant=require(\"module$node_modules$fbjs$lib$invariant\");module.exports={isAncestor:function(instA,instB){\"_hostNode\"in instA?void 0:invariant(!1,\"isAncestor: Invalid argument.\");\"_hostNode\"in instB?void 0:invariant(!1,\"isAncestor: Invalid argument.\");\nfor(;instB;){if(instB===instA)return!0;instB=instB._hostParent}return!1},getLowestCommonAncestor:getLowestCommonAncestor,getParentInstance:function(inst){\"_hostNode\"in inst?void 0:invariant(!1,\"getParentInstance: Invalid argument.\");return inst._hostParent},traverseTwoPhase:function(inst,fn,arg){for(var path=[];inst;)path.push(inst),inst=inst._hostParent;for(inst=path.length;0<inst--;)fn(path[inst],\"captured\",arg);for(inst=0;inst<path.length;inst++)fn(path[inst],\"bubbled\",arg)},traverseEnterLeave:function(from,\nto,fn,argFrom,argTo){for(var common=from&&to?getLowestCommonAncestor(from,to):null,pathFrom=[];from&&from!==common;)pathFrom.push(from),from=from._hostParent;for(from=[];to&&to!==common;)from.push(to),to=to._hostParent;for(to=0;to<pathFrom.length;to++)fn(pathFrom[to],\"bubbled\",argFrom);for(to=from.length;0<to--;)fn(from[to],\"captured\",argTo)}}}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$ReactDOMTreeTraversal\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = tempA._hostParent) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = tempB._hostParent) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = instA._hostParent;\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = instB._hostParent;\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB) {\n      return instA;\n    }\n    instA = instA._hostParent;\n    instB = instB._hostParent;\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n\n  while (instB) {\n    if (instB === instA) {\n      return true;\n    }\n    instB = instB._hostParent;\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;\n\n  return inst._hostParent;\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = inst._hostParent;\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (from && from !== common) {\n    pathFrom.push(from);\n    from = from._hostParent;\n  }\n  var pathTo = [];\n  while (to && to !== common) {\n    pathTo.push(to);\n    to = to._hostParent;\n  }\n  var i;\n  for (i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (i = pathTo.length; i-- > 0;) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}\n\nmodule.exports = {\n  isAncestor: isAncestor,\n  getLowestCommonAncestor: getLowestCommonAncestor,\n  getParentInstance: getParentInstance,\n  traverseTwoPhase: traverseTwoPhase,\n  traverseEnterLeave: traverseEnterLeave\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react_dom$lib$reactProdInvariant"]],"~:properties",["^5",["getLowestCommonAncestor","traverseTwoPhase","traverseEnterLeave","getParentInstance","isAncestor"]],"~:compiled-at",1635270336850,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$ReactDOMTreeTraversal.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/ReactDOMTreeTraversal.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$ReactDOMTreeTraversal\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2015-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Return the lowest common ancestor of A and B, or null if they are in\\n * different trees.\\n */\\nfunction getLowestCommonAncestor(instA, instB) {\\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\\n\\n  var depthA = 0;\\n  for (var tempA = instA; tempA; tempA = tempA._hostParent) {\\n    depthA++;\\n  }\\n  var depthB = 0;\\n  for (var tempB = instB; tempB; tempB = tempB._hostParent) {\\n    depthB++;\\n  }\\n\\n  // If A is deeper, crawl up.\\n  while (depthA - depthB > 0) {\\n    instA = instA._hostParent;\\n    depthA--;\\n  }\\n\\n  // If B is deeper, crawl up.\\n  while (depthB - depthA > 0) {\\n    instB = instB._hostParent;\\n    depthB--;\\n  }\\n\\n  // Walk in lockstep until we find a match.\\n  var depth = depthA;\\n  while (depth--) {\\n    if (instA === instB) {\\n      return instA;\\n    }\\n    instA = instA._hostParent;\\n    instB = instB._hostParent;\\n  }\\n  return null;\\n}\\n\\n/**\\n * Return if A is an ancestor of B.\\n */\\nfunction isAncestor(instA, instB) {\\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\\n\\n  while (instB) {\\n    if (instB === instA) {\\n      return true;\\n    }\\n    instB = instB._hostParent;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Return the parent instance of the passed-in instance.\\n */\\nfunction getParentInstance(inst) {\\n  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;\\n\\n  return inst._hostParent;\\n}\\n\\n/**\\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\\n */\\nfunction traverseTwoPhase(inst, fn, arg) {\\n  var path = [];\\n  while (inst) {\\n    path.push(inst);\\n    inst = inst._hostParent;\\n  }\\n  var i;\\n  for (i = path.length; i-- > 0;) {\\n    fn(path[i], 'captured', arg);\\n  }\\n  for (i = 0; i < path.length; i++) {\\n    fn(path[i], 'bubbled', arg);\\n  }\\n}\\n\\n/**\\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\\n * should would receive a `mouseEnter` or `mouseLeave` event.\\n *\\n * Does not invoke the callback on the nearest common ancestor because nothing\\n * \\\"entered\\\" or \\\"left\\\" that element.\\n */\\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\\n  var pathFrom = [];\\n  while (from && from !== common) {\\n    pathFrom.push(from);\\n    from = from._hostParent;\\n  }\\n  var pathTo = [];\\n  while (to && to !== common) {\\n    pathTo.push(to);\\n    to = to._hostParent;\\n  }\\n  var i;\\n  for (i = 0; i < pathFrom.length; i++) {\\n    fn(pathFrom[i], 'bubbled', argFrom);\\n  }\\n  for (i = pathTo.length; i-- > 0;) {\\n    fn(pathTo[i], 'captured', argTo);\\n  }\\n}\\n\\nmodule.exports = {\\n  isAncestor: isAncestor,\\n  getLowestCommonAncestor: getLowestCommonAncestor,\\n  getParentInstance: getParentInstance,\\n  traverseTwoPhase: traverseTwoPhase,\\n  traverseEnterLeave: traverseEnterLeave\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"getLowestCommonAncestor\",\"instA\",\"instB\",\"invariant\",\"depthA\",\"tempA\",\"_hostParent\",\"depthB\",\"tempB\",\"depth\",\"isAncestor\",\"getParentInstance\",\"inst\",\"traverseTwoPhase\",\"fn\",\"arg\",\"path\",\"push\",\"i\",\"length\",\"traverseEnterLeave\",\"from\",\"to\",\"argFrom\",\"argTo\",\"common\",\"pathFrom\",\"pathTo\"]\n}\n"]