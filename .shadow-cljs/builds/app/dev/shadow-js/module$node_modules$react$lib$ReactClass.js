["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react/lib/ReactClass.js"],"~:js","shadow$provide.module$node_modules$react$lib$ReactClass=function(global,process,require,module,exports,shadow$shims){function validateTypeDef(Constructor,typeDef,location){for(var propName in typeDef)typeDef.hasOwnProperty(propName)&&warning(\"function\"===typeof typeDef[propName],\"%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.\",Constructor.displayName||\"ReactClass\",ReactPropTypeLocationNames[location],propName)}function mixSpecIntoComponent(Constructor,spec){if(spec){\"function\"===\ntypeof spec?invariant(!1,\"ReactClass: You're attempting to use a component class or function as a mixin. Instead, just use a regular object.\"):void 0;ReactElement.isValidElement(spec)?invariant(!1,\"ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object.\"):void 0;var proto=Constructor.prototype,autoBindPairs=proto.__reactAutoBindPairs;spec.hasOwnProperty(\"mixins\")&&RESERVED_SPEC_KEYS.mixins(Constructor,spec.mixins);for(var name in spec)if(spec.hasOwnProperty(name)&&\n\"mixins\"!==name){var property=spec[name],isAlreadyDefined=proto.hasOwnProperty(name),isAlreadyDefined$jscomp$0=isAlreadyDefined,name$jscomp$0=name,specPolicy=ReactClassInterface.hasOwnProperty(name$jscomp$0)?ReactClassInterface[name$jscomp$0]:null;ReactClassMixin.hasOwnProperty(name$jscomp$0)&&(\"OVERRIDE_BASE\"!==specPolicy?invariant(!1,\"ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.\",name$jscomp$0):\nvoid 0);isAlreadyDefined$jscomp$0&&(\"DEFINE_MANY\"!==specPolicy&&\"DEFINE_MANY_MERGED\"!==specPolicy?invariant(!1,\"ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.\",name$jscomp$0):void 0);if(RESERVED_SPEC_KEYS.hasOwnProperty(name))RESERVED_SPEC_KEYS[name](Constructor,property);else isAlreadyDefined$jscomp$0=ReactClassInterface.hasOwnProperty(name),\"function\"!==typeof property||isAlreadyDefined$jscomp$0||isAlreadyDefined||!1===\nspec.autobind?isAlreadyDefined?(isAlreadyDefined=ReactClassInterface[name],!isAlreadyDefined$jscomp$0||\"DEFINE_MANY_MERGED\"!==isAlreadyDefined&&\"DEFINE_MANY\"!==isAlreadyDefined?invariant(!1,\"ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.\",isAlreadyDefined,name):void 0,\"DEFINE_MANY_MERGED\"===isAlreadyDefined?proto[name]=createMergedResultFunction(proto[name],property):\"DEFINE_MANY\"===isAlreadyDefined&&(proto[name]=createChainedFunction(proto[name],property))):(proto[name]=\nproperty,\"function\"===typeof property&&spec.displayName&&(proto[name].displayName=spec.displayName+\"_\"+name)):(autoBindPairs.push(name,property),proto[name]=property)}}else proto=typeof spec,warning(\"object\"===proto&&null!==spec,\"%s: You're attempting to include a mixin that is either null or not an object. Check the mixins included by the component, as well as any mixins they include themselves. Expected object but got %s.\",Constructor.displayName||\"ReactClass\",null===spec?null:proto)}function mergeIntoWithNoDuplicateKeys(one,\ntwo){one&&two&&\"object\"===typeof one&&\"object\"===typeof two?void 0:invariant(!1,\"mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.\");for(var key in two)two.hasOwnProperty(key)&&(void 0!==one[key]?invariant(!1,\"mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.\",key):void 0,one[key]=two[key]);return one}\nfunction createMergedResultFunction(one,two){return function(){var a=one.apply(this,arguments),b=two.apply(this,arguments);if(null==a)return b;if(null==b)return a;var c={};mergeIntoWithNoDuplicateKeys(c,a);mergeIntoWithNoDuplicateKeys(c,b);return c}}function createChainedFunction(one,two){return function(){one.apply(this,arguments);two.apply(this,arguments)}}function bindAutoBindMethod(component,method){var boundMethod=method.bind(component);boundMethod.__reactBoundContext=component;boundMethod.__reactBoundMethod=\nmethod;boundMethod.__reactBoundArguments=null;var componentName=component.constructor.displayName,_bind=boundMethod.bind;boundMethod.bind=function(newThis){for(var _len=arguments.length,args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];if(newThis!==component&&null!==newThis)warning(!1,\"bind(): React component methods may only be bound to the component instance. See %s\",componentName);else if(!args.length)return warning(!1,\"bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See %s\",\ncomponentName),boundMethod;_len=_bind.apply(boundMethod,arguments);_len.__reactBoundContext=component;_len.__reactBoundMethod=method;_len.__reactBoundArguments=args;return _len};return boundMethod}require(\"module$node_modules$react$lib$reactProdInvariant\");var _assign=require(\"module$node_modules$object_assign$index\");global=require(\"module$node_modules$react$lib$ReactComponent\");var ReactElement=require(\"module$node_modules$react$lib$ReactElement\"),ReactPropTypeLocationNames=require(\"module$node_modules$react$lib$ReactPropTypeLocationNames\"),\nReactNoopUpdateQueue=require(\"module$node_modules$react$lib$ReactNoopUpdateQueue\"),emptyObject=require(\"module$node_modules$fbjs$lib$emptyObject\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),warning=require(\"module$node_modules$fbjs$lib$warning\"),injectedMixins=[],ReactClassInterface={mixins:\"DEFINE_MANY\",statics:\"DEFINE_MANY\",propTypes:\"DEFINE_MANY\",contextTypes:\"DEFINE_MANY\",childContextTypes:\"DEFINE_MANY\",getDefaultProps:\"DEFINE_MANY_MERGED\",getInitialState:\"DEFINE_MANY_MERGED\",\ngetChildContext:\"DEFINE_MANY_MERGED\",render:\"DEFINE_ONCE\",componentWillMount:\"DEFINE_MANY\",componentDidMount:\"DEFINE_MANY\",componentWillReceiveProps:\"DEFINE_MANY\",shouldComponentUpdate:\"DEFINE_ONCE\",componentWillUpdate:\"DEFINE_MANY\",componentDidUpdate:\"DEFINE_MANY\",componentWillUnmount:\"DEFINE_MANY\",updateComponent:\"OVERRIDE_BASE\"},RESERVED_SPEC_KEYS={displayName:function(Constructor,displayName){Constructor.displayName=displayName},mixins:function(Constructor,mixins){if(mixins)for(var i=0;i<mixins.length;i++)mixSpecIntoComponent(Constructor,\nmixins[i])},childContextTypes:function(Constructor,childContextTypes){validateTypeDef(Constructor,childContextTypes,\"childContext\");Constructor.childContextTypes=_assign({},Constructor.childContextTypes,childContextTypes)},contextTypes:function(Constructor,contextTypes){validateTypeDef(Constructor,contextTypes,\"context\");Constructor.contextTypes=_assign({},Constructor.contextTypes,contextTypes)},getDefaultProps:function(Constructor,getDefaultProps){Constructor.getDefaultProps=Constructor.getDefaultProps?\ncreateMergedResultFunction(Constructor.getDefaultProps,getDefaultProps):getDefaultProps},propTypes:function(Constructor,propTypes){validateTypeDef(Constructor,propTypes,\"prop\");Constructor.propTypes=_assign({},Constructor.propTypes,propTypes)},statics:function(Constructor,statics){if(statics)for(var name in statics){var property=statics[name];statics.hasOwnProperty(name)&&(name in RESERVED_SPEC_KEYS?invariant(!1,'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it as an instance property instead; it will still be accessible on the constructor.',\nname):void 0,name in Constructor?invariant(!1,\"ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.\",name):void 0,Constructor[name]=property)}},autobind:function(){}},ReactClassMixin={replaceState:function(newState,callback){this.updater.enqueueReplaceState(this,newState);callback&&this.updater.enqueueCallback(this,callback,\"replaceState\")},isMounted:function(){return this.updater.isMounted(this)}},ReactClassComponent=function(){};_assign(ReactClassComponent.prototype,\nglobal.prototype,ReactClassMixin);module.exports={createClass:function(spec){var Constructor=function(props,context,updater){warning(this instanceof Constructor,\"Something is calling a React component directly. Use a factory or JSX instead. See: https://fb.me/react-legacyfactory\");if(this.__reactAutoBindPairs.length)for(var pairs=this.__reactAutoBindPairs,i=0;i<pairs.length;i+=2)this[pairs[i]]=bindAutoBindMethod(this,pairs[i+1]);this.props=props;this.context=context;this.refs=emptyObject;this.updater=\nupdater||ReactNoopUpdateQueue;this.state=null;props=this.getInitialState?this.getInitialState():null;void 0===props&&this.getInitialState._isMockFunction&&(props=null);\"object\"!==typeof props||Array.isArray(props)?invariant(!1,\"%s.getInitialState(): must return an object or null\",Constructor.displayName||\"ReactCompositeComponent\"):void 0;this.state=props};Constructor.prototype=new ReactClassComponent;Constructor.prototype.constructor=Constructor;Constructor.prototype.__reactAutoBindPairs=[];injectedMixins.forEach(mixSpecIntoComponent.bind(null,\nConstructor));mixSpecIntoComponent(Constructor,spec);Constructor.getDefaultProps&&(Constructor.defaultProps=Constructor.getDefaultProps());Constructor.getDefaultProps&&(Constructor.getDefaultProps.isReactClassApproved={});Constructor.prototype.getInitialState&&(Constructor.prototype.getInitialState.isReactClassApproved={});Constructor.prototype.render?void 0:invariant(!1,\"createClass(...): Class specification must implement a `render` method.\");warning(!Constructor.prototype.componentShouldUpdate,\n\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",spec.displayName||\"A component\");warning(!Constructor.prototype.componentWillRecieveProps,\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",spec.displayName||\"A component\");for(var methodName in ReactClassInterface)Constructor.prototype[methodName]||(Constructor.prototype[methodName]=\nnull);return Constructor},injection:{injectMixin:function(mixin){injectedMixins.push(mixin)}}}}","~:source","shadow$provide[\"module$node_modules$react$lib$ReactClass\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n    _assign = require('object-assign');\n\nvar ReactComponent = require('./ReactComponent');\nvar ReactElement = require('./ReactElement');\nvar ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');\nvar ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\n\nvar MIXINS_KEY = 'mixins';\n\n// Helper function to allow the creation of anonymous functions which do not\n// have .name set to the name of the variable being assigned to.\nfunction identity(fn) {\n  return fn;\n}\n\n/**\n * Policies that describe methods in `ReactClassInterface`.\n */\n\n\nvar injectedMixins = [];\n\n/**\n * Composite components are higher-level components that compose other composite\n * or host components.\n *\n * To create a new type of `ReactClass`, pass a specification of\n * your new class to `React.createClass`. The only requirement of your class\n * specification is that you implement a `render` method.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return <div>Hello World</div>;\n *     }\n *   });\n *\n * The class specification supports a specific protocol of methods that have\n * special meaning (e.g. `render`). See `ReactClassInterface` for\n * more the comprehensive protocol. Any other properties and methods in the\n * class specification will be available on the prototype.\n *\n * @interface ReactClassInterface\n * @internal\n */\nvar ReactClassInterface = {\n\n  /**\n   * An array of Mixin objects to include when defining your component.\n   *\n   * @type {array}\n   * @optional\n   */\n  mixins: 'DEFINE_MANY',\n\n  /**\n   * An object containing properties and methods that should be defined on\n   * the component's constructor instead of its prototype (static methods).\n   *\n   * @type {object}\n   * @optional\n   */\n  statics: 'DEFINE_MANY',\n\n  /**\n   * Definition of prop types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  propTypes: 'DEFINE_MANY',\n\n  /**\n   * Definition of context types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  contextTypes: 'DEFINE_MANY',\n\n  /**\n   * Definition of context types this component sets for its children.\n   *\n   * @type {object}\n   * @optional\n   */\n  childContextTypes: 'DEFINE_MANY',\n\n  // ==== Definition methods ====\n\n  /**\n   * Invoked when the component is mounted. Values in the mapping will be set on\n   * `this.props` if that prop is not specified (i.e. using an `in` check).\n   *\n   * This method is invoked before `getInitialState` and therefore cannot rely\n   * on `this.state` or use `this.setState`.\n   *\n   * @return {object}\n   * @optional\n   */\n  getDefaultProps: 'DEFINE_MANY_MERGED',\n\n  /**\n   * Invoked once before the component is mounted. The return value will be used\n   * as the initial value of `this.state`.\n   *\n   *   getInitialState: function() {\n   *     return {\n   *       isOn: false,\n   *       fooBaz: new BazFoo()\n   *     }\n   *   }\n   *\n   * @return {object}\n   * @optional\n   */\n  getInitialState: 'DEFINE_MANY_MERGED',\n\n  /**\n   * @return {object}\n   * @optional\n   */\n  getChildContext: 'DEFINE_MANY_MERGED',\n\n  /**\n   * Uses props from `this.props` and state from `this.state` to render the\n   * structure of the component.\n   *\n   * No guarantees are made about when or how often this method is invoked, so\n   * it must not have side effects.\n   *\n   *   render: function() {\n   *     var name = this.props.name;\n   *     return <div>Hello, {name}!</div>;\n   *   }\n   *\n   * @return {ReactComponent}\n   * @nosideeffects\n   * @required\n   */\n  render: 'DEFINE_ONCE',\n\n  // ==== Delegate methods ====\n\n  /**\n   * Invoked when the component is initially created and about to be mounted.\n   * This may have side effects, but any external subscriptions or data created\n   * by this method must be cleaned up in `componentWillUnmount`.\n   *\n   * @optional\n   */\n  componentWillMount: 'DEFINE_MANY',\n\n  /**\n   * Invoked when the component has been mounted and has a DOM representation.\n   * However, there is no guarantee that the DOM node is in the document.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been mounted (initialized and rendered) for the first time.\n   *\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidMount: 'DEFINE_MANY',\n\n  /**\n   * Invoked before the component receives new props.\n   *\n   * Use this as an opportunity to react to a prop transition by updating the\n   * state using `this.setState`. Current props are accessed via `this.props`.\n   *\n   *   componentWillReceiveProps: function(nextProps, nextContext) {\n   *     this.setState({\n   *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n   *     });\n   *   }\n   *\n   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n   * transition may cause a state change, but the opposite is not true. If you\n   * need it, you are probably looking for `componentWillUpdate`.\n   *\n   * @param {object} nextProps\n   * @optional\n   */\n  componentWillReceiveProps: 'DEFINE_MANY',\n\n  /**\n   * Invoked while deciding if the component should be updated as a result of\n   * receiving new props, state and/or context.\n   *\n   * Use this as an opportunity to `return false` when you're certain that the\n   * transition to the new props/state/context will not require a component\n   * update.\n   *\n   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n   *     return !equal(nextProps, this.props) ||\n   *       !equal(nextState, this.state) ||\n   *       !equal(nextContext, this.context);\n   *   }\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @return {boolean} True if the component should update.\n   * @optional\n   */\n  shouldComponentUpdate: 'DEFINE_ONCE',\n\n  /**\n   * Invoked when the component is about to update due to a transition from\n   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n   * and `nextContext`.\n   *\n   * Use this as an opportunity to perform preparation before an update occurs.\n   *\n   * NOTE: You **cannot** use `this.setState()` in this method.\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @param {ReactReconcileTransaction} transaction\n   * @optional\n   */\n  componentWillUpdate: 'DEFINE_MANY',\n\n  /**\n   * Invoked when the component's DOM representation has been updated.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been updated.\n   *\n   * @param {object} prevProps\n   * @param {?object} prevState\n   * @param {?object} prevContext\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidUpdate: 'DEFINE_MANY',\n\n  /**\n   * Invoked when the component is about to be removed from its parent and have\n   * its DOM representation destroyed.\n   *\n   * Use this as an opportunity to deallocate any external resources.\n   *\n   * NOTE: There is no `componentDidUnmount` since your component will have been\n   * destroyed by that point.\n   *\n   * @optional\n   */\n  componentWillUnmount: 'DEFINE_MANY',\n\n  // ==== Advanced methods ====\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @overridable\n   */\n  updateComponent: 'OVERRIDE_BASE'\n\n};\n\n/**\n * Mapping from class specification keys to special processing functions.\n *\n * Although these are declared like instance properties in the specification\n * when defining classes using `React.createClass`, they are actually static\n * and are accessible on the constructor instead of the prototype. Despite\n * being static, they must be defined outside of the \"statics\" key under\n * which all other static methods are defined.\n */\nvar RESERVED_SPEC_KEYS = {\n  displayName: function (Constructor, displayName) {\n    Constructor.displayName = displayName;\n  },\n  mixins: function (Constructor, mixins) {\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        mixSpecIntoComponent(Constructor, mixins[i]);\n      }\n    }\n  },\n  childContextTypes: function (Constructor, childContextTypes) {\n    if (process.env.NODE_ENV !== 'production') {\n      validateTypeDef(Constructor, childContextTypes, 'childContext');\n    }\n    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);\n  },\n  contextTypes: function (Constructor, contextTypes) {\n    if (process.env.NODE_ENV !== 'production') {\n      validateTypeDef(Constructor, contextTypes, 'context');\n    }\n    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);\n  },\n  /**\n   * Special case getDefaultProps which should move into statics but requires\n   * automatic merging.\n   */\n  getDefaultProps: function (Constructor, getDefaultProps) {\n    if (Constructor.getDefaultProps) {\n      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);\n    } else {\n      Constructor.getDefaultProps = getDefaultProps;\n    }\n  },\n  propTypes: function (Constructor, propTypes) {\n    if (process.env.NODE_ENV !== 'production') {\n      validateTypeDef(Constructor, propTypes, 'prop');\n    }\n    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);\n  },\n  statics: function (Constructor, statics) {\n    mixStaticSpecIntoComponent(Constructor, statics);\n  },\n  autobind: function () {} };\n\nfunction validateTypeDef(Constructor, typeDef, location) {\n  for (var propName in typeDef) {\n    if (typeDef.hasOwnProperty(propName)) {\n      // use a warning instead of an invariant so components\n      // don't show up in prod but only in __DEV__\n      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;\n    }\n  }\n}\n\nfunction validateMethodOverride(isAlreadyDefined, name) {\n  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;\n\n  // Disallow overriding of base class methods unless explicitly allowed.\n  if (ReactClassMixin.hasOwnProperty(name)) {\n    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;\n  }\n\n  // Disallow defining methods more than once unless explicitly allowed.\n  if (isAlreadyDefined) {\n    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;\n  }\n}\n\n/**\n * Mixin helper which handles policy validation and reserved\n * specification keys when building React classes.\n */\nfunction mixSpecIntoComponent(Constructor, spec) {\n  if (!spec) {\n    if (process.env.NODE_ENV !== 'production') {\n      var typeofSpec = typeof spec;\n      var isMixinValid = typeofSpec === 'object' && spec !== null;\n\n      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;\n    }\n\n    return;\n  }\n\n  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;\n  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;\n\n  var proto = Constructor.prototype;\n  var autoBindPairs = proto.__reactAutoBindPairs;\n\n  // By handling mixins before any other properties, we ensure the same\n  // chaining order is applied to methods with DEFINE_MANY policy, whether\n  // mixins are listed before or after these methods in the spec.\n  if (spec.hasOwnProperty(MIXINS_KEY)) {\n    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n  }\n\n  for (var name in spec) {\n    if (!spec.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (name === MIXINS_KEY) {\n      // We have already handled mixins in a special case above.\n      continue;\n    }\n\n    var property = spec[name];\n    var isAlreadyDefined = proto.hasOwnProperty(name);\n    validateMethodOverride(isAlreadyDefined, name);\n\n    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n      RESERVED_SPEC_KEYS[name](Constructor, property);\n    } else {\n      // Setup methods on prototype:\n      // The following member methods should not be automatically bound:\n      // 1. Expected ReactClass methods (in the \"interface\").\n      // 2. Overridden methods (that were mixed in).\n      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n      var isFunction = typeof property === 'function';\n      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;\n\n      if (shouldAutoBind) {\n        autoBindPairs.push(name, property);\n        proto[name] = property;\n      } else {\n        if (isAlreadyDefined) {\n          var specPolicy = ReactClassInterface[name];\n\n          // These cases should already be caught by validateMethodOverride.\n          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;\n\n          // For methods which are defined more than once, call the existing\n          // methods before calling the new property, merging if appropriate.\n          if (specPolicy === 'DEFINE_MANY_MERGED') {\n            proto[name] = createMergedResultFunction(proto[name], property);\n          } else if (specPolicy === 'DEFINE_MANY') {\n            proto[name] = createChainedFunction(proto[name], property);\n          }\n        } else {\n          proto[name] = property;\n          if (process.env.NODE_ENV !== 'production') {\n            // Add verbose displayName to the function, which helps when looking\n            // at profiling tools.\n            if (typeof property === 'function' && spec.displayName) {\n              proto[name].displayName = spec.displayName + '_' + name;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction mixStaticSpecIntoComponent(Constructor, statics) {\n  if (!statics) {\n    return;\n  }\n  for (var name in statics) {\n    var property = statics[name];\n    if (!statics.hasOwnProperty(name)) {\n      continue;\n    }\n\n    var isReserved = name in RESERVED_SPEC_KEYS;\n    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;\n\n    var isInherited = name in Constructor;\n    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;\n    Constructor[name] = property;\n  }\n}\n\n/**\n * Merge two objects, but throw if both contain the same key.\n *\n * @param {object} one The first object, which is mutated.\n * @param {object} two The second object\n * @return {object} one after it has been mutated to contain everything in two.\n */\nfunction mergeIntoWithNoDuplicateKeys(one, two) {\n  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;\n\n  for (var key in two) {\n    if (two.hasOwnProperty(key)) {\n      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;\n      one[key] = two[key];\n    }\n  }\n  return one;\n}\n\n/**\n * Creates a function that invokes two functions and merges their return values.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createMergedResultFunction(one, two) {\n  return function mergedResult() {\n    var a = one.apply(this, arguments);\n    var b = two.apply(this, arguments);\n    if (a == null) {\n      return b;\n    } else if (b == null) {\n      return a;\n    }\n    var c = {};\n    mergeIntoWithNoDuplicateKeys(c, a);\n    mergeIntoWithNoDuplicateKeys(c, b);\n    return c;\n  };\n}\n\n/**\n * Creates a function that invokes two functions and ignores their return vales.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createChainedFunction(one, two) {\n  return function chainedFunction() {\n    one.apply(this, arguments);\n    two.apply(this, arguments);\n  };\n}\n\n/**\n * Binds a method to the component.\n *\n * @param {object} component Component whose method is going to be bound.\n * @param {function} method Method to be bound.\n * @return {function} The bound method.\n */\nfunction bindAutoBindMethod(component, method) {\n  var boundMethod = method.bind(component);\n  if (process.env.NODE_ENV !== 'production') {\n    boundMethod.__reactBoundContext = component;\n    boundMethod.__reactBoundMethod = method;\n    boundMethod.__reactBoundArguments = null;\n    var componentName = component.constructor.displayName;\n    var _bind = boundMethod.bind;\n    boundMethod.bind = function (newThis) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      // User is trying to bind() an autobound method; we effectively will\n      // ignore the value of \"this\" that the user is trying to use, so\n      // let's warn.\n      if (newThis !== component && newThis !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;\n      } else if (!args.length) {\n        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;\n        return boundMethod;\n      }\n      var reboundMethod = _bind.apply(boundMethod, arguments);\n      reboundMethod.__reactBoundContext = component;\n      reboundMethod.__reactBoundMethod = method;\n      reboundMethod.__reactBoundArguments = args;\n      return reboundMethod;\n    };\n  }\n  return boundMethod;\n}\n\n/**\n * Binds all auto-bound methods in a component.\n *\n * @param {object} component Component whose method is going to be bound.\n */\nfunction bindAutoBindMethods(component) {\n  var pairs = component.__reactAutoBindPairs;\n  for (var i = 0; i < pairs.length; i += 2) {\n    var autoBindKey = pairs[i];\n    var method = pairs[i + 1];\n    component[autoBindKey] = bindAutoBindMethod(component, method);\n  }\n}\n\n/**\n * Add more to the ReactClass base class. These are all legacy features and\n * therefore not already part of the modern ReactComponent.\n */\nvar ReactClassMixin = {\n\n  /**\n   * TODO: This will be deprecated because state should always keep a consistent\n   * type signature and the only use case for this, is to avoid that.\n   */\n  replaceState: function (newState, callback) {\n    this.updater.enqueueReplaceState(this, newState);\n    if (callback) {\n      this.updater.enqueueCallback(this, callback, 'replaceState');\n    }\n  },\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function () {\n    return this.updater.isMounted(this);\n  }\n};\n\nvar ReactClassComponent = function () {};\n_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);\n\n/**\n * Module for creating composite components.\n *\n * @class ReactClass\n */\nvar ReactClass = {\n\n  /**\n   * Creates a composite component class given a class specification.\n   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  createClass: function (spec) {\n    // To keep our warnings more understandable, we'll use a little hack here to\n    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\n    // unnecessarily identify a class without displayName as 'Constructor'.\n    var Constructor = identity(function (props, context, updater) {\n      // This constructor gets overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted.\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;\n      }\n\n      // Wire up auto-binding\n      if (this.__reactAutoBindPairs.length) {\n        bindAutoBindMethods(this);\n      }\n\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n\n      this.state = null;\n\n      // ReactClasses doesn't have constructors. Instead, they use the\n      // getInitialState and componentWillMount methods for initialization.\n\n      var initialState = this.getInitialState ? this.getInitialState() : null;\n      if (process.env.NODE_ENV !== 'production') {\n        // We allow auto-mocks to proceed as if they're returning null.\n        if (initialState === undefined && this.getInitialState._isMockFunction) {\n          // This is probably bad practice. Consider warning here and\n          // deprecating this convenience.\n          initialState = null;\n        }\n      }\n      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;\n\n      this.state = initialState;\n    });\n    Constructor.prototype = new ReactClassComponent();\n    Constructor.prototype.constructor = Constructor;\n    Constructor.prototype.__reactAutoBindPairs = [];\n\n    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n\n    mixSpecIntoComponent(Constructor, spec);\n\n    // Initialize the defaultProps property after all mixins have been merged.\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This is a tag to indicate that the use of these method names is ok,\n      // since it's used with createClass. If it's not, then it's likely a\n      // mistake so we'll warn you to use the static property, property\n      // initializer or constructor respectively.\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps.isReactClassApproved = {};\n      }\n      if (Constructor.prototype.getInitialState) {\n        Constructor.prototype.getInitialState.isReactClassApproved = {};\n      }\n    }\n\n    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;\n      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;\n    }\n\n    // Reduce time spent doing lookups by setting these on the prototype.\n    for (var methodName in ReactClassInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    return Constructor;\n  },\n\n  injection: {\n    injectMixin: function (mixin) {\n      injectedMixins.push(mixin);\n    }\n  }\n\n};\n\nmodule.exports = ReactClass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$object_assign$index","~$shadow.js","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react$lib$reactProdInvariant","~$module$node_modules$fbjs$lib$emptyObject","~$module$node_modules$react$lib$ReactPropTypeLocationNames","~$module$node_modules$react$lib$ReactElement","~$module$node_modules$react$lib$ReactComponent","~$module$node_modules$fbjs$lib$warning","~$module$node_modules$react$lib$ReactNoopUpdateQueue"]],"~:properties",["^5",["componentWillMount","updateComponent","__reactBoundMethod","getChildContext","updater","childContextTypes","autobind","prototype","injection","__reactBoundContext","mixins","displayName","bind","statics","propTypes","getDefaultProps","injectMixin","context","componentDidUpdate","getInitialState","contextTypes","replaceState","componentDidMount","props","defaultProps","__reactAutoBindPairs","shouldComponentUpdate","render","componentWillUpdate","state","isReactClassApproved","componentWillUnmount","componentWillReceiveProps","createClass","isMounted","__reactBoundArguments","constructor","refs"]],"~:compiled-at",1635270336782,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react$lib$ReactClass.js\",\n\"lineCount\":20,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react/lib/ReactClass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react$lib$ReactClass\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant'),\\n    _assign = require('object-assign');\\n\\nvar ReactComponent = require('./ReactComponent');\\nvar ReactElement = require('./ReactElement');\\nvar ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');\\nvar ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');\\n\\nvar emptyObject = require('fbjs/lib/emptyObject');\\nvar invariant = require('fbjs/lib/invariant');\\nvar warning = require('fbjs/lib/warning');\\n\\nvar MIXINS_KEY = 'mixins';\\n\\n// Helper function to allow the creation of anonymous functions which do not\\n// have .name set to the name of the variable being assigned to.\\nfunction identity(fn) {\\n  return fn;\\n}\\n\\n/**\\n * Policies that describe methods in `ReactClassInterface`.\\n */\\n\\n\\nvar injectedMixins = [];\\n\\n/**\\n * Composite components are higher-level components that compose other composite\\n * or host components.\\n *\\n * To create a new type of `ReactClass`, pass a specification of\\n * your new class to `React.createClass`. The only requirement of your class\\n * specification is that you implement a `render` method.\\n *\\n *   var MyComponent = React.createClass({\\n *     render: function() {\\n *       return <div>Hello World</div>;\\n *     }\\n *   });\\n *\\n * The class specification supports a specific protocol of methods that have\\n * special meaning (e.g. `render`). See `ReactClassInterface` for\\n * more the comprehensive protocol. Any other properties and methods in the\\n * class specification will be available on the prototype.\\n *\\n * @interface ReactClassInterface\\n * @internal\\n */\\nvar ReactClassInterface = {\\n\\n  /**\\n   * An array of Mixin objects to include when defining your component.\\n   *\\n   * @type {array}\\n   * @optional\\n   */\\n  mixins: 'DEFINE_MANY',\\n\\n  /**\\n   * An object containing properties and methods that should be defined on\\n   * the component's constructor instead of its prototype (static methods).\\n   *\\n   * @type {object}\\n   * @optional\\n   */\\n  statics: 'DEFINE_MANY',\\n\\n  /**\\n   * Definition of prop types for this component.\\n   *\\n   * @type {object}\\n   * @optional\\n   */\\n  propTypes: 'DEFINE_MANY',\\n\\n  /**\\n   * Definition of context types for this component.\\n   *\\n   * @type {object}\\n   * @optional\\n   */\\n  contextTypes: 'DEFINE_MANY',\\n\\n  /**\\n   * Definition of context types this component sets for its children.\\n   *\\n   * @type {object}\\n   * @optional\\n   */\\n  childContextTypes: 'DEFINE_MANY',\\n\\n  // ==== Definition methods ====\\n\\n  /**\\n   * Invoked when the component is mounted. Values in the mapping will be set on\\n   * `this.props` if that prop is not specified (i.e. using an `in` check).\\n   *\\n   * This method is invoked before `getInitialState` and therefore cannot rely\\n   * on `this.state` or use `this.setState`.\\n   *\\n   * @return {object}\\n   * @optional\\n   */\\n  getDefaultProps: 'DEFINE_MANY_MERGED',\\n\\n  /**\\n   * Invoked once before the component is mounted. The return value will be used\\n   * as the initial value of `this.state`.\\n   *\\n   *   getInitialState: function() {\\n   *     return {\\n   *       isOn: false,\\n   *       fooBaz: new BazFoo()\\n   *     }\\n   *   }\\n   *\\n   * @return {object}\\n   * @optional\\n   */\\n  getInitialState: 'DEFINE_MANY_MERGED',\\n\\n  /**\\n   * @return {object}\\n   * @optional\\n   */\\n  getChildContext: 'DEFINE_MANY_MERGED',\\n\\n  /**\\n   * Uses props from `this.props` and state from `this.state` to render the\\n   * structure of the component.\\n   *\\n   * No guarantees are made about when or how often this method is invoked, so\\n   * it must not have side effects.\\n   *\\n   *   render: function() {\\n   *     var name = this.props.name;\\n   *     return <div>Hello, {name}!</div>;\\n   *   }\\n   *\\n   * @return {ReactComponent}\\n   * @nosideeffects\\n   * @required\\n   */\\n  render: 'DEFINE_ONCE',\\n\\n  // ==== Delegate methods ====\\n\\n  /**\\n   * Invoked when the component is initially created and about to be mounted.\\n   * This may have side effects, but any external subscriptions or data created\\n   * by this method must be cleaned up in `componentWillUnmount`.\\n   *\\n   * @optional\\n   */\\n  componentWillMount: 'DEFINE_MANY',\\n\\n  /**\\n   * Invoked when the component has been mounted and has a DOM representation.\\n   * However, there is no guarantee that the DOM node is in the document.\\n   *\\n   * Use this as an opportunity to operate on the DOM when the component has\\n   * been mounted (initialized and rendered) for the first time.\\n   *\\n   * @param {DOMElement} rootNode DOM element representing the component.\\n   * @optional\\n   */\\n  componentDidMount: 'DEFINE_MANY',\\n\\n  /**\\n   * Invoked before the component receives new props.\\n   *\\n   * Use this as an opportunity to react to a prop transition by updating the\\n   * state using `this.setState`. Current props are accessed via `this.props`.\\n   *\\n   *   componentWillReceiveProps: function(nextProps, nextContext) {\\n   *     this.setState({\\n   *       likesIncreasing: nextProps.likeCount > this.props.likeCount\\n   *     });\\n   *   }\\n   *\\n   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\\n   * transition may cause a state change, but the opposite is not true. If you\\n   * need it, you are probably looking for `componentWillUpdate`.\\n   *\\n   * @param {object} nextProps\\n   * @optional\\n   */\\n  componentWillReceiveProps: 'DEFINE_MANY',\\n\\n  /**\\n   * Invoked while deciding if the component should be updated as a result of\\n   * receiving new props, state and/or context.\\n   *\\n   * Use this as an opportunity to `return false` when you're certain that the\\n   * transition to the new props/state/context will not require a component\\n   * update.\\n   *\\n   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\\n   *     return !equal(nextProps, this.props) ||\\n   *       !equal(nextState, this.state) ||\\n   *       !equal(nextContext, this.context);\\n   *   }\\n   *\\n   * @param {object} nextProps\\n   * @param {?object} nextState\\n   * @param {?object} nextContext\\n   * @return {boolean} True if the component should update.\\n   * @optional\\n   */\\n  shouldComponentUpdate: 'DEFINE_ONCE',\\n\\n  /**\\n   * Invoked when the component is about to update due to a transition from\\n   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\\n   * and `nextContext`.\\n   *\\n   * Use this as an opportunity to perform preparation before an update occurs.\\n   *\\n   * NOTE: You **cannot** use `this.setState()` in this method.\\n   *\\n   * @param {object} nextProps\\n   * @param {?object} nextState\\n   * @param {?object} nextContext\\n   * @param {ReactReconcileTransaction} transaction\\n   * @optional\\n   */\\n  componentWillUpdate: 'DEFINE_MANY',\\n\\n  /**\\n   * Invoked when the component's DOM representation has been updated.\\n   *\\n   * Use this as an opportunity to operate on the DOM when the component has\\n   * been updated.\\n   *\\n   * @param {object} prevProps\\n   * @param {?object} prevState\\n   * @param {?object} prevContext\\n   * @param {DOMElement} rootNode DOM element representing the component.\\n   * @optional\\n   */\\n  componentDidUpdate: 'DEFINE_MANY',\\n\\n  /**\\n   * Invoked when the component is about to be removed from its parent and have\\n   * its DOM representation destroyed.\\n   *\\n   * Use this as an opportunity to deallocate any external resources.\\n   *\\n   * NOTE: There is no `componentDidUnmount` since your component will have been\\n   * destroyed by that point.\\n   *\\n   * @optional\\n   */\\n  componentWillUnmount: 'DEFINE_MANY',\\n\\n  // ==== Advanced methods ====\\n\\n  /**\\n   * Updates the component's currently mounted DOM representation.\\n   *\\n   * By default, this implements React's rendering and reconciliation algorithm.\\n   * Sophisticated clients may wish to override this.\\n   *\\n   * @param {ReactReconcileTransaction} transaction\\n   * @internal\\n   * @overridable\\n   */\\n  updateComponent: 'OVERRIDE_BASE'\\n\\n};\\n\\n/**\\n * Mapping from class specification keys to special processing functions.\\n *\\n * Although these are declared like instance properties in the specification\\n * when defining classes using `React.createClass`, they are actually static\\n * and are accessible on the constructor instead of the prototype. Despite\\n * being static, they must be defined outside of the \\\"statics\\\" key under\\n * which all other static methods are defined.\\n */\\nvar RESERVED_SPEC_KEYS = {\\n  displayName: function (Constructor, displayName) {\\n    Constructor.displayName = displayName;\\n  },\\n  mixins: function (Constructor, mixins) {\\n    if (mixins) {\\n      for (var i = 0; i < mixins.length; i++) {\\n        mixSpecIntoComponent(Constructor, mixins[i]);\\n      }\\n    }\\n  },\\n  childContextTypes: function (Constructor, childContextTypes) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      validateTypeDef(Constructor, childContextTypes, 'childContext');\\n    }\\n    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);\\n  },\\n  contextTypes: function (Constructor, contextTypes) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      validateTypeDef(Constructor, contextTypes, 'context');\\n    }\\n    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);\\n  },\\n  /**\\n   * Special case getDefaultProps which should move into statics but requires\\n   * automatic merging.\\n   */\\n  getDefaultProps: function (Constructor, getDefaultProps) {\\n    if (Constructor.getDefaultProps) {\\n      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);\\n    } else {\\n      Constructor.getDefaultProps = getDefaultProps;\\n    }\\n  },\\n  propTypes: function (Constructor, propTypes) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      validateTypeDef(Constructor, propTypes, 'prop');\\n    }\\n    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);\\n  },\\n  statics: function (Constructor, statics) {\\n    mixStaticSpecIntoComponent(Constructor, statics);\\n  },\\n  autobind: function () {} };\\n\\nfunction validateTypeDef(Constructor, typeDef, location) {\\n  for (var propName in typeDef) {\\n    if (typeDef.hasOwnProperty(propName)) {\\n      // use a warning instead of an invariant so components\\n      // don't show up in prod but only in __DEV__\\n      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;\\n    }\\n  }\\n}\\n\\nfunction validateMethodOverride(isAlreadyDefined, name) {\\n  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;\\n\\n  // Disallow overriding of base class methods unless explicitly allowed.\\n  if (ReactClassMixin.hasOwnProperty(name)) {\\n    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;\\n  }\\n\\n  // Disallow defining methods more than once unless explicitly allowed.\\n  if (isAlreadyDefined) {\\n    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;\\n  }\\n}\\n\\n/**\\n * Mixin helper which handles policy validation and reserved\\n * specification keys when building React classes.\\n */\\nfunction mixSpecIntoComponent(Constructor, spec) {\\n  if (!spec) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      var typeofSpec = typeof spec;\\n      var isMixinValid = typeofSpec === 'object' && spec !== null;\\n\\n      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\\\\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;\\n    }\\n\\n    return;\\n  }\\n\\n  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\\\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;\\n  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\\\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;\\n\\n  var proto = Constructor.prototype;\\n  var autoBindPairs = proto.__reactAutoBindPairs;\\n\\n  // By handling mixins before any other properties, we ensure the same\\n  // chaining order is applied to methods with DEFINE_MANY policy, whether\\n  // mixins are listed before or after these methods in the spec.\\n  if (spec.hasOwnProperty(MIXINS_KEY)) {\\n    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\\n  }\\n\\n  for (var name in spec) {\\n    if (!spec.hasOwnProperty(name)) {\\n      continue;\\n    }\\n\\n    if (name === MIXINS_KEY) {\\n      // We have already handled mixins in a special case above.\\n      continue;\\n    }\\n\\n    var property = spec[name];\\n    var isAlreadyDefined = proto.hasOwnProperty(name);\\n    validateMethodOverride(isAlreadyDefined, name);\\n\\n    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\\n      RESERVED_SPEC_KEYS[name](Constructor, property);\\n    } else {\\n      // Setup methods on prototype:\\n      // The following member methods should not be automatically bound:\\n      // 1. Expected ReactClass methods (in the \\\"interface\\\").\\n      // 2. Overridden methods (that were mixed in).\\n      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\\n      var isFunction = typeof property === 'function';\\n      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;\\n\\n      if (shouldAutoBind) {\\n        autoBindPairs.push(name, property);\\n        proto[name] = property;\\n      } else {\\n        if (isAlreadyDefined) {\\n          var specPolicy = ReactClassInterface[name];\\n\\n          // These cases should already be caught by validateMethodOverride.\\n          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;\\n\\n          // For methods which are defined more than once, call the existing\\n          // methods before calling the new property, merging if appropriate.\\n          if (specPolicy === 'DEFINE_MANY_MERGED') {\\n            proto[name] = createMergedResultFunction(proto[name], property);\\n          } else if (specPolicy === 'DEFINE_MANY') {\\n            proto[name] = createChainedFunction(proto[name], property);\\n          }\\n        } else {\\n          proto[name] = property;\\n          if (process.env.NODE_ENV !== 'production') {\\n            // Add verbose displayName to the function, which helps when looking\\n            // at profiling tools.\\n            if (typeof property === 'function' && spec.displayName) {\\n              proto[name].displayName = spec.displayName + '_' + name;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nfunction mixStaticSpecIntoComponent(Constructor, statics) {\\n  if (!statics) {\\n    return;\\n  }\\n  for (var name in statics) {\\n    var property = statics[name];\\n    if (!statics.hasOwnProperty(name)) {\\n      continue;\\n    }\\n\\n    var isReserved = name in RESERVED_SPEC_KEYS;\\n    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\\\\'t be on the \\\"statics\\\" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;\\n\\n    var isInherited = name in Constructor;\\n    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;\\n    Constructor[name] = property;\\n  }\\n}\\n\\n/**\\n * Merge two objects, but throw if both contain the same key.\\n *\\n * @param {object} one The first object, which is mutated.\\n * @param {object} two The second object\\n * @return {object} one after it has been mutated to contain everything in two.\\n */\\nfunction mergeIntoWithNoDuplicateKeys(one, two) {\\n  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;\\n\\n  for (var key in two) {\\n    if (two.hasOwnProperty(key)) {\\n      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;\\n      one[key] = two[key];\\n    }\\n  }\\n  return one;\\n}\\n\\n/**\\n * Creates a function that invokes two functions and merges their return values.\\n *\\n * @param {function} one Function to invoke first.\\n * @param {function} two Function to invoke second.\\n * @return {function} Function that invokes the two argument functions.\\n * @private\\n */\\nfunction createMergedResultFunction(one, two) {\\n  return function mergedResult() {\\n    var a = one.apply(this, arguments);\\n    var b = two.apply(this, arguments);\\n    if (a == null) {\\n      return b;\\n    } else if (b == null) {\\n      return a;\\n    }\\n    var c = {};\\n    mergeIntoWithNoDuplicateKeys(c, a);\\n    mergeIntoWithNoDuplicateKeys(c, b);\\n    return c;\\n  };\\n}\\n\\n/**\\n * Creates a function that invokes two functions and ignores their return vales.\\n *\\n * @param {function} one Function to invoke first.\\n * @param {function} two Function to invoke second.\\n * @return {function} Function that invokes the two argument functions.\\n * @private\\n */\\nfunction createChainedFunction(one, two) {\\n  return function chainedFunction() {\\n    one.apply(this, arguments);\\n    two.apply(this, arguments);\\n  };\\n}\\n\\n/**\\n * Binds a method to the component.\\n *\\n * @param {object} component Component whose method is going to be bound.\\n * @param {function} method Method to be bound.\\n * @return {function} The bound method.\\n */\\nfunction bindAutoBindMethod(component, method) {\\n  var boundMethod = method.bind(component);\\n  if (process.env.NODE_ENV !== 'production') {\\n    boundMethod.__reactBoundContext = component;\\n    boundMethod.__reactBoundMethod = method;\\n    boundMethod.__reactBoundArguments = null;\\n    var componentName = component.constructor.displayName;\\n    var _bind = boundMethod.bind;\\n    boundMethod.bind = function (newThis) {\\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n        args[_key - 1] = arguments[_key];\\n      }\\n\\n      // User is trying to bind() an autobound method; we effectively will\\n      // ignore the value of \\\"this\\\" that the user is trying to use, so\\n      // let's warn.\\n      if (newThis !== component && newThis !== null) {\\n        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;\\n      } else if (!args.length) {\\n        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;\\n        return boundMethod;\\n      }\\n      var reboundMethod = _bind.apply(boundMethod, arguments);\\n      reboundMethod.__reactBoundContext = component;\\n      reboundMethod.__reactBoundMethod = method;\\n      reboundMethod.__reactBoundArguments = args;\\n      return reboundMethod;\\n    };\\n  }\\n  return boundMethod;\\n}\\n\\n/**\\n * Binds all auto-bound methods in a component.\\n *\\n * @param {object} component Component whose method is going to be bound.\\n */\\nfunction bindAutoBindMethods(component) {\\n  var pairs = component.__reactAutoBindPairs;\\n  for (var i = 0; i < pairs.length; i += 2) {\\n    var autoBindKey = pairs[i];\\n    var method = pairs[i + 1];\\n    component[autoBindKey] = bindAutoBindMethod(component, method);\\n  }\\n}\\n\\n/**\\n * Add more to the ReactClass base class. These are all legacy features and\\n * therefore not already part of the modern ReactComponent.\\n */\\nvar ReactClassMixin = {\\n\\n  /**\\n   * TODO: This will be deprecated because state should always keep a consistent\\n   * type signature and the only use case for this, is to avoid that.\\n   */\\n  replaceState: function (newState, callback) {\\n    this.updater.enqueueReplaceState(this, newState);\\n    if (callback) {\\n      this.updater.enqueueCallback(this, callback, 'replaceState');\\n    }\\n  },\\n\\n  /**\\n   * Checks whether or not this composite component is mounted.\\n   * @return {boolean} True if mounted, false otherwise.\\n   * @protected\\n   * @final\\n   */\\n  isMounted: function () {\\n    return this.updater.isMounted(this);\\n  }\\n};\\n\\nvar ReactClassComponent = function () {};\\n_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);\\n\\n/**\\n * Module for creating composite components.\\n *\\n * @class ReactClass\\n */\\nvar ReactClass = {\\n\\n  /**\\n   * Creates a composite component class given a class specification.\\n   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\\n   *\\n   * @param {object} spec Class specification (which must define `render`).\\n   * @return {function} Component constructor function.\\n   * @public\\n   */\\n  createClass: function (spec) {\\n    // To keep our warnings more understandable, we'll use a little hack here to\\n    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\\n    // unnecessarily identify a class without displayName as 'Constructor'.\\n    var Constructor = identity(function (props, context, updater) {\\n      // This constructor gets overridden by mocks. The argument is used\\n      // by mocks to assert on what gets mounted.\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;\\n      }\\n\\n      // Wire up auto-binding\\n      if (this.__reactAutoBindPairs.length) {\\n        bindAutoBindMethods(this);\\n      }\\n\\n      this.props = props;\\n      this.context = context;\\n      this.refs = emptyObject;\\n      this.updater = updater || ReactNoopUpdateQueue;\\n\\n      this.state = null;\\n\\n      // ReactClasses doesn't have constructors. Instead, they use the\\n      // getInitialState and componentWillMount methods for initialization.\\n\\n      var initialState = this.getInitialState ? this.getInitialState() : null;\\n      if (process.env.NODE_ENV !== 'production') {\\n        // We allow auto-mocks to proceed as if they're returning null.\\n        if (initialState === undefined && this.getInitialState._isMockFunction) {\\n          // This is probably bad practice. Consider warning here and\\n          // deprecating this convenience.\\n          initialState = null;\\n        }\\n      }\\n      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;\\n\\n      this.state = initialState;\\n    });\\n    Constructor.prototype = new ReactClassComponent();\\n    Constructor.prototype.constructor = Constructor;\\n    Constructor.prototype.__reactAutoBindPairs = [];\\n\\n    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\\n\\n    mixSpecIntoComponent(Constructor, spec);\\n\\n    // Initialize the defaultProps property after all mixins have been merged.\\n    if (Constructor.getDefaultProps) {\\n      Constructor.defaultProps = Constructor.getDefaultProps();\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      // This is a tag to indicate that the use of these method names is ok,\\n      // since it's used with createClass. If it's not, then it's likely a\\n      // mistake so we'll warn you to use the static property, property\\n      // initializer or constructor respectively.\\n      if (Constructor.getDefaultProps) {\\n        Constructor.getDefaultProps.isReactClassApproved = {};\\n      }\\n      if (Constructor.prototype.getInitialState) {\\n        Constructor.prototype.getInitialState.isReactClassApproved = {};\\n      }\\n    }\\n\\n    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;\\n      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;\\n    }\\n\\n    // Reduce time spent doing lookups by setting these on the prototype.\\n    for (var methodName in ReactClassInterface) {\\n      if (!Constructor.prototype[methodName]) {\\n        Constructor.prototype[methodName] = null;\\n      }\\n    }\\n\\n    return Constructor;\\n  },\\n\\n  injection: {\\n    injectMixin: function (mixin) {\\n      injectedMixins.push(mixin);\\n    }\\n  }\\n\\n};\\n\\nmodule.exports = ReactClass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"validateTypeDef\",\"Constructor\",\"typeDef\",\"location\",\"propName\",\"hasOwnProperty\",\"warning\",\"displayName\",\"ReactPropTypeLocationNames\",\"mixSpecIntoComponent\",\"spec\",\"invariant\",\"ReactElement\",\"isValidElement\",\"proto\",\"prototype\",\"autoBindPairs\",\"__reactAutoBindPairs\",\"MIXINS_KEY\",\"RESERVED_SPEC_KEYS\",\"mixins\",\"name\",\"property\",\"isAlreadyDefined\",\"specPolicy\",\"ReactClassInterface\",\"ReactClassMixin\",\"isReactClassMethod\",\"autobind\",\"createMergedResultFunction\",\"createChainedFunction\",\"push\",\"typeofSpec\",\"mergeIntoWithNoDuplicateKeys\",\"one\",\"two\",\"key\",\"undefined\",\"mergedResult\",\"a\",\"apply\",\"arguments\",\"b\",\"c\",\"chainedFunction\",\"bindAutoBindMethod\",\"component\",\"method\",\"boundMethod\",\"bind\",\"__reactBoundContext\",\"__reactBoundMethod\",\"__reactBoundArguments\",\"componentName\",\"constructor\",\"_bind\",\"boundMethod.bind\",\"newThis\",\"_len\",\"length\",\"args\",\"Array\",\"_key\",\"reboundMethod\",\"_assign\",\"ReactComponent\",\"ReactNoopUpdateQueue\",\"emptyObject\",\"injectedMixins\",\"statics\",\"propTypes\",\"contextTypes\",\"childContextTypes\",\"getDefaultProps\",\"getInitialState\",\"getChildContext\",\"render\",\"componentWillMount\",\"componentDidMount\",\"componentWillReceiveProps\",\"shouldComponentUpdate\",\"componentWillUpdate\",\"componentDidUpdate\",\"componentWillUnmount\",\"updateComponent\",\"i\",\"replaceState\",\"newState\",\"callback\",\"updater\",\"enqueueReplaceState\",\"enqueueCallback\",\"isMounted\",\"ReactClassComponent\",\"ReactClass\",\"createClass\",\"fn\",\"props\",\"context\",\"pairs\",\"autoBindKey\",\"refs\",\"state\",\"initialState\",\"_isMockFunction\",\"isArray\",\"forEach\",\"defaultProps\",\"isReactClassApproved\",\"componentShouldUpdate\",\"componentWillRecieveProps\",\"methodName\",\"injection\",\"injectMixin\",\"mixin\"]\n}\n"]