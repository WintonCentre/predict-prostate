["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-dom/lib/EventPluginHub.js"],"~:js","shadow$provide.module$node_modules$react_dom$lib$EventPluginHub=function(global,process,require,module,exports,shadow$shims){require(\"module$node_modules$react_dom$lib$reactProdInvariant\");var EventPluginRegistry=require(\"module$node_modules$react_dom$lib$EventPluginRegistry\"),EventPluginUtils=require(\"module$node_modules$react_dom$lib$EventPluginUtils\"),ReactErrorUtils=require(\"module$node_modules$react_dom$lib$ReactErrorUtils\"),accumulateInto=require(\"module$node_modules$react_dom$lib$accumulateInto\"),\nforEachAccumulated=require(\"module$node_modules$react_dom$lib$forEachAccumulated\"),invariant=require(\"module$node_modules$fbjs$lib$invariant\"),listenerBank={},eventQueue=null,executeDispatchesAndRelease=function(event,simulated){event&&(EventPluginUtils.executeDispatchesInOrder(event,simulated),event.isPersistent()||event.constructor.release(event))},executeDispatchesAndReleaseSimulated=function(e){return executeDispatchesAndRelease(e,!0)},executeDispatchesAndReleaseTopLevel=function(e){return executeDispatchesAndRelease(e,\n!1)};module.exports={injection:{injectEventPluginOrder:EventPluginRegistry.injectEventPluginOrder,injectEventPluginsByName:EventPluginRegistry.injectEventPluginsByName},putListener:function(inst,registrationName,listener){\"function\"!==typeof listener?invariant(!1,\"Expected %s listener to be a function, instead got type %s\",registrationName,typeof listener):void 0;var key=\".\"+inst._rootNodeID;(listenerBank[registrationName]||(listenerBank[registrationName]={}))[key]=listener;(key=EventPluginRegistry.registrationNameModules[registrationName])&&\nkey.didPutListener&&key.didPutListener(inst,registrationName,listener)},getListener:function(inst,registrationName){var bankForRegistrationName=listenerBank[registrationName];a:switch(registrationName){case \"onClick\":case \"onClickCapture\":case \"onDoubleClick\":case \"onDoubleClickCapture\":case \"onMouseDown\":case \"onMouseDownCapture\":case \"onMouseMove\":case \"onMouseMoveCapture\":case \"onMouseUp\":case \"onMouseUpCapture\":(registrationName=!inst._currentElement.props.disabled)||(registrationName=inst._currentElement.type,\nregistrationName=!(\"button\"===registrationName||\"input\"===registrationName||\"select\"===registrationName||\"textarea\"===registrationName));registrationName=!registrationName;break a;default:registrationName=!1}if(registrationName)return null;inst=\".\"+inst._rootNodeID;return bankForRegistrationName&&bankForRegistrationName[inst]},deleteListener:function(inst,registrationName){var PluginModule=EventPluginRegistry.registrationNameModules[registrationName];PluginModule&&PluginModule.willDeleteListener&&\nPluginModule.willDeleteListener(inst,registrationName);(registrationName=listenerBank[registrationName])&&delete registrationName[\".\"+inst._rootNodeID]},deleteAllListeners:function(inst){var key=\".\"+inst._rootNodeID,registrationName;for(registrationName in listenerBank)if(listenerBank.hasOwnProperty(registrationName)&&listenerBank[registrationName][key]){var PluginModule=EventPluginRegistry.registrationNameModules[registrationName];PluginModule&&PluginModule.willDeleteListener&&PluginModule.willDeleteListener(inst,\nregistrationName);delete listenerBank[registrationName][key]}},extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){for(var events,plugins=EventPluginRegistry.plugins,i=0;i<plugins.length;i++){var possiblePlugin=plugins[i];possiblePlugin&&(possiblePlugin=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget))&&(events=accumulateInto(events,possiblePlugin))}return events},enqueueEvents:function(events){events&&(eventQueue=accumulateInto(eventQueue,\nevents))},processEventQueue:function(simulated){var processingEventQueue=eventQueue;eventQueue=null;simulated?forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated):forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);eventQueue?invariant(!1,\"processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.\"):void 0;ReactErrorUtils.rethrowCaughtError()},__purge:function(){listenerBank=\n{}},__getListenerBank:function(){return listenerBank}}}","~:source","shadow$provide[\"module$node_modules$react_dom$lib$EventPluginHub\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar EventPluginRegistry = require('./EventPluginRegistry');\nvar EventPluginUtils = require('./EventPluginUtils');\nvar ReactErrorUtils = require('./ReactErrorUtils');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Internal store for event listeners\n */\nvar listenerBank = {};\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    EventPluginUtils.executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nvar getDictionaryKey = function (inst) {\n  // Prevents V8 performance issue:\n  // https://github.com/facebook/react/pull/7232\n  return '.' + inst._rootNodeID;\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\nvar EventPluginHub = {\n\n  /**\n   * Methods for injecting dependencies.\n   */\n  injection: {\n\n    /**\n     * @param {array} InjectedEventPluginOrder\n     * @public\n     */\n    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,\n\n    /**\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     */\n    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName\n\n  },\n\n  /**\n   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.\n   *\n   * @param {object} inst The instance, which is the source of events.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {function} listener The callback to store.\n   */\n  putListener: function (inst, registrationName, listener) {\n    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;\n\n    var key = getDictionaryKey(inst);\n    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});\n    bankForRegistrationName[key] = listener;\n\n    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\n    if (PluginModule && PluginModule.didPutListener) {\n      PluginModule.didPutListener(inst, registrationName, listener);\n    }\n  },\n\n  /**\n   * @param {object} inst The instance, which is the source of events.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @return {?function} The stored callback.\n   */\n  getListener: function (inst, registrationName) {\n    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n    // live here; needs to be moved to a better place soon\n    var bankForRegistrationName = listenerBank[registrationName];\n    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {\n      return null;\n    }\n    var key = getDictionaryKey(inst);\n    return bankForRegistrationName && bankForRegistrationName[key];\n  },\n\n  /**\n   * Deletes a listener from the registration bank.\n   *\n   * @param {object} inst The instance, which is the source of events.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   */\n  deleteListener: function (inst, registrationName) {\n    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\n    if (PluginModule && PluginModule.willDeleteListener) {\n      PluginModule.willDeleteListener(inst, registrationName);\n    }\n\n    var bankForRegistrationName = listenerBank[registrationName];\n    // TODO: This should never be null -- when is it?\n    if (bankForRegistrationName) {\n      var key = getDictionaryKey(inst);\n      delete bankForRegistrationName[key];\n    }\n  },\n\n  /**\n   * Deletes all listeners for the DOM element with the supplied ID.\n   *\n   * @param {object} inst The instance, which is the source of events.\n   */\n  deleteAllListeners: function (inst) {\n    var key = getDictionaryKey(inst);\n    for (var registrationName in listenerBank) {\n      if (!listenerBank.hasOwnProperty(registrationName)) {\n        continue;\n      }\n\n      if (!listenerBank[registrationName][key]) {\n        continue;\n      }\n\n      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\n      if (PluginModule && PluginModule.willDeleteListener) {\n        PluginModule.willDeleteListener(inst, registrationName);\n      }\n\n      delete listenerBank[registrationName][key];\n    }\n  },\n\n  /**\n   * Allows registered plugins an opportunity to extract events from top-level\n   * native browser events.\n   *\n   * @return {*} An accumulation of synthetic events.\n   * @internal\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var events;\n    var plugins = EventPluginRegistry.plugins;\n    for (var i = 0; i < plugins.length; i++) {\n      // Not every plugin in the ordering may be loaded at runtime.\n      var possiblePlugin = plugins[i];\n      if (possiblePlugin) {\n        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n        if (extractedEvents) {\n          events = accumulateInto(events, extractedEvents);\n        }\n      }\n    }\n    return events;\n  },\n\n  /**\n   * Enqueues a synthetic event that should be dispatched when\n   * `processEventQueue` is invoked.\n   *\n   * @param {*} events An accumulation of synthetic events.\n   * @internal\n   */\n  enqueueEvents: function (events) {\n    if (events) {\n      eventQueue = accumulateInto(eventQueue, events);\n    }\n  },\n\n  /**\n   * Dispatches all synthetic events on the event queue.\n   *\n   * @internal\n   */\n  processEventQueue: function (simulated) {\n    // Set `eventQueue` to null before processing it so that we can tell if more\n    // events get enqueued while processing.\n    var processingEventQueue = eventQueue;\n    eventQueue = null;\n    if (simulated) {\n      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n    } else {\n      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n    }\n    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;\n    // This would be a good time to rethrow if any of the event handlers threw.\n    ReactErrorUtils.rethrowCaughtError();\n  },\n\n  /**\n   * These are needed for tests only. Do not use!\n   */\n  __purge: function () {\n    listenerBank = {};\n  },\n\n  __getListenerBank: function () {\n    return listenerBank;\n  }\n\n};\n\nmodule.exports = EventPluginHub;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_dom$lib$ReactErrorUtils","~$module$node_modules$react_dom$lib$EventPluginRegistry","~$shadow.js","~$module$node_modules$react_dom$lib$EventPluginUtils","~$module$node_modules$fbjs$lib$invariant","~$module$node_modules$react_dom$lib$reactProdInvariant","~$module$node_modules$react_dom$lib$forEachAccumulated","~$module$node_modules$react_dom$lib$accumulateInto"]],"~:properties",["^5",["enqueueEvents","deleteAllListeners","putListener","injection","__getListenerBank","injectEventPluginOrder","getListener","__purge","injectEventPluginsByName","extractEvents","deleteListener","processEventQueue"]],"~:compiled-at",1635270336808,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_dom$lib$EventPluginHub.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-dom/lib/EventPluginHub.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_dom$lib$EventPluginHub\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/**\\n * Copyright 2013-present, Facebook, Inc.\\n * All rights reserved.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n *\\n */\\n\\n'use strict';\\n\\nvar _prodInvariant = require('./reactProdInvariant');\\n\\nvar EventPluginRegistry = require('./EventPluginRegistry');\\nvar EventPluginUtils = require('./EventPluginUtils');\\nvar ReactErrorUtils = require('./ReactErrorUtils');\\n\\nvar accumulateInto = require('./accumulateInto');\\nvar forEachAccumulated = require('./forEachAccumulated');\\nvar invariant = require('fbjs/lib/invariant');\\n\\n/**\\n * Internal store for event listeners\\n */\\nvar listenerBank = {};\\n\\n/**\\n * Internal queue of events that have accumulated their dispatches and are\\n * waiting to have their dispatches executed.\\n */\\nvar eventQueue = null;\\n\\n/**\\n * Dispatches an event and releases it back into the pool, unless persistent.\\n *\\n * @param {?object} event Synthetic event to be dispatched.\\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\\n * @private\\n */\\nvar executeDispatchesAndRelease = function (event, simulated) {\\n  if (event) {\\n    EventPluginUtils.executeDispatchesInOrder(event, simulated);\\n\\n    if (!event.isPersistent()) {\\n      event.constructor.release(event);\\n    }\\n  }\\n};\\nvar executeDispatchesAndReleaseSimulated = function (e) {\\n  return executeDispatchesAndRelease(e, true);\\n};\\nvar executeDispatchesAndReleaseTopLevel = function (e) {\\n  return executeDispatchesAndRelease(e, false);\\n};\\n\\nvar getDictionaryKey = function (inst) {\\n  // Prevents V8 performance issue:\\n  // https://github.com/facebook/react/pull/7232\\n  return '.' + inst._rootNodeID;\\n};\\n\\nfunction isInteractive(tag) {\\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\\n}\\n\\nfunction shouldPreventMouseEvent(name, type, props) {\\n  switch (name) {\\n    case 'onClick':\\n    case 'onClickCapture':\\n    case 'onDoubleClick':\\n    case 'onDoubleClickCapture':\\n    case 'onMouseDown':\\n    case 'onMouseDownCapture':\\n    case 'onMouseMove':\\n    case 'onMouseMoveCapture':\\n    case 'onMouseUp':\\n    case 'onMouseUpCapture':\\n      return !!(props.disabled && isInteractive(type));\\n    default:\\n      return false;\\n  }\\n}\\n\\n/**\\n * This is a unified interface for event plugins to be installed and configured.\\n *\\n * Event plugins can implement the following properties:\\n *\\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\\n *     Required. When a top-level event is fired, this method is expected to\\n *     extract synthetic events that will in turn be queued and dispatched.\\n *\\n *   `eventTypes` {object}\\n *     Optional, plugins that fire events must publish a mapping of registration\\n *     names that are used to register listeners. Values of this mapping must\\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\\n *\\n *   `executeDispatch` {function(object, function, string)}\\n *     Optional, allows plugins to override how an event gets dispatched. By\\n *     default, the listener is simply invoked.\\n *\\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\\n *\\n * @public\\n */\\nvar EventPluginHub = {\\n\\n  /**\\n   * Methods for injecting dependencies.\\n   */\\n  injection: {\\n\\n    /**\\n     * @param {array} InjectedEventPluginOrder\\n     * @public\\n     */\\n    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,\\n\\n    /**\\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\\n     */\\n    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName\\n\\n  },\\n\\n  /**\\n   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.\\n   *\\n   * @param {object} inst The instance, which is the source of events.\\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\\n   * @param {function} listener The callback to store.\\n   */\\n  putListener: function (inst, registrationName, listener) {\\n    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;\\n\\n    var key = getDictionaryKey(inst);\\n    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});\\n    bankForRegistrationName[key] = listener;\\n\\n    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\\n    if (PluginModule && PluginModule.didPutListener) {\\n      PluginModule.didPutListener(inst, registrationName, listener);\\n    }\\n  },\\n\\n  /**\\n   * @param {object} inst The instance, which is the source of events.\\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\\n   * @return {?function} The stored callback.\\n   */\\n  getListener: function (inst, registrationName) {\\n    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\\n    // live here; needs to be moved to a better place soon\\n    var bankForRegistrationName = listenerBank[registrationName];\\n    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {\\n      return null;\\n    }\\n    var key = getDictionaryKey(inst);\\n    return bankForRegistrationName && bankForRegistrationName[key];\\n  },\\n\\n  /**\\n   * Deletes a listener from the registration bank.\\n   *\\n   * @param {object} inst The instance, which is the source of events.\\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\\n   */\\n  deleteListener: function (inst, registrationName) {\\n    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\\n    if (PluginModule && PluginModule.willDeleteListener) {\\n      PluginModule.willDeleteListener(inst, registrationName);\\n    }\\n\\n    var bankForRegistrationName = listenerBank[registrationName];\\n    // TODO: This should never be null -- when is it?\\n    if (bankForRegistrationName) {\\n      var key = getDictionaryKey(inst);\\n      delete bankForRegistrationName[key];\\n    }\\n  },\\n\\n  /**\\n   * Deletes all listeners for the DOM element with the supplied ID.\\n   *\\n   * @param {object} inst The instance, which is the source of events.\\n   */\\n  deleteAllListeners: function (inst) {\\n    var key = getDictionaryKey(inst);\\n    for (var registrationName in listenerBank) {\\n      if (!listenerBank.hasOwnProperty(registrationName)) {\\n        continue;\\n      }\\n\\n      if (!listenerBank[registrationName][key]) {\\n        continue;\\n      }\\n\\n      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\\n      if (PluginModule && PluginModule.willDeleteListener) {\\n        PluginModule.willDeleteListener(inst, registrationName);\\n      }\\n\\n      delete listenerBank[registrationName][key];\\n    }\\n  },\\n\\n  /**\\n   * Allows registered plugins an opportunity to extract events from top-level\\n   * native browser events.\\n   *\\n   * @return {*} An accumulation of synthetic events.\\n   * @internal\\n   */\\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\\n    var events;\\n    var plugins = EventPluginRegistry.plugins;\\n    for (var i = 0; i < plugins.length; i++) {\\n      // Not every plugin in the ordering may be loaded at runtime.\\n      var possiblePlugin = plugins[i];\\n      if (possiblePlugin) {\\n        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\\n        if (extractedEvents) {\\n          events = accumulateInto(events, extractedEvents);\\n        }\\n      }\\n    }\\n    return events;\\n  },\\n\\n  /**\\n   * Enqueues a synthetic event that should be dispatched when\\n   * `processEventQueue` is invoked.\\n   *\\n   * @param {*} events An accumulation of synthetic events.\\n   * @internal\\n   */\\n  enqueueEvents: function (events) {\\n    if (events) {\\n      eventQueue = accumulateInto(eventQueue, events);\\n    }\\n  },\\n\\n  /**\\n   * Dispatches all synthetic events on the event queue.\\n   *\\n   * @internal\\n   */\\n  processEventQueue: function (simulated) {\\n    // Set `eventQueue` to null before processing it so that we can tell if more\\n    // events get enqueued while processing.\\n    var processingEventQueue = eventQueue;\\n    eventQueue = null;\\n    if (simulated) {\\n      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\\n    } else {\\n      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\\n    }\\n    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;\\n    // This would be a good time to rethrow if any of the event handlers threw.\\n    ReactErrorUtils.rethrowCaughtError();\\n  },\\n\\n  /**\\n   * These are needed for tests only. Do not use!\\n   */\\n  __purge: function () {\\n    listenerBank = {};\\n  },\\n\\n  __getListenerBank: function () {\\n    return listenerBank;\\n  }\\n\\n};\\n\\nmodule.exports = EventPluginHub;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"EventPluginRegistry\",\"EventPluginUtils\",\"ReactErrorUtils\",\"accumulateInto\",\"forEachAccumulated\",\"invariant\",\"listenerBank\",\"eventQueue\",\"executeDispatchesAndRelease\",\"event\",\"simulated\",\"executeDispatchesInOrder\",\"isPersistent\",\"constructor\",\"release\",\"executeDispatchesAndReleaseSimulated\",\"e\",\"executeDispatchesAndReleaseTopLevel\",\"EventPluginHub\",\"injection\",\"injectEventPluginOrder\",\"injectEventPluginsByName\",\"putListener\",\"inst\",\"registrationName\",\"listener\",\"key\",\"_rootNodeID\",\"PluginModule\",\"registrationNameModules\",\"didPutListener\",\"getListener\",\"bankForRegistrationName\",\"disabled\",\"tag\",\"deleteListener\",\"willDeleteListener\",\"deleteAllListeners\",\"hasOwnProperty\",\"extractEvents\",\"topLevelType\",\"targetInst\",\"nativeEvent\",\"nativeEventTarget\",\"events\",\"plugins\",\"i\",\"length\",\"possiblePlugin\",\"extractedEvents\",\"enqueueEvents\",\"processEventQueue\",\"processingEventQueue\",\"rethrowCaughtError\",\"__purge\",\"__getListenerBank\"]\n}\n"]